<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Swipe Runner</title>
  <style>
    :root {
      --bg1: #0f2027;
      --bg2: #203a43;
      --bg3: #2c5364;
      --card: rgba(12,14,16,0.82);
      --text: #ffffff;
      --accent: #00e5ff;
      --danger: #ff4d6d;
      --safe: #32d74b;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, var(--bg1), var(--bg2), var(--bg3));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .app {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    header {
      width: 100%;
      max-width: 840px;
      padding: env(safe-area-inset-top) 16px 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      z-index: 3;
    }
    .tag {
      background: var(--card);
      color: #fff;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      font-weight: 700;
      letter-spacing: 0.3px;
      pointer-events: auto;
      user-select: none;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .btn {
      appearance: none;
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      background: var(--accent);
      color: #002b36;
      font-weight: 800;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: transform 0.08s ease, filter 0.2s ease, background 0.2s ease;
      pointer-events: auto;
      user-select: none;
    }
    .btn.secondary { background: rgba(255,255,255,0.95); color: #0b1720; }
    .btn:active { transform: scale(0.98); }
    .stage {
      position: relative;
      width: 100%;
      max-width: 840px;
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px 12px 12px;
    }
    canvas {
      width: 100%;
      height: 100%;
      max-height: calc(100vh - 120px);
      background: radial-gradient(1200px 800px at 50% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0) 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0) 40%);
      border-radius: 16px;
      box-shadow: var(--shadow);
      touch-action: none;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 4;
      padding: 24px;
      pointer-events: none;
    }
    .overlay.show { display: flex; }
    .card {
      pointer-events: auto;
      width: 100%;
      max-width: 460px;
      background: rgba(12,14,16,0.85);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 22px;
      text-align: center;
      box-shadow: var(--shadow);
      animation: pop 220ms ease-out;
      color: #fff;
    }
    @keyframes pop {
      from { transform: scale(0.96); opacity: 0; }
      to   { transform: scale(1); opacity: 1; }
    }
    h1 {
      font-size: clamp(20px, 3.8vw, 28px);
      margin: 0 0 8px 0;
    }
    p { margin: 8px 0; opacity: 0.95; }
    .controls {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .hint {
      margin-top: 8px;
      font-size: 0.95rem;
      opacity: 0.9;
    }
    .laneGuide {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      opacity: 0.1;
    }
    .touchZones {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      z-index: 2;
      pointer-events: auto;
      touch-action: none;
    }
    .touchZones > div { touch-action: manipulation; }
    .footer {
      width: 100%;
      max-width: 840px;
      padding: 0 16px 16px 16px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .sr {
      position: absolute;
      width: 1px;
      height: 1px;
      margin: -1px;
      border: 0;
      padding: 0;
      clip: rect(0 0 0 0);
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="row">
        <div class="tag" id="scoreTag" aria-live="polite" aria-atomic="true">Score: 0</div>
        <div class="tag" id="speedTag">Speed: 1x</div>
      </div>
      <div class="row">
        <div class="tag" id="bestTag">Best: 0</div>
        <button class="btn secondary" id="pauseBtn" aria-pressed="false">Pause</button>
      </div>
    </header>

    <div class="stage">
      <canvas id="game" aria-label="Swipe Runner Game" role="img"></canvas>

      <div class="overlay show" id="menu">
        <div class="card">
          <h1>Swipe Runner</h1>
          <p>Swipe left or right to change lanes. Avoid red blocks. Survive to score!</p>
          <div class="controls">
            <button class="btn" id="startBtn">Tap to Start</button>
            <button class="btn secondary" id="howBtn">How to Play</button>
          </div>
          <p class="hint">Desktop: Arrow keys or A/D.</p>
        </div>
      </div>

      <div class="overlay" id="help">
        <div class="card">
          <h1>How to Play</h1>
          <p>• Swipe left/right anywhere on the game to move between lanes.</p>
          <p>• Tap left/right side of the screen to nudge a lane.</p>
          <p>• Avoid red obstacles. Survive to increase your score.</p>
          <p>• Your best score is saved automatically.</p>
          <div class="controls">
            <button class="btn" id="closeHelp">Got it</button>
            <button class="btn secondary" id="startFromHelp">Start</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="gameover">
        <div class="card" id="gameoverCard">
          <h1>Game Over</h1>
          <p id="finalScore">Score: 0</p>
          <p id="bestScore">Best: 0</p>
          <div class="controls">
            <button class="btn" id="retryBtn">Play Again</button>
            <button class="btn secondary" id="menuBtn">Main Menu</button>
          </div>
          <p class="hint">Tip: Quick swipes give snappy lane changes.</p>
        </div>
      </div>

      <svg class="laneGuide" id="laneGuide" preserveAspectRatio="none"></svg>

      <div class="touchZones" id="tapZones" aria-hidden="true">
        <div id="zoneLeft"></div>
        <div id="zoneRight"></div>
      </div>
    </div>

    <div class="footer">
      <span class="tag">Built for mobile. Swipe to play!</span>
    </div>
  </div>

  <script>
    (function() {
      "use strict";

      // Utility helpers
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const rand = (min, max) => Math.random() * (max - min) + min;

      // DOM references
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR for performance

      const scoreTag = document.getElementById("scoreTag");
      const speedTag = document.getElementById("speedTag");
      const bestTag = document.getElementById("bestTag");

      const overlayMenu = document.getElementById("menu");
      const overlayHelp = document.getElementById("help");
      const overlayGameOver = document.getElementById("gameover");

      const startBtn = document.getElementById("startBtn");
      const howBtn = document.getElementById("howBtn");
      const closeHelpBtn = document.getElementById("closeHelp");
      const startFromHelpBtn = document.getElementById("startFromHelp");
      const retryBtn = document.getElementById("retryBtn");
      const menuBtn = document.getElementById("menuBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const finalScore = document.getElementById("finalScore");
      const bestScore = document.getElementById("bestScore");

      const tapZones = document.getElementById("tapZones");
      const zoneLeft = document.getElementById("zoneLeft");
      const zoneRight = document.getElementById("zoneRight");
      const laneGuide = document.getElementById("laneGuide");

      const BEST_KEY = "swipeRunnerBestScoreV1";

      // Game state
      const state = {
        running: false,
        paused: false,
        gameOver: false,
        width: 0,
        height: 0,
        lanes: 3,
        laneWidth: 0,
        laneX: [],
        player: {
          lane: 1,
          x: 0,
          y: 0,
          width: 44,
          height: 64,
          color: "#00e5ff",
          moveCooldown: 0
        },
        obstacles: [],
        obstacleSpeed: 180,
        obstacleAccel: 1.003,
        spawnEvery: 800,
        minSpawnEvery: 350,
        lastSpawn: 0,
        score: 0,
        best: Number(localStorage.getItem(BEST_KEY) || 0),
        lastTime: 0,
        startedAt: 0
      };

      // Resize and DPI handling
      function resize() {
        const rect = canvas.getBoundingClientRect();
        const cssW = Math.floor(rect.width);
        const cssH = Math.floor(rect.height);

        canvas.width = Math.max(300, cssW) * dpr;
        canvas.height = Math.max(400, cssH) * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        state.width = cssW;
        state.height = cssH;

        // Update lane metrics
        state.laneWidth = Math.floor(cssW / state.lanes);
        state.laneX = [];
        for (let i = 0; i < state.lanes; i++) {
          state.laneX.push(Math.floor(i * state.laneWidth + state.laneWidth / 2));
        }

        // Position player near bottom
        state.player.width = Math.max(36, Math.min(64, Math.floor(state.laneWidth * 0.55)));
        state.player.height = Math.floor(state.player.width * 1.35);
        state.player.y = Math.floor(state.height - state.player.height - Math.max(20, state.height * 0.06));
        updatePlayerX();

        drawLaneGuide();
      }

      function drawLaneGuide() {
        // Draw faint lane dividers using SVG to stay crisp on resize
        laneGuide.innerHTML = "";
        const w = state.width;
        const h = state.height;
        laneGuide.setAttribute("viewBox", `0 0 ${w} ${h}`);
        for (let i = 1; i < state.lanes; i++) {
          const x = i * state.laneWidth;
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", x);
          line.setAttribute("y1", "0");
          line.setAttribute("x2", x);
          line.setAttribute("y2", h);
          line.setAttribute("stroke", "white");
          line.setAttribute("stroke-width", "2");
          line.setAttribute("stroke-dasharray", "6,10");
          laneGuide.appendChild(line);
        }
      }

      function updatePlayerX() {
        state.player.lane = clamp(state.player.lane, 0, state.lanes - 1);
        state.player.x = Math.floor(state.laneX[state.player.lane] - state.player.width / 2);
      }

      // Game control helpers
      function resetGame() {
        state.running = true;
        state.paused = false;
        state.gameOver = false;
        state.score = 0;
        state.obstacles = [];
        state.obstacleSpeed = 200 + Math.max(0, (state.best / 500) * 40);
        state.spawnEvery = 800;
        state.lastSpawn = 0;
        state.player.lane = 1;
        state.player.moveCooldown = 0;
        updatePlayerX();
        state.lastTime = performance.now();
        state.startedAt = state.lastTime;

        overlayMenu.classList.remove("show");
        overlayHelp.classList.remove("show");
        overlayGameOver.classList.remove("show");
        pauseBtn.setAttribute("aria-pressed", "false");
        renderHUD();
      }

      function gameOver() {
        state.running = false;
        state.gameOver = true;
        overlayGameOver.classList.add("show");
        finalScore.textContent = `Score: ${Math.floor(state.score)}`;
        if (state.score > state.best) {
          state.best = Math.floor(state.score);
          localStorage.setItem(BEST_KEY, String(state.best));
        }
        bestScore.textContent = `Best: ${state.best}`;
      }

      function togglePause(force) {
        if (!state.running) return;
        const target = (typeof force === "boolean") ? force : !state.paused;
        state.paused = target;
        pauseBtn.textContent = target ? "Resume" : "Pause";
        pauseBtn.setAttribute("aria-pressed", target ? "true" : "false");
      }

      // Rendering
      function clear() {
        ctx.clearRect(0, 0, state.width, state.height);
      }

      function drawPlayer() {
        const p = state.player;
        ctx.save();
        ctx.shadowColor = "rgba(0, 229, 255, 0.6)";
        ctx.shadowBlur = 20;
        ctx.fillStyle = p.color;
        roundRect(ctx, p.x, p.y, p.width, p.height, 10);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = "rgba(255,255,255,0.85)";
        const ww = Math.floor(p.width * 0.6);
        const wh = Math.floor(p.height * 0.28);
        const wx = p.x + (p.width - ww) / 2;
        const wy = p.y + p.height * 0.16;
        roundRect(ctx, wx, wy, ww, wh, 6);
        ctx.fill();
      }

      function drawObstacles() {
        for (const o of state.obstacles) {
          ctx.save();
          ctx.shadowColor = "rgba(255,77,109,0.55)";
          ctx.shadowBlur = 18;
          ctx.fillStyle = "#ff4d6d";
          roundRect(ctx, o.x, o.y, o.w, o.h, 8);
          ctx.fill();
          ctx.restore();
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        const min = Math.min(w, h);
        const rad = Math.min(r, min / 2);
        ctx.beginPath();
        ctx.moveTo(x + rad, y);
        ctx.arcTo(x + w, y, x + w, y + h, rad);
        ctx.arcTo(x + w, y + h, x, y + h, rad);
        ctx.arcTo(x, y + h, x, y, rad);
        ctx.arcTo(x, y, x + w, y, rad);
        ctx.closePath();
      }

      function renderHUD() {
        scoreTag.textContent = `Score: ${Math.floor(state.score)}`;
        speedTag.textContent = `Speed: ${(state.obstacleSpeed / 200).toFixed(1)}x`;
        bestTag.textContent = `Best: ${state.best}`;
      }

      // Spawn obstacles
      function spawnObstacle() {
        const lane = Math.floor(rand(0, state.lanes));
        const w = Math.max(30, Math.min(70, Math.floor(state.laneWidth * rand(0.45, 0.7))));
        const h = Math.floor(w * rand(0.9, 1.35));
        const x = Math.floor(state.laneX[lane] - w / 2);
        const gapTop = -h - rand(10, 100);
        state.obstacles.push({
          lane,
          x,
          y: gapTop,
          w,
          h,
          speed: state.obstacleSpeed * rand(0.95, 1.1)
        });
      }

      function moveLane(dir) {
        if (state.paused || !state.running) return;
        if (state.player.moveCooldown > 0) return;
        state.player.lane += dir;
        state.player.lane = clamp(state.player.lane, 0, state.lanes - 1);
        updatePlayerX();
        state.player.moveCooldown = 80;
      }

      // Collision detection
      function intersects(ax, ay, aw, ah, bx, by, bw, bh) {
        return ax < bx + bw &&
               ax + aw > bx &&
               ay < by + bh &&
               ay + ah > by;
      }

      // Game loop
      function loop(now) {
        requestAnimationFrame(loop);
        if (!state.running || state.paused) {
          state.lastTime = now;
          return;
        }
        const dt = Math.min(50, now - state.lastTime);
        state.lastTime = now;

        if (state.player.moveCooldown > 0) {
          state.player.moveCooldown -= dt;
          if (state.player.moveCooldown < 0) state.player.moveCooldown = 0;
        }

        state.lastSpawn += dt;
        const dynamicSpawn = Math.max(state.minSpawnEvery, state.spawnEvery - Math.floor((now - state.startedAt) / 20));
        if (state.lastSpawn >= dynamicSpawn) {
          spawnObstacle();
          state.lastSpawn = 0;
        }

        state.obstacleSpeed *= state.obstacleAccel;
        for (const o of state.obstacles) {
          o.speed *= state.obstacleAccel * 1.0005;
        }

        const remove = [];
        for (let i = 0; i < state.obstacles.length; i++) {
          const o = state.obstacles[i];
          o.y += (o.speed * dt) / 1000;
          if (o.y > state.height + 60) {
            remove.push(i);
            state.score += 10;
          }
        }
        for (let i = remove.length - 1; i >= 0; i--) {
          state.obstacles.splice(remove[i], 1);
        }

        const p = state.player;
        for (const o of state.obstacles) {
          if (intersects(p.x, p.y, p.width, p.height, o.x, o.y, o.w, o.h)) {
            gameOver();
            break;
          }
        }

        state.score += dt * 0.02;

        clear();
        drawObstacles();
        drawPlayer();
        renderHUD();
      }

      // Input: Keyboard
      window.addEventListener("keydown", (e) => {
        if (overlayMenu.classList.contains("show")) return;
        switch (e.key) {
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            moveLane(-1);
            break;
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            moveLane(1);
            break;
          case " ":
          case "Spacebar":
          case "Enter":
            e.preventDefault();
            togglePause();
            break;
          case "Escape":
            if (state.running) togglePause(true);
            break;
        }
      }, { passive: false });

      // Input: Touch (swipes + taps)
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartT = 0;
      let touchMoved = false;

      function onTouchStart(ev) {
        if (ev.touches && ev.touches.length > 1) return;
        const t = ev.touches ? ev.touches[0] : ev;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartT = performance.now();
        touchMoved = false;
      }

      function onTouchMove(ev) {
        if (!touchStartT) return;
        const t = ev.touches ? ev.touches[0] : ev;
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) touchMoved = true;
      }

      function onTouchEnd(ev) {
        if (!touchStartT) return;
        const endT = performance.now();
        const changed = ev.changedTouches ? ev.changedTouches[0] : ev;
        const dx = changed.clientX - touchStartX;
        const dy = changed.clientY - touchStartY;
        const dt = endT - touchStartT;

        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        const swipeThreshold = Math.max(24, Math.min(60, state.width * 0.06));
        const fastSwipeTime = 300;

        if ((absX > absY && absX > swipeThreshold) || (absX > 14 && dt < fastSwipeTime)) {
          moveLane(dx > 0 ? 1 : -1);
        } else if (!touchMoved && dt < 220) {
          // Quick tap nudges based on screen side
          const rect = canvas.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;
          moveLane(changed.clientX > midX ? 1 : -1);
        }

        touchStartT = 0;
        touchMoved = false;
      }

      // Tap zones for extra accessibility (left/right half screen)
      zoneLeft.addEventListener("click", () => moveLane(-1));
      zoneRight.addEventListener("click", () => moveLane(1));

      // Bind touch events to the tap zone layer so it doesn't get blocked by overlays
      const touchTarget = tapZones;
      touchTarget.addEventListener("touchstart", onTouchStart, { passive: true });
      touchTarget.addEventListener("touchmove", onTouchMove, { passive: true });
      touchTarget.addEventListener("touchend", onTouchEnd, { passive: true });
      touchTarget.addEventListener("pointerdown", onTouchStart, { passive: true });
      touchTarget.addEventListener("pointermove", onTouchMove, { passive: true });
      touchTarget.addEventListener("pointerup", onTouchEnd, { passive: true });

      // UI event bindings
      startBtn.addEventListener("click", () => resetGame());
      howBtn.addEventListener("click", () => {
        overlayHelp.classList.add("show");
        overlayMenu.classList.remove("show");
      });
      closeHelpBtn.addEventListener("click", () => {
        overlayHelp.classList.remove("show");
        overlayMenu.classList.add("show");
      });
      startFromHelpBtn.addEventListener("click", () => resetGame());
      retryBtn.addEventListener("click", () => resetGame());
      menuBtn.addEventListener("click", () => {
        overlayGameOver.classList.remove("show");
        overlayMenu.classList.add("show");
      });
      pauseBtn.addEventListener("click", () => togglePause());

      // Initial best score
      bestTag.textContent = `Best: ${state.best}`;

      // Resize listener
      const ro = new ResizeObserver(resize);
      ro.observe(document.querySelector(".stage"));

      // Start loop
      requestAnimationFrame((t) => { state.lastTime = t; loop(t); });

      // Initial layout
      resize();
    })();
  </script>
</body>
</html>