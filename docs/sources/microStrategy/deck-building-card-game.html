<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Card Climber - A Tiny Deckbuilder</title>
<style>
  :root{
    --bg:#0f1220;
    --panel:#171b2f;
    --panel2:#1f2440;
    --accent:#6bd5ff;
    --accent2:#66ffa1;
    --danger:#ff6b6b;
    --warn:#ffc857;
    --card:#222845;
    --text:#e9f1ff;
    --muted:#a9b4d1;
    --attack:#ff7a7a;
    --skill:#6bd5ff;
    --power:#ffe27a;
    --shadow:0 10px 30px rgba(0,0,0,0.35);
    --radius:14px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; margin:0; background:radial-gradient(1200px 1200px at 75% -100px, #1f2550 0%, transparent 60%) , linear-gradient(160deg, #0c0e1a 0%, #101430 65%, #0b0e1b 100%); color:var(--text); font-family:system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji","Segoe UI Emoji"; overflow:hidden;}
  #game{
    display:flex; flex-direction:column; height:100%; width:100%;
  }
  .topbar{
    display:flex; align-items:center; justify-content:space-between;
    padding:10px 12px; gap:8px; background:linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    border-bottom:1px solid rgba(255,255,255,0.06);
  }
  .top-left, .top-right{display:flex; align-items:center; gap:8px;}
  .badge{
    background:var(--panel2); padding:8px 10px; border-radius:12px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.06);
    display:flex; align-items:center; gap:8px; font-weight:700;
  }
  .badge small{font-weight:600; opacity:.8;}
  .btn{
    appearance:none; border:none; padding:10px 14px; border-radius:12px; font-weight:800; color:#0d1224; background:var(--accent);
    cursor:pointer; transition:transform .05s ease, box-shadow .2s ease, background .2s ease; box-shadow:0 6px 0 #1a809f, var(--shadow);
    user-select:none; -webkit-user-select:none;
  }
  .btn:active{transform:translateY(2px); box-shadow:0 3px 0 #1a809f, var(--shadow);}
  .btn.secondary{background:#96a6ff; box-shadow:0 6px 0 #4a56ad, var(--shadow);}
  .btn.warn{background:var(--warn); box-shadow:0 6px 0 #a5812b, var(--shadow);}
  .btn.ghost{background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.15); box-shadow:none;}
  .flex{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .spacer{flex:1}
  .arena{
    position:relative; flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:12px;
    padding:10px;
  }
  .board{
    position:relative; width:100%; max-width:1100px; height:100%; display:grid; grid-template-rows:auto 1fr; gap:10px;
  }
  .enemy-area{
    position:relative; display:flex; justify-content:center; align-items:flex-start; padding-top:10px;
  }
  .enemy{
    width:min(70vw, 520px); max-width:520px; min-height:180px; border-radius:var(--radius); background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.08); box-shadow:var(--shadow);
    display:flex; gap:16px; padding:16px; position:relative; overflow:hidden;
  }
  .enemy:before{
    content:""; position:absolute; inset:-25% -10% auto -10%; height:160%; background:radial-gradient(300px 120px at 50% 10%, rgba(107,213,255,0.15), transparent 60%);
    transform:rotate(-5deg);
  }
  .enemy-art{
    width:36%; min-width:140px; aspect-ratio:1/1; border-radius:16px; background:linear-gradient(140deg, #2a335f, #1a1f3f);
    border:1px solid rgba(255,255,255,0.06);
    display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden;
  }
  .blob{
    width:70%; height:70%; border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #77e0ff, #4caad6 60%, #36678a 100%);
    box-shadow: inset 0 0 40px rgba(255,255,255,0.25), 0 10px 30px rgba(0,0,0,.5);
    position:relative; animation:float 3s ease-in-out infinite;
  }
  .blob:after{
    content:""; position:absolute; inset:auto 10% 12% 10%; height:18%; background:radial-gradient(50% 50% at 50% 50%, rgba(255,255,255,0.25), transparent); filter:blur(8px);
  }
  @keyframes float { 0%,100%{ transform:translateY(0)} 50%{ transform:translateY(-6px)} }
  .enemy-info{flex:1; display:flex; flex-direction:column; gap:8px;}
  .name{font-weight:900; letter-spacing:.5px; font-size:20px;}
  .hpbar, .pbar{
    position:relative; height:16px; border-radius:10px; background:#0b0f21; border:1px solid rgba(255,255,255,0.08); overflow:hidden;
  }
  .hpbar .fill{position:absolute; inset:0 auto 0 0; width:100%; background:linear-gradient(90deg, #ff6b6b, #ffa36b); transition:width .3s;}
  .pbar .fill{position:absolute; inset:0 auto 0 0; width:100%; background:linear-gradient(90deg, #6bd5ff, #96ffa6); transition:width .2s;}
  .bars{display:grid; grid-template-columns:1fr; gap:8px;}
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .stat{
    display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1);
    font-weight:700;
  }
  .stat .ico{width:18px; height:18px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; color:#0b0f21; font-size:12px; font-weight:900;}
  .ico.hp{background:var(--danger);}
  .ico.en{background:var(--accent2);}
  .ico.bl{background:#9ecbff; color:#0a1530}
  .ico.vu{background:#ffb86b;}
  .intent{
    display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px; border:1px dashed rgba(255,255,255,0.2);
    background:rgba(255,255,255,0.03); font-weight:800; color:#fff;
  }
  .hand-area{
    position:relative; width:100%; max-width:1100px; margin:0 auto;
    display:flex; flex-direction:column; gap:10px; padding:0 6px 8px;
  }
  .controls{ display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;}
  .piles{ display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .pile{ background:var(--panel2); border:1px solid rgba(255,255,255,.08); padding:6px 10px; border-radius:10px; font-weight:700;}
  .hand{
    display:flex; gap:10px; overflow-x:auto; padding:6px; -webkit-overflow-scrolling:touch; scrollbar-width:none;
  }
  .hand::-webkit-scrollbar{display:none;}
  .card{
    min-width:150px; width:150px; max-width:28vw;
    aspect-ratio:2/3; background:linear-gradient(160deg, #262c4f 0%, #1b2140 60%); border:2px solid rgba(255,255,255,0.08); border-radius:16px;
    box-shadow:0 10px 24px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,0.06);
    padding:10px; display:flex; flex-direction:column; gap:6px; position:relative; cursor:pointer; user-select:none; -webkit-user-select:none;
    transition: transform .12s ease, filter .2s ease, opacity .2s ease;
  }
  .card.disabled{filter:grayscale(.9) brightness(.8); opacity:.7; cursor:not-allowed;}
  .card:active{transform:scale(.98) translateY(2px);}
  .cost{
    position:absolute; top:8px; left:8px; width:32px; height:32px; border-radius:50%; background:var(--accent);
    display:flex; align-items:center; justify-content:center; color:#0a1030; font-weight:900; border:2px solid rgba(255,255,255,0.4);
    box-shadow:inset 0 -2px 0 rgba(0,0,0,.25);
  }
  .card .title{font-weight:900; font-size:16px; margin-top:22px;}
  .card .type{font-size:12px; color:var(--muted); font-weight:700; letter-spacing:.5px;}
  .card .desc{margin-top:auto; font-size:13px; color:#e9f1ff;}
  .tag{
    position:absolute; right:8px; top:8px; font-size:11px; font-weight:800; padding:3px 8px; border-radius:999px; color:#0a1030;
  }
  .tag.attack{background:var(--attack);}
  .tag.skill{background:var(--skill); color:#001c2a;}
  .tag.power{background:var(--power);}
  .endturn{
    font-size:16px; padding:12px 16px; border-radius:14px; font-weight:900; letter-spacing:.5px;
  }
  .playerbar{
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
  }
  .big-stats{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  }
  .stack{display:flex; align-items:center; gap:6px; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.1); padding:8px 12px; border-radius:12px;}
  .titlebar{
    font-weight:900; font-size:18px; letter-spacing:1px; opacity:.9;
  }
  .floating{
    position:absolute; pointer-events:none; font-weight:900; text-shadow:0 2px 0 rgba(0,0,0,.35); animation:pop 800ms ease-out forwards;
  }
  @keyframes pop{
    0%{ transform:translateY(0) scale(1); opacity:1}
    70%{ transform:translateY(-24px) scale(1.1); opacity:1}
    100%{ transform:translateY(-40px) scale(1.05); opacity:0}
  }
  .overlay{
    position:fixed; inset:0; background:rgba(8,10,20,0.7); display:none; align-items:center; justify-content:center; padding:16px; z-index:10;
  }
  .overlay.show{display:flex;}
  .modal{
    width:min(900px, 96vw); max-height:92vh; overflow:auto;
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border:1px solid rgba(255,255,255,0.12);
    border-radius:18px; padding:16px; box-shadow:var(--shadow); backdrop-filter: blur(8px);
  }
  .modal h2{margin:0 0 8px 0; font-size:22px;}
  .modal p{margin:6px 0 10px; color:var(--muted); font-weight:600;}
  .choices{display:flex; gap:12px; flex-wrap:wrap;}
  .choice-card{transform-origin:center; transition:transform .12s ease;}
  .choice-card:active{transform:scale(.98) translateY(2px);}
  .center{text-align:center;}
  .footer-actions{display:flex; justify-content:flex-end; gap:8px; margin-top:10px;}
  .small{font-size:12px; color:var(--muted); font-weight:700;}
  .sep{height:1px; background:rgba(255,255,255,0.08); margin:10px 0;}
  @media (max-width: 680px){
    .enemy{width:95%; gap:12px;}
    .card{min-width:136px; width:136px;}
    .topbar .badge{padding:6px 8px;}
    .btn{padding:9px 12px;}
  }
</style>
</head>
<body>
<div id="game" role="application" aria-label="Card Climber">
  <div class="topbar">
    <div class="top-left">
      <div class="titlebar">Card Climber</div>
      <div class="badge"><small>Floor</small> <span id="floorLabel">1 / 5</span></div>
      <div class="badge"><small>Draw</small><span id="drawCount">0</span></div>
      <div class="badge"><small>Discard</small><span id="discardCount">0</span></div>
      <div class="badge"><small>Exhaust</small><span id="exhaustCount">0</span></div>
    </div>
    <div class="top-right">
      <button class="btn ghost" id="helpBtn">Help</button>
      <button class="btn secondary" id="restartBtn" title="R">Restart</button>
    </div>
  </div>

  <div class="arena">
    <div class="board">
      <div class="enemy-area">
        <div class="enemy" id="enemyCard" aria-live="polite">
          <div class="enemy-art" id="enemyArt">
            <div class="blob" id="enemyBlob"></div>
          </div>
          <div class="enemy-info">
            <div class="row">
              <div class="name" id="enemyName">Enemy</div>
              <div class="intent" id="enemyIntent">...</div>
            </div>
            <div class="bars">
              <div class="hpbar" aria-label="Enemy Health"><div class="fill" id="enemyHPFill"></div></div>
              <div class="row">
                <div class="stat"><span class="ico hp">❤</span><span id="enemyHP">0/0</span></div>
                <div class="stat"><span class="ico bl">🛡</span><span id="enemyBlock">0</span></div>
                <div class="stat"><span class="ico vu">⚠</span><span id="enemyVuln">0</span></div>
              </div>
            </div>
            <div class="row small" id="enemyNote"></div>
          </div>
        </div>
      </div>
      <div class="hand-area">
        <div class="controls">
          <div class="playerbar">
            <div class="stack">
              <div class="stat"><span class="ico hp">❤</span><span id="playerHP">60/60</span></div>
              <div class="stat"><span class="ico bl">🛡</span><span id="playerBlock">0</span></div>
              <div class="stat"><span class="ico vu">⚠</span><span id="playerVuln">0</span></div>
            </div>
            <div class="stack">
              <div class="stat"><span class="ico en">⚡</span><span id="energy">3 / 3</span></div>
            </div>
          </div>
          <div class="spacer"></div>
          <div class="piles">
            <div class="pile">Hand <b id="handCount">0</b></div>
            <div class="pile">Draw <b id="drawCount2">0</b></div>
            <div class="pile">Discard <b id="discardCount2">0</b></div>
          </div>
          <button class="btn endturn" id="endTurnBtn" title="Space">End Turn</button>
        </div>
        <div class="hand" id="hand"></div>
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="helpOverlay" aria-modal="true" role="dialog">
  <div class="modal">
    <h2>How to Play</h2>
    <p>Beat 5 enemies by playing cards from your hand. After each victory, choose a new card to add to your deck.</p>
    <div class="sep"></div>
    <ul>
      <li>Each turn you draw 5 cards and gain 3 energy.</li>
      <li>Tap/click a card to play it. Cards cost energy. Attack to damage, Skill to block or utility.</li>
      <li>Block reduces incoming damage this enemy turn. Vulnerable makes a target take 50% more damage.</li>
      <li>End your turn to let the enemy act. Their intent is shown beside their name.</li>
      <li>After a fight, pick 1 of 3 cards (or skip) to add to your deck.</li>
    </ul>
    <div class="sep"></div>
    <p><b>Keyboard</b></p>
    <ul>
      <li>Play cards: 1-9 (0 for the 10th card)</li>
      <li>End Turn: Space</li>
      <li>Restart: R</li>
      <li>Toggle Help: H</li>
    </ul>
    <div class="footer-actions">
      <button class="btn" id="closeHelp">Got it</button>
    </div>
  </div>
</div>

<div class="overlay" id="rewardOverlay" aria-modal="true" role="dialog">
  <div class="modal">
    <h2>Victory!</h2>
    <p>Choose a card to add to your deck. You heal a little between fights.</p>
    <div class="choices" id="rewardChoices"></div>
    <div class="footer-actions">
      <button class="btn ghost" id="skipReward">Skip</button>
    </div>
  </div>
</div>

<div class="overlay" id="gameOverOverlay" aria-modal="true" role="dialog">
  <div class="modal center">
    <h2 id="gameOverTitle">Game Over</h2>
    <p id="gameOverText">You were defeated. Try again!</p>
    <div class="footer-actions" style="justify-content:center;">
      <button class="btn" id="playAgain">Play Again</button>
    </div>
  </div>
</div>

<script>
(function(){
  const el = sel => document.querySelector(sel);
  const els = sel => Array.from(document.querySelectorAll(sel));

  // Game State
  const state = {
    floor: 1,
    maxFloors: 5,
    player: { maxHP: 60, hp: 60, block: 0, vuln: 0, energy: 3, maxEnergy: 3 },
    enemy: null,
    enemyIntent: null,
    canAct: true,
    deck: [],
    drawPile: [],
    discardPile: [],
    exhaustPile: [],
    hand: [],
    turnStarted: false,
    inCombat: false,
    rewards: []
  };

  // Cards Catalog
  const CARDS = {
    strike: {
      id:'strike', name:'Strike', type:'Attack', cost:1, color:'attack',
      desc:()=>'Deal 6 damage.',
      play:(ctx)=> dealDamage(ctx.enemy, calcDamage(6, ctx.enemy))
    },
    defend: {
      id:'defend', name:'Defend', type:'Skill', cost:1, color:'skill',
      desc:()=>'Gain 5 Block.',
      play:(ctx)=> gainBlock(ctx.player, 5)
    },
    bash: {
      id:'bash', name:'Bash', type:'Attack', cost:2, color:'attack',
      desc:()=>'Deal 7 damage and apply 2 Vulnerable.',
      play:(ctx)=>{ dealDamage(ctx.enemy, calcDamage(7, ctx.enemy)); applyVuln(ctx.enemy, 2); }
    },
    heavy: {
      id:'heavy', name:'Heavy Strike', type:'Attack', cost:2, color:'attack',
      desc:()=>'Deal 10 damage.',
      play:(ctx)=> dealDamage(ctx.enemy, calcDamage(10, ctx.enemy))
    },
    quick: {
      id:'quick', name:'Quick Jab', type:'Attack', cost:0, color:'attack',
      desc:()=>'Deal 4 damage.',
      play:(ctx)=> dealDamage(ctx.enemy, calcDamage(4, ctx.enemy))
    },
    pommel: {
      id:'pommel', name:'Pommel', type:'Attack', cost:1, color:'attack',
      desc:()=>'Deal 6 damage. Draw 1.',
      play:(ctx)=>{ dealDamage(ctx.enemy, calcDamage(6, ctx.enemy)); draw(1); }
    },
    adrenaline: {
      id:'adrenaline', name:'Adrenaline', type:'Skill', cost:0, color:'skill', exhaust:true,
      desc:()=>'Gain 2 Energy. Draw 2. Exhaust.',
      play:(ctx)=>{ gainEnergy(2); draw(2); toast('+2 Energy'); }
    },
    heal: {
      id:'heal', name:'Bandage', type:'Skill', cost:1, color:'skill',
      desc:()=>'Heal 4 HP.',
      play:(ctx)=> heal(ctx.player, 4)
    },
    double: {
      id:'double', name:'Double Strike', type:'Attack', cost:1, color:'attack',
      desc:()=>'Deal 4 damage twice.',
      play:(ctx)=>{ dealDamage(ctx.enemy, calcDamage(4, ctx.enemy)); setTimeout(()=>dealDamage(ctx.enemy, calcDamage(4, ctx.enemy)), 120); }
    },
    fortify: {
      id:'fortify', name:'Fortify', type:'Skill', cost:2, color:'skill',
      desc:()=>'Gain 9 Block.',
      play:(ctx)=> gainBlock(ctx.player, 9)
    },
    guardSlam: {
      id:'guardSlam', name:'Shield Bash', type:'Attack', cost:1, color:'attack',
      desc:()=>'Gain 4 Block and deal 4 damage.',
      play:(ctx)=>{ gainBlock(ctx.player,4); dealDamage(ctx.enemy, calcDamage(4, ctx.enemy)); }
    },
    slam: {
      id:'slam', name:'Slam', type:'Attack', cost:1, color:'attack',
      desc:()=>'Deal 6 damage and apply 1 Vulnerable.',
      play:(ctx)=>{ dealDamage(ctx.enemy, calcDamage(6, ctx.enemy)); applyVuln(ctx.enemy,1); }
    }
  };

  const BASE_DECK = ['strike','strike','strike','strike','strike','defend','defend','defend','defend','bash'];
  const REWARD_POOL = Object.keys(CARDS).filter(id => !['strike','defend','bash'].includes(id));

  // Enemies
  function makeEnemy(type){
    const e = { name:'', maxHP:40, hp:40, block:0, vuln:0, strength:0, note:'', type };
    if(type==='Slime'){
      e.name='Blue Slime'; e.maxHP=35+state.floor*2; e.hp=e.maxHP;
      e.ai = (turn)=>{ // random among attack 7, block 6, debuff vuln 1
        const roll = Math.random();
        if(roll<0.5){ return {kind:'attack', dmg:7} }
        else if(roll<0.75){ return {kind:'block', blk:6} }
        else { return {kind:'debuff', debuff:'vuln', amount:1} }
      }
      e.note='Gloopy and unpredictable.';
    } else if(type==='Cultist'){
      e.name='Cultist'; e.maxHP=30+state.floor*3; e.hp=e.maxHP; e.strength=0;
      e.ai = (turn)=>{ if(turn===1) return {kind:'buff', buff:'ritual', text:'+2 Strength'};
        return {kind:'attack', dmg:6 + e.strength};
      }
      e.afterAct = (intent)=>{ if(intent.kind==='buff'){ e.strength+=2; } }
      e.note='Grows stronger every chant.';
    } else if(type==='Goblin'){
      e.name='Goblin Guard'; e.maxHP=38+state.floor*4; e.hp=e.maxHP;
      e.ai = (turn)=> turn%2===1 ? {kind:'attack', dmg:10} : {kind:'block', blk:10};
      e.note='Alternates between guarding and striking.';
    } else if(type==='Thief'){
      e.name='Sneaky Thief'; e.maxHP=28+state.floor*3; e.hp=e.maxHP;
      e.ai = (turn)=>{ const r = Math.random(); if(r<0.4){return {kind:'multi', hits:3, dmg:3}} else return {kind:'attack', dmg:8} }
      e.note='Sometimes attacks in flurries.';
    } else {
      e.name='Orc Brute'; e.maxHP=50+state.floor*6; e.hp=e.maxHP;
      e.ai = (turn)=>{ const r = Math.random(); if(r<0.5){return {kind:'attack', dmg:14}} else return {kind:'block', blk:12} }
      e.note='Hits hard; hunkers down otherwise.';
    }
    return e;
  }

  const ENEMY_ORDER = ['Slime','Cultist','Goblin','Thief','Orc'];

  // Helpers
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }
  function cloneCard(id){
    const c = CARDS[id];
    return { uid: Math.random().toString(36).slice(2), ...c }; // shallow copy
  }
  function buildPilesFromDeck(){
    state.drawPile = shuffle(state.deck.map(id=>cloneCard(id)));
    state.discardPile = [];
    state.exhaustPile = [];
    state.hand = [];
  }
  function draw(n){
    for(let i=0;i<n;i++){
      if(state.hand.length>=10) return;
      if(state.drawPile.length===0){
        if(state.discardPile.length===0) break;
        state.drawPile = shuffle(state.discardPile);
        state.discardPile = [];
      }
      const card = state.drawPile.pop();
      state.hand.push(card);
    }
    render();
  }
  function gainEnergy(x){
    state.player.energy = Math.min(state.player.maxEnergy, state.player.energy + x);
    renderEnergy();
  }
  function spendEnergy(x){
    if(state.player.energy>=x){ state.player.energy -= x; renderEnergy(); return true; }
    return false;
  }
  function heal(target, amt){
    const before = target.hp;
    target.hp = Math.min(target.maxHP, target.hp + amt);
    if(target===state.player) floatText(el('#playerHP').closest('.stack'), `+${target.hp-before}`, '#66ffa1', -20);
    render();
  }
  function applyVuln(target, stacks){
    target.vuln = Math.max(0, target.vuln + stacks);
    if(target===state.enemy) floatText(el('#enemyCard'), 'Vulnerable', '#ffb86b');
    else floatText(el('#playerHP').closest('.stack'), 'Vulnerable', '#ffb86b');
    render();
  }
  function gainBlock(target, amt){
    target.block += amt;
    if(target===state.player) floatText(el('#playerHP').closest('.stack'), `+${amt}🛡`, '#9ecbff');
    else floatText(el('#enemyCard'), `+${amt}🛡`, '#9ecbff');
    render();
  }
  function calcDamage(base, target){
    const mult = target.vuln>0 ? 1.5 : 1;
    return Math.floor(base * mult);
  }
  function dealDamage(target, raw){
    let dmg = raw;
    if(target.block>0){
      const fromBlock = Math.min(target.block, dmg);
      target.block -= fromBlock; dmg -= fromBlock;
    }
    if(dmg>0){
      target.hp -= dmg;
      if(target===state.enemy){
        floatText(el('#enemyCard'), `-${dmg}`, '#ff6b6b');
        shake(el('#enemyCard'));
      } else {
        floatText(el('#playerHP').closest('.stack'), `-${dmg}`, '#ff6b6b');
        shake(el('.arena'));
      }
    } else {
      if(target===state.enemy) floatText(el('#enemyCard'), 'Blocked', '#9ecbff');
      else floatText(el('#playerHP').closest('.stack'), 'Blocked', '#9ecbff');
    }
    render();
    checkDeaths();
  }
  function floatText(container, text, color='#fff', xOffset=0){
    const f = document.createElement('div');
    f.className='floating';
    f.textContent=text;
    f.style.left = (container.getBoundingClientRect().width/2 + xOffset)+'px';
    f.style.top = '0px';
    f.style.color = color;
    container.appendChild(f);
    setTimeout(()=>f.remove(), 820);
  }
  function shake(node){
    node.animate([{transform:'translateX(0)'},{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}], {duration:140});
  }
  function toast(msg){
    floatText(el('.arena'), msg, '#96ffa6', 0);
  }

  // Combat Flow
  function startGame(){
    state.floor = 1;
    state.player = { maxHP: 60, hp: 60, block: 0, vuln: 0, energy: 3, maxEnergy: 3 };
    state.deck = [...BASE_DECK];
    startCombat();
  }
  function startCombat(){
    state.inCombat = true;
    state.turnStarted = false;
    buildPilesFromDeck();
    const enemyType = ENEMY_ORDER[state.floor-1] || ENEMY_ORDER[ENEMY_ORDER.length-1];
    state.enemy = makeEnemy(enemyType);
    state.enemyIntent = computeEnemyIntent(1);
    state.turnCount = 1;
    // First hand
    state.player.block = 0;
    state.player.energy = state.player.maxEnergy;
    draw(5);
    render();
    showIntent();
  }
  function computeEnemyIntent(turn){
    if(!state.enemy || !state.enemy.ai) return {kind:'attack', dmg:6};
    return state.enemy.ai(turn);
  }
  function startPlayerTurn(){
    state.turnCount++;
    state.player.block = 0;
    state.player.energy = state.player.maxEnergy;
    draw(5);
    state.enemyIntent = computeEnemyIntent(state.turnCount);
    state.canAct = true;
    render();
    showIntent();
  }
  function endPlayerTurn(){
    if(!state.inCombat||!state.canAct) return;
    state.canAct=false;
    // discard hand
    while(state.hand.length){
      const c = state.hand.pop();
      state.discardPile.push(c);
    }
    // reduce player's status at end of own turn
    if(state.player.vuln>0) state.player.vuln--;
    render();
    setTimeout(enemyTurn, 350);
  }
  function enemyTurn(){
    // Enemy block refresh
    state.enemy.block = 0;
    // Execute intent
    const intent = state.enemyIntent || {kind:'attack', dmg:5};
    if(intent.kind==='attack'){
      dealDamage(state.player, intent.dmg);
    } else if(intent.kind==='multi'){
      let hits=intent.hits||2, dmg=intent.dmg||3, i=0;
      const hitLoop=()=>{ if(i>=hits){ afterEnemyIntent(intent); return; }
        dealDamage(state.player, dmg); i++; setTimeout(hitLoop, 150);
      };
      return hitLoop();
    } else if(intent.kind==='block'){
      gainBlock(state.enemy, intent.blk||6);
    } else if(intent.kind==='buff'){
      // will apply in afterAct
      floatText(el('#enemyCard'), 'Buff', '#96ffa6');
    } else if(intent.kind==='debuff'){
      if(intent.debuff==='vuln'){ applyVuln(state.player, intent.amount||1); }
    }
    afterEnemyIntent(intent);
  }
  function afterEnemyIntent(intent){
    // enemy after-effect
    if(state.enemy.afterAct) state.enemy.afterAct(intent);
    // reduce enemy status at end of their turn
    if(state.enemy.vuln>0) state.enemy.vuln--;
    // Check if player dead (maybe from thorns? not used)
    if(checkDeaths()) return;
    setTimeout(()=>startPlayerTurn(), 300);
  }
  function checkDeaths(){
    if(state.player.hp<=0){
      state.player.hp=0;
      render();
      gameOver(false);
      return true;
    }
    if(state.enemy.hp<=0){
      state.enemy.hp=0;
      render();
      victory();
      return true;
    }
    return false;
  }

  // Card Play
  function playCardAt(index){
    if(!state.inCombat || !state.canAct) return;
    const card = state.hand[index];
    if(!card) return;
    if(state.player.energy < card.cost){ shake(el('#energy').closest('.stack')); return; }
    // Spend energy
    spendEnergy(card.cost);
    // Play effect
    try{
      card.play({player: state.player, enemy: state.enemy});
    }catch(e){ console.error(e); }
    // Move to discard or exhaust
    const played = state.hand.splice(index,1)[0];
    if(played.exhaust){
      state.exhaustPile.push(played);
      floatText(el('.arena'), 'Exhaust', '#aaa');
    } else {
      state.discardPile.push(played);
    }
    render();
  }

  // Rendering
  function render(){
    renderEnemy();
    renderPlayer();
    renderPiles();
    renderHand();
  }
  function renderEnemy(){
    const e = state.enemy;
    if(!e) return;
    el('#enemyName').textContent = e.name;
    const hpPct = Math.max(0, e.hp)/e.maxHP*100;
    el('#enemyHPFill').style.width = hpPct+'%';
    el('#enemyHP').textContent = `${Math.max(0,e.hp)}/${e.maxHP}`;
    el('#enemyBlock').textContent = e.block;
    el('#enemyVuln').textContent = e.vuln;
    el('#enemyNote').textContent = e.note || '';
  }
  function renderPlayer(){
    el('#playerHP').textContent = `${Math.max(0,state.player.hp)}/${state.player.maxHP}`;
    el('#playerBlock').textContent = state.player.block;
    el('#playerVuln').textContent = state.player.vuln;
    renderEnergy();
    el('#floorLabel').textContent = `${state.floor} / ${state.maxFloors}`;
  }
  function renderEnergy(){
    el('#energy').textContent = `${state.player.energy} / ${state.player.maxEnergy}`;
    updateCardInteractivity();
  }
  function renderPiles(){
    el('#drawCount').textContent = state.drawPile.length;
    el('#discardCount').textContent = state.discardPile.length;
    el('#exhaustCount').textContent = state.exhaustPile.length;
    el('#drawCount2').textContent = state.drawPile.length;
    el('#discardCount2').textContent = state.discardPile.length;
    el('#handCount').textContent = state.hand.length;
  }
  function showIntent(){
    const it = state.enemyIntent || {};
    let text='...';
    if(it.kind==='attack') text = `Intent: Attack ${it.dmg}`;
    else if(it.kind==='multi') text = `Intent: ${it.hits} x ${it.dmg}`;
    else if(it.kind==='block') text = `Intent: Block ${it.blk}`;
    else if(it.kind==='buff') text = `Intent: Buff`;
    else if(it.kind==='debuff') text = `Intent: Debuff`;
    el('#enemyIntent').textContent = text;
  }
  function renderHand(){
    const h = el('#hand');
    h.innerHTML = '';
    state.hand.forEach((card, i)=>{
      const n = document.createElement('div');
      n.className = 'card';
      n.setAttribute('role','button');
      n.setAttribute('aria-label', `${card.name}, ${card.type}, Cost ${card.cost}`);
      n.innerHTML = `
        <div class="cost">${card.cost}</div>
        <div class="tag ${card.type.toLowerCase()}">${card.type}</div>
        <div class="title">${card.name}</div>
        <div class="type">[${i<9?i+1:0}] ${card.exhaust?'Exhaust':''}</div>
        <div class="desc">${card.desc()}</div>
      `;
      n.addEventListener('click', ()=> playCardAt(i));
      h.appendChild(n);
    });
    updateCardInteractivity();
  }
  function updateCardInteractivity(){
    const cards = els('#hand .card');
    cards.forEach((node, i)=>{
      const card = state.hand[i];
      const affordable = state.player.energy >= (card?.cost ?? 0);
      if(affordable) node.classList.remove('disabled');
      else node.classList.add('disabled');
    });
  }

  // Rewards / Progress
  function victory(){
    state.inCombat = false;
    // Heal 20% of maxHP (rounded up)
    const healAmt = Math.ceil(state.player.maxHP * 0.15);
    heal(state.player, healAmt);
    // Prepare 3 choices
    const choices = shuffle(REWARD_POOL.slice()).slice(0,3).map(id=>cloneCard(id));
    state.rewards = choices;
    openReward();
  }
  function openReward(){
    const overlay = el('#rewardOverlay');
    const zone = el('#rewardChoices');
    zone.innerHTML = '';
    state.rewards.forEach((card, idx)=>{
      const c = renderCardChoice(card);
      c.classList.add('choice-card');
      c.addEventListener('click', ()=>{
        state.deck.push(card.id);
        closeReward(true);
      });
      zone.appendChild(c);
    });
    overlay.classList.add('show');
  }
  function closeReward(picked){
    el('#rewardOverlay').classList.remove('show');
    if(state.floor >= state.maxFloors){
      gameOver(true);
      return;
    }
    if(!picked){
      // skip
    }
    // Next floor
    state.floor++;
    startCombat();
  }
  function gameOver(win){
    const overlay = el('#gameOverOverlay');
    el('#gameOverTitle').textContent = win ? 'You Win!' : 'Defeat';
    el('#gameOverText').textContent = win ? 'You conquered all foes. Great job!' : 'You were defeated. Try again!';
    overlay.classList.add('show');
  }
  function renderCardChoice(card){
    const n = document.createElement('div');
    n.className = 'card';
    n.innerHTML = `
      <div class="cost">${card.cost}</div>
      <div class="tag ${card.type.toLowerCase()}">${card.type}</div>
      <div class="title">${card.name}</div>
      <div class="type">${card.exhaust?'Exhaust':''}</div>
      <div class="desc">${card.desc()}</div>
    `;
    return n;
  }

  // Events
  el('#endTurnBtn').addEventListener('click', endPlayerTurn);
  el('#restartBtn').addEventListener('click', ()=>{ closeAllOverlays(); startGame(); });
  el('#helpBtn').addEventListener('click', ()=> el('#helpOverlay').classList.add('show'));
  el('#closeHelp').addEventListener('click', ()=> el('#helpOverlay').classList.remove('show'));
  el('#skipReward').addEventListener('click', ()=> closeReward(false));
  el('#playAgain').addEventListener('click', ()=>{ el('#gameOverOverlay').classList.remove('show'); startGame(); });

  function closeAllOverlays(){
    ['#helpOverlay','#rewardOverlay','#gameOverOverlay'].forEach(s=>el(s).classList.remove('show'));
  }

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ e.preventDefault(); endPlayerTurn(); }
    if(e.key==='r' || e.key==='R'){ startGame(); }
    if(e.key==='h' || e.key==='H'){ const o = el('#helpOverlay'); o.classList.toggle('show'); }
    // 1-9 and 0
    const num = parseInt(e.key, 10);
    if(!isNaN(num)){
      if(num===0) playCardAt(9);
      else playCardAt(num-1);
    }
  }, {passive:false});

  // Initialize
  startGame();

})();
</script>
</body>
</html>