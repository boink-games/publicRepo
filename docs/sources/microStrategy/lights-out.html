<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lights Out (3×3) • Color Edition</title>
  <style>
    :root{
      --bg1:#0b1022;
      --bg2:#111936;
      --panel:#0f172a;
      --panel-2:#111b33;
      --text:#e8ecf8;
      --muted:#9fb2d7;
      --accent:#22d3ee;
      --accent-2:#8b5cf6;
      --gap: clamp(8px, 1.8vw, 16px);
      --cell: clamp(64px, 22vw, 120px);
      --radius: 14px;
      --shadow: 0 10px 25px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #1a2466 0%, transparent 60%),
                  radial-gradient(1000px 700px at -10% 120%, #1b2a64 0%, transparent 60%),
                  linear-gradient(160deg,var(--bg1),var(--bg2));
      background-attachment: fixed;
    }
    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding: clamp(12px, 2.4vw, 28px);
      gap: clamp(12px, 2.2vw, 20px);
    }
    .card{
      width:min(92vw, 520px);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)) padding-box,
                  linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.02)) border-box;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: clamp(12px, 2.2vw, 20px);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: clamp(12px, 2vw, 16px);
      backdrop-filter: blur(6px) saturate(120%);
    }
    .top{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-weight:800;
      letter-spacing:.3px;
      display:flex;
      align-items:center;
      gap:.5em;
      font-size: clamp(18px, 2.4vw, 22px);
      text-shadow: 0 2px 10px rgba(34,211,238,.25);
    }
    .title .badge{
      font-size:.72em;
      color:#cbd5e1;
      padding:.28em .6em;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.12);
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-end;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      color:var(--text);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
      padding:.6em .9em;
      border-radius:12px;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
      box-shadow: var(--shadow);
      transition: transform .08s ease, filter .2s ease, background .2s ease, border-color .2s ease;
      backdrop-filter: blur(3px);
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0); }
    button.primary{
      background: linear-gradient(140deg, rgba(34,211,238,0.32), rgba(139,92,246,0.30));
      border-color: rgba(34,211,238,0.55);
      text-shadow: 0 1px 10px rgba(34,211,238,.45);
    }
    button[disabled]{
      opacity:.6; filter:saturate(.7) grayscale(.1); cursor:not-allowed;
    }

    .status{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size: clamp(13px, 1.8vw, 14px);
    }
    .counter b{ color: var(--text); }
    .hint{
      opacity:.9;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, var(--cell));
      gap: var(--gap);
      padding: clamp(10px, 2.2vw, 18px);
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      touch-action: manipulation;
      user-select:none;
    }
    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 16px;
      position:relative;
      display:grid;
      place-items:center;
      isolation:isolate;
      cursor:pointer;
      transition: transform .08s ease;
      outline:none;
      --h: 200;
      --sat: 95%;
      --on1: hsl(var(--h) var(--sat) 62%);
      --on2: hsl(calc(var(--h) + 30) var(--sat) 52%);
      --off1: #142039;
      --off2: #0e162b;
      --ring: hsla(var(--h), 95%, 60%, .72);
      background: linear-gradient(160deg, var(--off1), var(--off2));
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.06),
        inset 0 -6px 16px rgba(0,0,0,.35),
        0 8px 18px rgba(0,0,0,.35);
    }
    .cell:active{ transform: scale(.985); }
    .cell.off::after,
    .cell.on::after{
      content:"";
      position:absolute; inset:-1px; border-radius:18px; pointer-events:none;
      transition: opacity .25s ease, transform .25s ease, box-shadow .25s ease;
    }
    .cell.on{
      background: radial-gradient(circle at 30% 30%, var(--on1), transparent 55%),
                  radial-gradient(circle at 70% 70%, var(--on2), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,0));
      box-shadow:
        0 0 36px 6px color-mix(in oklab, var(--on1) 30%, transparent),
        0 8px 20px rgba(0,0,0,.45),
        inset 0 0 0 1px rgba(255,255,255,.10);
      animation: glow 2s ease-in-out infinite;
    }
    .cell.on::after{
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.18), inset 0 0 24px rgba(255,255,255,.20);
      background: radial-gradient(80px 80px at 50% 50%, rgba(255,255,255,.18), transparent 62%);
      opacity:.9;
    }
    .cell.off::after{
      opacity:.05;
      background: radial-gradient(80px 60px at 30% 30%, rgba(255,255,255,.06), transparent 60%);
    }
    .cell.hintRing::before{
      content:"";
      position:absolute; inset:-6px; border-radius:22px; pointer-events:none;
      border: 2px solid var(--ring);
      filter: blur(.6px);
      animation: ring .6s ease forwards;
    }

    @keyframes glow{
      0%,100%{ filter: saturate(1.05) brightness(1); }
      50%{ filter: saturate(1.25) brightness(1.08); }
    }
    @keyframes ring{
      0%{ opacity:0; transform: scale(.9); }
      100%{ opacity:1; transform: scale(1); }
    }
    @media (prefers-reduced-motion: reduce){
      .cell, .cell::after, .cell.on{ animation: none !important; transition: none !important; }
      button{ transition: none !important; }
    }

    .footer{
      color:var(--muted);
      font-size: clamp(12px, 1.8vw, 13px);
      text-align:center;
    }

    .toast{
      position:fixed;
      left:50%; top:12px; transform:translateX(-50%);
      background: linear-gradient(180deg, rgba(34,211,238,0.28), rgba(139,92,246,0.22));
      border:1px solid rgba(255,255,255,.22);
      color:white;
      padding:.7em 1em;
      border-radius:14px;
      box-shadow: var(--shadow);
      font-weight:700;
      letter-spacing:.2px;
      opacity:0; pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(4px); }
    .sr{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card" role="application" aria-label="Lights Out 3 by 3">
      <div class="top">
        <div class="title">
          Lights Out
          <span class="badge">3×3</span>
        </div>
        <div class="controls">
          <button id="newBtn" class="primary" type="button" aria-label="Start a new puzzle">New Game</button>
          <button id="resetBtn" type="button" aria-label="Reset to puzzle start">Reset</button>
          <button id="solveBtn" type="button" aria-label="Auto-solve the current puzzle">Auto-Solve</button>
        </div>
      </div>

      <div class="status">
        <div class="counter">Moves: <b id="moves">0</b></div>
        <div class="goal">Goal: switch off all lights</div>
      </div>

      <div class="grid" id="grid" aria-live="polite"></div>

      <div class="footer">
        Tip: Tap or click a tile to toggle it and its neighbors. Try to turn them all off!
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true">You win! Great job ✨</div>

  <script>
  (function(){
    const N = 3;
    const SIZE = N * N;

    const grid = document.getElementById('grid');
    const movesEl = document.getElementById('moves');
    const newBtn = document.getElementById('newBtn');
    const resetBtn = document.getElementById('resetBtn');
    const solveBtn = document.getElementById('solveBtn');
    const toast = document.getElementById('toast');

    let state = new Array(SIZE).fill(0);
    let startState = state.slice();
    let moves = 0;
    let isAnimating = false;

    // Precompute neighbors for each index
    const neighbors = Array.from({length: SIZE}, (_, i) => {
      const r = Math.floor(i / N), c = i % N;
      const list = [i];
      if(r > 0) list.push(i - N);
      if(r < N - 1) list.push(i + N);
      if(c > 0) list.push(i - 1);
      if(c < N - 1) list.push(i + 1);
      return list;
    });

    // Build A matrix where A[row][col] = 1 if pressing col toggles row
    const A = Array.from({length: SIZE}, (_, row) => {
      const arr = new Array(SIZE).fill(0);
      for (let col = 0; col < SIZE; col++) {
        // press col toggles col and its neighbors
        if (neighbors[col].includes(row)) arr[col] = 1; // row toggled by pressing col
      }
      return arr;
    });

    // Compute inverse of A over GF(2), if invertible
    const Ainv = invertBinaryMatrix(A);

    // Create cells once for performance
    const cells = [];
    function initGrid(){
      grid.innerHTML = '';
      for(let i=0;i<SIZE;i++){
        const d = document.createElement('button');
        d.type = 'button';
        d.className = 'cell off';
        d.setAttribute('role','button');
        d.setAttribute('aria-pressed','false');
        d.setAttribute('aria-label', 'Tile '+(i+1));
        d.tabIndex = 0;
        // Per-cell hue for colorful variation
        const hue = (i * 360 / SIZE + 10) % 360;
        d.style.setProperty('--h', hue.toFixed(0));
        // Pointer input
        d.addEventListener('pointerdown', (e)=>{
          if(isAnimating) return;
          e.preventDefault();
          flipAt(i, true);
        }, {passive:false});
        // Keyboard
        d.addEventListener('keydown', (e)=>{
          if(isAnimating) return;
          if(e.key === 'Enter' || e.key === ' '){
            e.preventDefault();
            flipAt(i, true);
          }
        });
        cells.push(d);
        grid.appendChild(d);
      }
      renderAll();
    }

    function renderAll(){
      for(let i=0;i<SIZE;i++){
        updateCell(i);
      }
      updateMoves();
    }

    function updateCell(i){
      const on = !!state[i];
      const el = cells[i];
      el.classList.toggle('on', on);
      el.classList.toggle('off', !on);
      el.setAttribute('aria-pressed', on ? 'true' : 'false');
    }

    function updateMoves(){
      movesEl.textContent = moves;
    }

    function toggleIndex(i){
      state[i] ^= 1;
      updateCell(i);
    }

    function flipAt(i, countMove){
      neighbors[i].forEach(toggleIndex);
      if (countMove){
        moves++;
        updateMoves();
      }
      if (!isAnimating) checkWin();
    }

    function setButtonsDisabled(disabled){
      [newBtn, resetBtn, solveBtn].forEach(b=> b.disabled = disabled);
    }

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1800);
    }

    function checkWin(){
      if(state.every(v=>v===0)){
        showToast('You win! Great job ✨');
      }
    }

    function resetToStart(){
      if(isAnimating) return;
      state = startState.slice();
      moves = 0;
      renderAll();
    }

    function randomMoves(k){
      for(let i=0;i<k;i++){
        const idx = Math.floor(Math.random()*SIZE);
        neighbors[idx].forEach(j=> state[j] ^= 1);
      }
    }

    function newGame(){
      if(isAnimating) return;
      // Start from all-off, apply random valid moves to guarantee solvable
      state = new Array(SIZE).fill(0);
      // 6–12 random moves
      const k = 6 + Math.floor(Math.random()*7);
      randomMoves(k);
      startState = state.slice();
      moves = 0;
      renderAll();
    }

    async function autoSolve(){
      if(isAnimating) return;
      isAnimating = true;
      setButtonsDisabled(true);
      grid.style.pointerEvents = 'none';

      // Solve A x = b (mod 2)
      const b = state.slice();
      let x;
      if (Ainv){
        x = multiplyBinary(Ainv, b);
      } else {
        x = solveBinaryLinearSystem(A, b);
      }

      const movesToPlay = [];
      for(let i=0;i<SIZE;i++){
        if(x[i] & 1) movesToPlay.push(i);
      }

      // Animate sequence
      for(const idx of movesToPlay){
        if(!isAnimating) break;
        // ring highlight then press
        cells[idx].classList.add('hintRing');
        await wait(140);
        cells[idx].classList.remove('hintRing');
        flipAt(idx, false); // don't count automated steps as player moves
        await wait(150);
      }

      // After applying solution, verify all off
      if(state.every(v=>v===0)){
        showToast('Solved automatically ✨');
      }
      isAnimating = false;
      setButtonsDisabled(false);
      grid.style.pointerEvents = 'auto';
    }

    function wait(ms){ return new Promise(res=>setTimeout(res, ms)); }

    // Binary matrix helpers (GF(2))
    function invertBinaryMatrix(M){
      const n = M.length;
      // clone M and append identity -> [M | I]
      const A = Array.from({length:n}, (_,r)=>{
        const row = new Array(n*2).fill(0);
        for(let c=0;c<n;c++) row[c] = M[r][c] & 1;
        row[n+r] = 1;
        return row;
      });

      let row = 0;
      for(let col=0; col<n && row<n; col++){
        // find pivot
        let pivot = row;
        while(pivot<n && A[pivot][col]===0) pivot++;
        if(pivot===n) continue; // no pivot in this column
        if(pivot!==row){
          const tmp = A[row]; A[row] = A[pivot]; A[pivot] = tmp;
        }
        // eliminate other rows
        for(let r=0;r<n;r++){
          if(r!==row && A[r][col]===1){
            for(let c=col;c<2*n;c++){
              A[r][c] ^= A[row][c];
            }
          }
        }
        row++;
      }

      // Check left side is identity
      for(let r=0;r<n;r++){
        for(let c=0;c<n;c++){
          const expected = (r===c)?1:0;
          if(A[r][c] !== expected) return null; // not invertible
        }
      }
      // Extract inverse
      const inv = Array.from({length:n}, (_,r)=>{
        const out = new Array(n).fill(0);
        for(let c=0;c<n;c++) out[c] = A[r][n+c] & 1;
        return out;
      });
      return inv;
    }

    function multiplyBinary(M, v){
      const n = M.length;
      const out = new Array(n).fill(0);
      for(let r=0;r<n;r++){
        let sum = 0;
        for(let c=0;c<n;c++){
          sum ^= (M[r][c] & v[c]);
        }
        out[r] = sum & 1;
      }
      return out;
    }

    function solveBinaryLinearSystem(M, b){
      const n = M.length;
      // Augmented matrix [M | b]
      const A = Array.from({length:n}, (_,r)=>{
        const row = M[r].slice();
        row.push(b[r] & 1);
        return row;
      });
      let row = 0;
      const pivots = new Array(n).fill(-1);

      for(let col=0; col<n && row<n; col++){
        let pivot = row;
        while(pivot<n && A[pivot][col]===0) pivot++;
        if(pivot===n) continue;
        if(pivot!==row){ const tmp=A[row]; A[row]=A[pivot]; A[pivot]=tmp; }
        pivots[row] = col;
        // eliminate below
        for(let r=0;r<n;r++){
          if(r!==row && A[r][col]===1){
            for(let c=col;c<=n;c++){
              A[r][c] ^= A[row][c];
            }
          }
        }
        row++;
      }
      // Back substitution implicitly done by elimination above
      const x = new Array(n).fill(0);
      for(let r=0;r<n;r++){
        const c = pivots[r];
        if(c !== -1){
          x[c] = A[r][n] & 1;
        }
      }
      return x;
    }

    // Wire up controls
    newBtn.addEventListener('click', newGame);
    resetBtn.addEventListener('click', resetToStart);
    solveBtn.addEventListener('click', autoSolve);

    // Start the game
    initGrid();
    newGame();

    // Accessibility: keyboard navigation hint on focus
    cells.forEach(el=>{
      el.addEventListener('focus', ()=> el.classList.add('hint'));
      el.addEventListener('blur', ()=> el.classList.remove('hint'));
    });

  })();
  </script>
</body>
</html>