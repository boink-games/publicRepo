<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Flappy Dot</title>
  <style>
    :root { 
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --fg: #ffffff;
      --glass-bg: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
      --glass-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      --dot-color: linear-gradient(45deg, #38bdf8, #0ea5e9);
      --dot-glow: rgba(56, 189, 248, 0.8);
      --pipe-color: linear-gradient(45deg, #1e293b, #334155);
      --pipe-glow: rgba(30, 41, 59, 0.6);
      --ground-color: linear-gradient(45deg, #166534, #22c55e);
      --sky-color: linear-gradient(180deg, #0ea5e9, #38bdf8);
    }
    
    * { 
      box-sizing: border-box; 
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }
    
    html, body { 
      height: 100vh;
      height: 100dvh;
      margin: 0; 
      background: var(--bg);
      color: var(--fg); 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    canvas { 
      width: 100%; 
      height: 100vh;
      height: 100dvh;
      display: block; 
      background: var(--sky-color);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.2);
    }
    
    .hud { 
      position: fixed; 
      top: env(safe-area-inset-top, 0px); 
      left: env(safe-area-inset-left, 0px); 
      right: env(safe-area-inset-right, 0px); 
      display: flex; 
      justify-content: space-between; 
      padding: clamp(8px, 2vw, 16px) clamp(12px, 3vw, 20px);
      background: linear-gradient(180deg, rgba(0,0,0,0.6), transparent);
      z-index: 10;
    }
    
    .hud-item {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      padding: clamp(8px, 2vw, 12px) clamp(12px, 3vw, 16px);
      font-weight: 800;
      font-size: clamp(14px, 4vw, 18px);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      box-shadow: var(--glass-shadow);
    }
    
    .score {
      color: #38bdf8;
      text-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
    }
    
    .controls {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 0px);
      left: env(safe-area-inset-left, 0px);
      right: env(safe-area-inset-right, 0px);
      padding: clamp(12px, 3vw, 20px);
      background: linear-gradient(0deg, rgba(0,0,0,0.6), transparent);
      display: flex;
      justify-content: center;
      gap: clamp(12px, 3vw, 20px);
      z-index: 10;
    }
    
    .control-btn { 
      background: var(--glass-bg);
      color: var(--fg);
      border: 1px solid var(--glass-border);
      padding: clamp(12px, 3vw, 16px) clamp(16px, 4vw, 24px);
      border-radius: 16px;
      font-weight: 700;
      font-size: clamp(14px, 3vw, 16px);
      cursor: pointer;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      transition: all 0.2s ease;
      user-select: none;
      box-shadow: var(--glass-shadow);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .control-btn:active, .control-btn.pressed {
      background: var(--glass-border);
      transform: scale(0.95);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .control-btn:hover {
      background: var(--glass-border);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }
    
    .game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    .game-over-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: clamp(24px, 6vw, 40px);
      text-align: center;
      box-shadow: var(--glass-shadow);
      max-width: 90vw;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .game-over-title {
      font-size: clamp(24px, 6vw, 32px);
      font-weight: 800;
      margin-bottom: 16px;
      color: #ef4444;
      text-shadow: 0 0 15px rgba(239, 68, 68, 0.6);
      animation: pulse 2s ease-in-out infinite alternate;
    }
    
    .final-score {
      font-size: clamp(18px, 4vw, 24px);
      margin-bottom: 24px;
      color: #38bdf8;
      text-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
    }
    
    .instructions {
      font-size: clamp(14px, 3vw, 16px);
      opacity: 0.9;
      margin-bottom: 24px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes pulse {
      from { opacity: 0.8; }
      to { opacity: 1; }
    }
    
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      z-index: 5;
    }
    
    @keyframes particleFloat {
      0% {
        transform: translateY(0) rotate(0deg) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(-150px) rotate(360deg) scale(0);
        opacity: 0;
      }
    }
    
    .start-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      padding: 20px 30px;
      text-align: center;
      font-size: clamp(16px, 4vw, 20px);
      font-weight: 700;
      color: var(--fg);
      box-shadow: var(--glass-shadow);
      z-index: 15;
      animation: bounce 2s ease-in-out infinite;
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translate(-50%, -50%) translateY(0);
      }
      40% {
        transform: translate(-50%, -50%) translateY(-10px);
      }
      60% {
        transform: translate(-50%, -50%) translateY(-5px);
      }
    }
    
    /* Responsive adjustments */
    @media (max-width: 480px) {
      .hud {
        padding: 8px 12px;
      }
      
      .controls {
        padding: 12px;
      }
      
      .game-over-panel {
        padding: 20px;
        margin: 16px;
      }
    }
    
    @media (orientation: landscape) and (max-height: 500px) {
      .hud {
        padding: 4px 8px;
      }
      
      .hud-item {
        padding: 4px 8px;
        font-size: 12px;
      }
      
      .controls {
        padding: 8px;
      }
      
      .control-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-item score">Score: <span id="score">0</span></div>
    <div class="hud-item">Best: <span id="bestScore">0</span></div>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  
  <div class="controls">
    <button class="control-btn" id="restartBtn">Restart</button>
    <button class="control-btn" id="pauseBtn">Pause</button>
  </div>
  
  <div class="start-hint" id="startHint">
    Tap anywhere to start!
  </div>
  
  <div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-panel">
      <div class="game-over-title">Game Over!</div>
      <div class="final-score">Score: <span id="finalScore">0</span></div>
      <div class="instructions">Tap anywhere to restart</div>
      <button class="control-btn" onclick="resetGame()">Play Again</button>
    </div>
  </div>
  
  <script>
    // Enhanced Flappy Dot game with modern features
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('bestScore');
    const finalScoreEl = document.getElementById('finalScore');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startHint = document.getElementById('startHint');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    
    // Responsive canvas sizing
    let W, H;
    function resizeCanvas() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    
    window.addEventListener('resize', resizeCanvas, { passive: true });
    resizeCanvas();
    
    // Game state
    let dot, pipes, score, alive, paused, gameStarted;
    let lastTime, animationId;
    let particles = [];
    let bestScore = localStorage.getItem('flappyDotBest') || 0;
    bestScoreEl.textContent = bestScore;
    
    // Haptic feedback function
    function vibrate(pattern = 50) {
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
    }
    
    // Particle system
    function createParticles(x, y, color, count = 8) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x + (Math.random() - 0.5) * 40,
          y: y + (Math.random() - 0.5) * 40,
          vx: (Math.random() - 0.5) * 12,
          vy: -Math.random() * 8 - 2,
          color: color,
          life: 1,
          decay: 0.015 + Math.random() * 0.02,
          size: 3 + Math.random() * 4,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.2
        });
      }
    }
    
    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.99;
        p.vy += 0.15; // gravity
        p.rotation += p.rotationSpeed;
        p.life -= p.decay;
        return p.life > 0;
      });
    }
    
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        
        // Gradient particle
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size);
        gradient.addColorStop(0, p.color);
        gradient.addColorStop(1, p.color + '00');
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    // Background stars/clouds effect
    let backgroundElements = [];
    function initBackground() {
      backgroundElements = [];
      for (let i = 0; i < 50; i++) {
        backgroundElements.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: Math.random() * 3 + 1,
          speed: Math.random() * 0.5 + 0.2,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
    }
    
    function updateBackground() {
      backgroundElements.forEach(star => {
        star.x -= star.speed;
        if (star.x < -5) {
          star.x = W + 5;
          star.y = Math.random() * H;
        }
      });
    }
    
    function drawBackground() {
      // Sky gradient
      const skyGradient = ctx.createLinearGradient(0, 0, 0, H);
      skyGradient.addColorStop(0, '#0ea5e9');
      skyGradient.addColorStop(0.7, '#38bdf8');
      skyGradient.addColorStop(1, '#7dd3fc');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, W, H);
      
      // Background elements (stars/clouds)
      backgroundElements.forEach(star => {
        ctx.save();
        ctx.globalAlpha = star.opacity;
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = star.size * 2;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    // Ground effect
    function drawGround() {
      const groundHeight = 50;
      const groundGradient = ctx.createLinearGradient(0, H - groundHeight, 0, H);
      groundGradient.addColorStop(0, '#166534');
      groundGradient.addColorStop(1, '#22c55e');
      
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, H - groundHeight, W, groundHeight);
      
      // Ground details
      ctx.fillStyle = '#15803d';
      for (let x = 0; x < W; x += 20) {
        const height = Math.random() * 10 + 5;
        ctx.fillRect(x, H - height, 10, height);
      }
    }
    
    function reset() {
      dot = {
        x: W * 0.3,
        y: H * 0.5,
        vy: 0,
        size: Math.max(12, Math.min(20, Math.round(W / 40))),
        rotation: 0
      };
      pipes = [];
      score = 0;
      alive = true;
      paused = false;
      gameStarted = false;
      particles = [];
      
      spawnPipe();
      updateScore();
      
      startHint.style.display = 'block';
      gameOverOverlay.style.display = 'none';
      
      lastTime = performance.now();
      if (animationId) cancelAnimationFrame(animationId);
      gameLoop(lastTime);
    }
    
    function spawnPipe() {
      const gap = Math.max(140, Math.min(250, H * 0.35));
      const minTop = 80;
      const maxTop = H - gap - 100;
      const top = Math.random() * (maxTop - minTop) + minTop;
      const speed = Math.max(2.5, Math.min(5, W / 250));
      
      pipes.push({
        x: W + 50,
        top,
        bottom: top + gap,
        speed,
        passed: false,
        width: 60
      });
    }
    
    function updateScore() {
      scoreEl.textContent = score;
      if (score > bestScore) {
        bestScore = score;
        bestScoreEl.textContent = bestScore;
        localStorage.setItem('flappyDotBest', bestScore);
      }
    }
    
    function gameLoop(currentTime) {
      if (!alive && !paused) return;
      
      const deltaTime = Math.min(33, currentTime - lastTime) / 16.666;
      lastTime = currentTime;
      
      if (!paused && gameStarted) {
        update(deltaTime);
      }
      
      draw();
      animationId = requestAnimationFrame(gameLoop);
    }
    
    function update(deltaTime) {
      // Update dot physics
      dot.vy += 0.45 * deltaTime; // gravity
      dot.y += dot.vy * 4.5 * deltaTime;
      dot.rotation += dot.vy * 0.02;
      
      // Update pipes
      for (const pipe of pipes) {
        pipe.x -= pipe.speed * 4 * deltaTime;
      }
      
      // Remove off-screen pipes and spawn new ones
      if (pipes.length && pipes[0].x < -pipes[0].width) {
        pipes.shift();
        spawnPipe();
      }
      
      // Update background
      updateBackground();
      
      // Update particles
      updateParticles();
      
      // Collision detection
      checkCollisions();
    }
    
    function checkCollisions() {
      // Ground and ceiling collision
      if (dot.y < 0 || dot.y > H - 50) {
        gameOver();
        return;
      }
      
      // Pipe collision and scoring
      for (const pipe of pipes) {
        const dotLeft = dot.x - dot.size/2;
        const dotRight = dot.x + dot.size/2;
        const dotTop = dot.y - dot.size/2;
        const dotBottom = dot.y + dot.size/2;
        
        // Check if dot is in pipe's x range
        if (dotRight > pipe.x && dotLeft < pipe.x + pipe.width) {
          // Check collision with top or bottom pipe
          if (dotTop < pipe.top || dotBottom > pipe.bottom) {
            gameOver();
            return;
          }
        }
        
        // Score when passing pipe
        if (!pipe.passed && pipe.x + pipe.width < dot.x) {
          pipe.passed = true;
          score++;
          updateScore();
          vibrate([30, 30, 30]);
          createParticles(dot.x, dot.y, '#38bdf8', 12);
        }
      }
    }
    
    function draw() {
      // Background
      drawBackground();
      updateBackground();
      
      // Pipes with enhanced graphics
      for (const pipe of pipes) {
        ctx.save();
        
        // Pipe gradient and glow
        const pipeGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipe.width, 0);
        pipeGradient.addColorStop(0, '#1e293b');
        pipeGradient.addColorStop(0.5, '#334155');
        pipeGradient.addColorStop(1, '#1e293b');
        
        ctx.shadowColor = 'rgba(30, 41, 59, 0.6)';
        ctx.shadowBlur = 12;
        
        // Top pipe
        ctx.fillStyle = pipeGradient;
        ctx.beginPath();
        ctx.roundRect(pipe.x, 0, pipe.width, pipe.top, [0, 0, 8, 8]);
        ctx.fill();
        
        // Bottom pipe
        ctx.beginPath();
        ctx.roundRect(pipe.x, pipe.bottom, pipe.width, H - pipe.bottom, [8, 8, 0, 0]);
        ctx.fill();
        
        // Pipe highlights
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(pipe.x + 5, 0, 3, pipe.top);
        ctx.fillRect(pipe.x + 5, pipe.bottom, 3, H - pipe.bottom);
        
        ctx.restore();
      }
      
      // Ground
      drawGround();
      
      // Dot with enhanced graphics
      ctx.save();
      ctx.translate(dot.x, dot.y);
      ctx.rotate(dot.rotation);
      
      // Dot glow
      ctx.shadowColor = 'rgba(56, 189, 248, 0.8)';
      ctx.shadowBlur = 25;
      
      // Dot gradient
      const dotGradient = ctx.createRadialGradient(-dot.size/3, -dot.size/3, 0, 0, 0, dot.size);
      dotGradient.addColorStop(0, '#ffffff');
      dotGradient.addColorStop(0.2, '#7dd3fc');
      dotGradient.addColorStop(0.6, '#38bdf8');
      dotGradient.addColorStop(1, '#0ea5e9');
      
      ctx.fillStyle = dotGradient;
      ctx.beginPath();
      ctx.arc(0, 0, dot.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Dot highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(-dot.size/4, -dot.size/4, dot.size/3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      
      // Particles
      drawParticles();
      
      // Paused overlay
      if (paused) {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 32px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', W/2, H/2);
        ctx.restore();
      }
    }
    
    function flap() {
      if (!alive) {
        resetGame();
        return;
      }
      
      if (!gameStarted) {
        gameStarted = true;
        startHint.style.display = 'none';
      }
      
      if (paused) {
        togglePause();
        return;
      }
      
      dot.vy = -4.2;
      vibrate(40);
      createParticles(dot.x - dot.size, dot.y, '#38bdf8', 6);
    }
    
    function gameOver() {
      alive = false;
      finalScoreEl.textContent = score;
      gameOverOverlay.style.display = 'flex';
      vibrate([200, 100, 200, 100, 200]);
      
      // Explosion particles
      createParticles(dot.x, dot.y, '#ef4444', 20);
      createParticles(dot.x, dot.y, '#f97316', 15);
      createParticles(dot.x, dot.y, '#fbbf24', 10);
    }
    
    function resetGame() {
      if (animationId) cancelAnimationFrame(animationId);
      reset();
    }
    
    function togglePause() {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (paused) {
        vibrate(60);
      }
    }
    
    // Event listeners
    canvas.addEventListener('pointerdown', flap);
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      flap();
    }, { passive: false });
    
    restartBtn.addEventListener('click', resetGame);
    pauseBtn.addEventListener('click', togglePause);
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        flap();
      }
      if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        if (alive && gameStarted) togglePause();
      }
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        resetGame();
      }
    });
    
    // Initialize background and start game
    initBackground();
    reset();
  </script>
</body>
</html>
