<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Pong</title>
  <style>
    :root{
      --bar-height: 56px;
      --neon-cyan: #00eaff;
      --neon-pink: #ff2bd6;
      --neon-lime: #9cff00;
      --text: #cfe9ff;
      --bg-1: #0b0f16;
      --bg-2: #070a11;
      --bg-3: #04060c;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 10% 10%, var(--bg-1), var(--bg-2) 60%, var(--bg-3));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    header#topBar {
      position: fixed;
      top: env(safe-area-inset-top, 0);
      left: 0;
      right: 0;
      height: var(--bar-height);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 16px;
      z-index: 2;
      background: linear-gradient(180deg, rgba(10,12,20,0.7), rgba(5,6,12,0.3));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,0.06);
      user-select: none;
      pointer-events: none;
    }
    header#topBar .title {
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      font-size: 14px;
      color: #b1d9ff;
      text-shadow:
        0 0 10px rgba(0,234,255,0.3),
        0 0 20px rgba(0,234,255,0.18);
    }
    canvas#game {
      position: absolute;
      top: calc(var(--bar-height) + env(safe-area-inset-top, 0));
      left: 0;
      width: 100vw;
      height: calc(100vh - var(--bar-height) - env(safe-area-inset-top, 0));
      display: block;
      margin: 0;
      border: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      cursor: crosshair;
    }
    /* Subtle animated abstract grid overlay behind canvas content for extra depth */
    .bg-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 700px at 130% -20%, rgba(0,234,255,0.08), transparent 60%),
        radial-gradient(900px 600px at -20% 120%, rgba(255,43,214,0.07), transparent 60%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.03) 0 2px, transparent 2px 48px);
      mix-blend-mode: screen;
      opacity: 0.35;
      animation: floatGrid 16s linear infinite;
      z-index: 0;
    }
    @keyframes floatGrid {
      0% { transform: translate3d(0,0,0) }
      100% { transform: translate3d(-48px, -48px, 0) }
    }
    /* Hint bubble */
    .hint {
      position: fixed;
      bottom: calc(16px + env(safe-area-inset-bottom, 0));
      left: 50%;
      transform: translateX(-50%);
      background: rgba(8,12,20,0.6);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.03em;
      color: #cfe9ff;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 18px rgba(0,234,255,0.12);
      z-index: 3;
      user-select: none;
      pointer-events: none;
      opacity: 1;
      transition: opacity 400ms ease;
    }
    .hint.hidden { opacity: 0; }
    @media (min-width: 768px) {
      header#topBar .title { font-size: 15px; }
      .hint { font-size: 13px; }
    }
  </style>
</head>
<body>
  <header id="topBar"><div class="title">Neon Pong</div></header>
  <div class="bg-overlay"></div>
  <canvas id="game"></canvas>

  <div id="touchHint" class="hint">Drag to move • Tap to start/pause</div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: false });
      const topBar = document.getElementById('topBar');
      const hint = document.getElementById('touchHint');

      const COLORS = {
        left: '#00eaff',
        right: '#ff2bd6',
        ball: '#9cff00',
        net: '#a1bfff',
        text: '#d0f2ff'
      };

      const STATE = {
        w: 0, h: 0, dpr: 1,
        t: 0,
        running: false,
        showingWin: false,
        winner: null,
        scores: [0, 0],
        winScore: 7,
        resetCooldown: 0,
        lastTime: 0
      };

      const PADDLES = {
        margin: 0,
        width: 0,
        height: 0,
        shadow: 0,
        leftY: 0,
        rightY: 0,
        leftTargetY: 0, // for smoothing
        rightTargetY: 0,
        aiSpeed: 0
      };

      const BALL = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        r: 0,
        baseSpeed: 0,
        trail: [],
        trailLen: 14
      };

      let input = {
        active: false,
        y: null,
        keyDir: 0 // -1 up, 1 down
      };

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const cssWidth = window.innerWidth;
        const cssHeight = Math.max(160, window.innerHeight - (topBar?.getBoundingClientRect().height || 0));
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        STATE.w = cssWidth;
        STATE.h = cssHeight;
        STATE.dpr = dpr;

        recomputeSizes();
      }

      function recomputeSizes() {
        const w = STATE.w;
        const h = STATE.h;
        const s = Math.min(w, h);

        PADDLES.margin = Math.max(10, w * 0.02);
        PADDLES.width = Math.max(8, w * 0.015);
        PADDLES.height = Math.max(60, h * 0.18);
        PADDLES.shadow = Math.max(8, s * 0.025);
        PADDLES.aiSpeed = Math.max(220, h * 0.55);

        // Keep paddles centered proportionally on resize
        const leftRatio = (PADDLES.leftY + PADDLES.height / 2) / (STATE.h || 1);
        const rightRatio = (PADDLES.rightY + PADDLES.height / 2) / (STATE.h || 1);
        PADDLES.leftY = Math.max(0, (leftRatio || 0.5) * h - PADDLES.height / 2);
        PADDLES.rightY = Math.max(0, (rightRatio || 0.5) * h - PADDLES.height / 2);

        BALL.r = Math.max(6, Math.min(14, s * 0.012));
        BALL.baseSpeed = Math.max(250, s * 0.5);

        if (!STATE.running && !STATE.showingWin) {
          resetBall(Math.random() < 0.5 ? -1 : 1);
        }
      }

      function resetBall(direction) {
        BALL.x = STATE.w * 0.5;
        BALL.y = STATE.h * 0.5;
        const speed = BALL.baseSpeed * 0.9;
        const angle = (Math.random() * 0.6 - 0.3); // slight vertical angle
        BALL.vx = Math.cos(angle) * speed * direction;
        BALL.vy = Math.sin(angle) * speed;
        BALL.trail.length = 0;
        STATE.resetCooldown = 0.65;
      }

      function startGame() {
        if (STATE.showingWin) {
          STATE.showingWin = false;
          STATE.scores = [0, 0];
          STATE.winner = null;
        }
        STATE.running = true;
        hideHint();
      }

      function togglePause() {
        if (STATE.showingWin) return;
        STATE.running = !STATE.running;
        if (STATE.running) hideHint();
        else showHint("Paused • Tap to resume");
      }

      function showHint(text) {
        if (!hint) return;
        if (text) hint.textContent = text;
        hint.classList.remove('hidden');
      }
      function hideHint() {
        if (!hint) return;
        hint.classList.add('hidden');
      }

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      // Input handling
      canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        input.active = true;
        const pos = getPointerPos(e);
        input.y = pos.y;
        PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        PADDLES.leftY = clamp(PADDLES.leftTargetY, 0, STATE.h - PADDLES.height);

        // Start or toggle pause
        if (!STATE.running && !STATE.showingWin) {
          startGame();
        } else if (STATE.showingWin) {
          startGame();
        } else {
          // Short taps that aren't dragging can toggle pause; we'll only toggle on quick taps
          // Here we won't immediately toggle to avoid accidental pauses while dragging
        }
      }, { passive: false });

      canvas.addEventListener('pointermove', (e) => {
        if (!input.active && e.pointerType === 'mouse') {
          // Allow hovering with mouse to control too
          const pos = getPointerPos(e);
          input.y = pos.y;
          PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        } else if (input.active) {
          const pos = getPointerPos(e);
          input.y = pos.y;
          PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        }
        e.preventDefault();
      }, { passive: false });

      canvas.addEventListener('pointerup', (e) => {
        input.active = false;
      });

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePause();
          return;
        }
        if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          STATE.showingWin = false;
          STATE.scores = [0, 0];
          resetBall(Math.random() < 0.5 ? -1 : 1);
          STATE.running = false;
          showHint("Tap to start • Drag to move");
          return;
        }
        if (e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          input.keyDir = -1;
        } else if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          input.keyDir = 1;
        }
      });

      window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          if (input.keyDir < 0) input.keyDir = 0;
        } else if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          if (input.keyDir > 0) input.keyDir = 0;
        }
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden && STATE.running) {
          STATE.running = false;
          showHint("Paused • Tap to resume");
        }
      });

      function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        return { x, y };
      }

      // Game update
      function update(dt) {
        STATE.t += dt;

        // Handle reset cooldown
        if (STATE.resetCooldown > 0) {
          STATE.resetCooldown -= dt;
          if (STATE.resetCooldown < 0) STATE.resetCooldown = 0;
        }

        // Player paddle control (smoothing for touch)
        if (input.keyDir !== 0) {
          const speed = Math.max(270, STATE.h * 0.7);
          PADDLES.leftTargetY = PADDLES.leftY + input.keyDir * speed * dt;
        }
        const smooth = 1 - Math.pow(0.001, dt); // time-based smoothing factor
        PADDLES.leftY += (clamp(PADDLES.leftTargetY, 0, STATE.h - PADDLES.height) - PADDLES.leftY) * smooth;

        // AI movement
        aiMovement(dt);

        // Ball physics
        if (STATE.resetCooldown <= 0) {
          BALL.x += BALL.vx * dt;
          BALL.y += BALL.vy * dt;
        }

        // Wall collisions
        if (BALL.y - BALL.r <= 0) {
          BALL.y = BALL.r;
          BALL.vy = Math.abs(BALL.vy);
        } else if (BALL.y + BALL.r >= STATE.h) {
          BALL.y = STATE.h - BALL.r;
          BALL.vy = -Math.abs(BALL.vy);
        }

        // Paddle collisions
        const leftX = PADDLES.margin;
        const rightX = STATE.w - PADDLES.margin - PADDLES.width;

        // Left
        if (BALL.x - BALL.r <= leftX + PADDLES.width) {
          if (BALL.y >= PADDLES.leftY && BALL.y <= PADDLES.leftY + PADDLES.height) {
            BALL.x = leftX + PADDLES.width + BALL.r;
            bounceOnPaddle(true, PADDLES.leftY);
          }
        }
        // Right
        if (BALL.x + BALL.r >= rightX) {
          if (BALL.y >= PADDLES.rightY && BALL.y <= PADDLES.rightY + PADDLES.height) {
            BALL.x = rightX - BALL.r;
            bounceOnPaddle(false, PADDLES.rightY);
          }
        }

        // Scoring
        if (BALL.x + BALL.r < 0) {
          STATE.scores[1] += 1;
          if (STATE.scores[1] >= STATE.winScore) {
            STATE.showingWin = true;
            STATE.winner = 'Right';
            STATE.running = false;
            showHint("Right Player Won • Tap to play again");
          } else {
            resetBall(1);
          }
        } else if (BALL.x - BALL.r > STATE.w) {
          STATE.scores[0] += 1;
          if (STATE.scores[0] >= STATE.winScore) {
            STATE.showingWin = true;
            STATE.winner = 'Left';
            STATE.running = false;
            showHint("Left Player Won • Tap to play again");
          } else {
            resetBall(-1);
          }
        }

        // Trail
        if (STATE.resetCooldown <= 0) {
          BALL.trail.push({ x: BALL.x, y: BALL.y });
          if (BALL.trail.length > BALL.trailLen) BALL.trail.shift();
        }
      }

      function aiMovement(dt) {
        const center = PADDLES.rightY + PADDLES.height / 2;
        // Predictive target with slight bias and adaptive difficulty
        const reaction = clamp(0.12 + Math.abs(BALL.vx) / 1400, 0.12, 0.45);
        const targetY = BALL.y + Math.sin(STATE.t * 2) * 10;
        const desired = clamp(targetY - PADDLES.height / 2, 0, STATE.h - PADDLES.height);

        // Follow target but not perfectly, scaled by aiSpeed
        const dy = desired - PADDLES.rightY;
        const step = Math.sign(dy) * Math.min(Math.abs(dy), PADDLES.aiSpeed * dt * (0.7 + reaction));
        PADDLES.rightY = clamp(PADDLES.rightY + step, 0, STATE.h - PADDLES.height);
      }

      function bounceOnPaddle(isLeft, paddleY) {
        const paddleCenterY = paddleY + PADDLES.height / 2;
        const relative = (BALL.y - paddleCenterY) / (PADDLES.height / 2); // [-1,1]
        const angle = clamp(relative, -0.9, 0.9) * (Math.PI / 3); // up to 60 deg
        let speed = Math.hypot(BALL.vx, BALL.vy) * 1.04;
        const maxSpeed = BALL.baseSpeed * 1.6;
        speed = Math.min(speed, maxSpeed);

        const dir = isLeft ? 1 : -1;
        BALL.vx = dir * Math.cos(angle) * speed;
        BALL.vy = Math.sin(angle) * speed;

        // Small extra kick if hit near paddle edge
        if (Math.abs(relative) > 0.75) BALL.vy *= 1.05;
      }

      // Render
      function draw() {
        drawBackground();

        if (STATE.showingWin) {
          drawArena();
          drawUI();
          drawWinOverlay();
          return;
        }

        drawArena();
        drawUI();
      }

      function drawBackground() {
        const w = STATE.w, h = STATE.h;
        // Base gradient
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#060814');
        grad.addColorStop(1, '#03040a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        // Animated neon rays
        const t = STATE.t * 0.15;
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.globalCompositeOperation = 'screen';
        ctx.lineWidth = 2;
        const step = Math.max(28, Math.min(44, Math.floor(Math.min(w, h) * 0.05)));
        const offset = (t * 120) % step;
        for (let i = -step; i < w + h; i += step) {
          ctx.strokeStyle = i % (step * 3) === 0 ? 'rgba(0,234,255,0.25)' : 'rgba(255,43,214,0.12)';
          ctx.beginPath();
          ctx.moveTo(i - offset, -10);
          ctx.lineTo(-10, i - offset);
          ctx.stroke();
        }
        ctx.restore();

        // Vignette
        const vg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.2, w/2, h/2, Math.max(w,h)*0.7);
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = vg;
        ctx.fillRect(0, 0, w, h);
      }

      function drawArena() {
        drawNet();

        // Paddles
        drawPaddle(PADDLES.margin, PADDLES.leftY, PADDLES.width, PADDLES.height, COLORS.left, PADDLES.shadow);
        drawPaddle(STATE.w - PADDLES.margin - PADDLES.width, PADDLES.rightY, PADDLES.width, PADDLES.height, COLORS.right, PADDLES.shadow);

        // Ball trail
        drawBallTrail();

        // Ball
        drawBall(BALL.x, BALL.y, BALL.r, COLORS.ball);
      }

      function drawNet() {
        const x = STATE.w / 2;
        const dash = Math.max(10, STATE.h * 0.02);
        ctx.save();
        ctx.lineWidth = Math.max(2, STATE.w * 0.003);
        ctx.setLineDash([dash, dash * 0.7]);
        ctx.strokeStyle = 'rgba(161,191,255,0.25)';
        ctx.shadowColor = 'rgba(161,191,255,0.4)';
        ctx.shadowBlur = Math.max(6, Math.min(18, Math.min(STATE.w, STATE.h) * 0.02));
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, STATE.h);
        ctx.stroke();
        ctx.restore();
      }

      function drawPaddle(x, y, w, h, color, glow) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = glow;
        const r = Math.min(w, h) * 0.25;
        roundRect(ctx, x, y, w, h, r);
        ctx.fill();

        // Inner glossy edge
        const inner = ctx.createLinearGradient(x, y, x + w, y);
        inner.addColorStop(0, 'rgba(255,255,255,0.18)');
        inner.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.shadowBlur = 0;
        ctx.fillStyle = inner;
        roundRect(ctx, x+1, y+1, w-2, h-2, r*0.8);
        ctx.fill();
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      function drawBall(x, y, r, color) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowColor = color;
        ctx.shadowBlur = Math.max(10, r * 3.2);

        // Core
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        // Soft aura
        const g = ctx.createRadialGradient(x, y, r * 0.2, x, y, r * 3.2);
        g.addColorStop(0, color + 'cc');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r * 3.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawBallTrail() {
        if (!BALL.trail.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < BALL.trail.length; i++) {
          const p = BALL.trail[i];
          const alpha = i / BALL.trail.length;
          const radius = BALL.r * (0.5 + alpha * 0.8);
          ctx.fillStyle = `rgba(156,255,0,${alpha * 0.3})`;
          ctx.shadowColor = 'rgba(156,255,0,0.8)';
          ctx.shadowBlur = Math.max(6, BALL.r * 2);
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawUI() {
        const w = STATE.w;
        const h = STATE.h;
        const s = Math.min(w, h);

        // Scores
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const fontSize = Math.max(24, s * 0.06);
        ctx.font = `700 ${fontSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        // Left score
        ctx.shadowColor = COLORS.left;
        ctx.shadowBlur = s * 0.03;
        ctx.fillStyle = '#e6fbff';
        ctx.fillText(STATE.scores[0], w * 0.25, h * 0.05);
        // Right score
        ctx.shadowColor = COLORS.right;
        ctx.fillText(STATE.scores[1], w * 0.75, h * 0.05);
        ctx.restore();

        // Instructions overlay when not running
        if (!STATE.running && !STATE.showingWin) {
          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const titleSize = Math.max(20, s * 0.038);
          const subSize = Math.max(12, s * 0.02);
          ctx.font = `700 ${titleSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          ctx.fillStyle = '#bfeaff';
          ctx.shadowColor = 'rgba(0,234,255,0.8)';
          ctx.shadowBlur = s * 0.02;
          ctx.fillText('Tap to Start • Drag to Move', w/2, h*0.5 - titleSize);

          ctx.font = `500 ${subSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          ctx.shadowBlur = s * 0.015;
          ctx.fillStyle = 'rgba(200,230,255,0.9)';
          ctx.fillText('Space to pause • R to reset', w/2, h*0.5 + subSize * 1.2);
          ctx.restore();
        }

        // Cooldown indicator
        if (STATE.resetCooldown > 0) {
          const prog = 1 - (STATE.resetCooldown / 0.65);
          const radius = Math.max(20, s * 0.06);
          ctx.save();
          ctx.translate(w/2, h/2);
          ctx.strokeStyle = 'rgba(200,230,255,0.35)';
          ctx.lineWidth = Math.max(3, s * 0.006);
          ctx.beginPath();
          ctx.arc(0, 0, radius, -Math.PI/2, -Math.PI/2 + prog * Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawWinOverlay() {
        const w = STATE.w, h = STATE.h, s = Math.min(w, h);
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.fillStyle = '#e8faff';
        ctx.shadowColor = STATE.winner === 'Left' ? COLORS.left : COLORS.right;
        ctx.shadowBlur = s * 0.03;

        const titleSize = Math.max(28, s * 0.065);
        const subSize = Math.max(14, s * 0.028);

        ctx.font = `800 ${titleSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(`${STATE.winner} Player Won!`, w/2, h*0.42);

        ctx.font = `600 ${subSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = '#cfe9ff';
        ctx.shadowBlur = s * 0.02;
        ctx.fillText(`Final Score ${STATE.scores[0]} - ${STATE.scores[1]}`, w/2, h*0.52);

        ctx.font = `600 ${subSize * 0.9}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = '#b3d8ff';
        ctx.shadowBlur = s * 0.015;
        ctx.fillText('Tap to play again', w/2, h*0.62);
        ctx.restore();
      }

      // Main loop
      function loop(ts) {
        if (!STATE.lastTime) STATE.lastTime = ts;
        const dt = clamp((ts - STATE.lastTime) / 1000, 0, 0.05);
        STATE.lastTime = ts;

        if (STATE.running) {
          update(dt);
        }

        draw();
        requestAnimationFrame(loop);
      }

      // Init
      function init() {
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Place paddles in center
        PADDLES.leftY = STATE.h / 2 - PADDLES.height / 2;
        PADDLES.rightY = STATE.h / 2 - PADDLES.height / 2;
        PADDLES.leftTargetY = PADDLES.leftY;
        PADDLES.rightTargetY = PADDLES.rightY;

        resetBall(Math.random() < 0.5 ? -1 : 1);

        // Initial hint timeout fade
        setTimeout(() => hideHint(), 4000);

        requestAnimationFrame(loop);
      }

      init();
    })();
  </script>
</body>
</html>