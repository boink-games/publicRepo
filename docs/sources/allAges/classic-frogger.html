<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Classic Frogger - Modern Edition</title>
  <style>
    :root {
      --bg: radial-gradient(1200px 800px at 10% 10%, #0b132b 0%, #091126 30%, #060d1e 60%, #040a18 100%);
      --fg: #ffffff;
      --glass-bg: rgba(255,255,255,0.06);
      --glass-border: rgba(255,255,255,0.12);
      --glass-shadow: 0 10px 40px rgba(0,0,0,0.35);
      --accent: #60a5fa;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100vh;
      height: 100dvh;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
      position: fixed;
      width: 100%;
    }

    .container {
      height: 100vh;
      height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .game-panel {
      text-align: center;
      padding: clamp(16px, 4vw, 28px);
      border-radius: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(18px) saturate(120%);
      -webkit-backdrop-filter: blur(18px) saturate(120%);
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      max-width: 95vw;
      max-height: 95vh;
      position: relative;
      overflow: visible;
    }

    .stats {
      font-size: clamp(15px, 3.5vw, 18px);
      font-weight: 700;
      margin-bottom: 12px;
      display: flex;
      gap: clamp(12px, 4vw, 20px);
      justify-content: center;
      flex-wrap: wrap;
    }

    .stat-item {
      background: linear-gradient(180deg, rgba(255,255,255,0.09), rgba(255,255,255,0.05));
      padding: 8px 14px;
      border-radius: 14px;
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
    }

    .stats span {
      color: var(--accent);
      text-shadow: 0 0 10px rgba(96,165,250,0.35);
    }

    #gameCanvas {
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      background: #06101f;
      max-width: 100%;
      max-height: 62vh;
      display: block;
      margin: 0 auto;
      box-shadow:
        0 12px 40px rgba(0,0,0,0.35),
        inset 0 4px 10px rgba(255,255,255,0.06),
        0 0 0 1px rgba(255,255,255,0.05);
      touch-action: none;
    }

    .info {
      margin-top: 12px;
      font-size: clamp(12px, 3vw, 14px);
      opacity: 0.85;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .controls {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: clamp(8px, 2vw, 12px);
      max-width: 240px;
      margin-left: auto;
      margin-right: auto;
      user-select: none;
    }

    .control-btn {
      padding: clamp(12px, 3vw, 16px);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      color: var(--fg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      font-size: clamp(16px, 4vw, 20px);
      font-weight: 800;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, border-color 0.12s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .control-btn:active, .control-btn.pressed {
      background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.06));
      transform: scale(0.96);
      border-color: rgba(255,255,255,0.2);
      box-shadow: inset 0 6px 20px rgba(0,0,0,0.35);
    }
    .control-btn:hover {
      box-shadow: 0 10px 28px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.12);
    }

    .empty { visibility: hidden; }

    .restart-btn {
      margin-top: 14px;
      padding: 12px 22px;
      background: linear-gradient(135deg, #60a5fa, #3b82f6);
      color: var(--fg);
      border: 0;
      border-radius: 14px;
      font-weight: 800;
      cursor: pointer;
      font-size: clamp(14px, 3vw, 16px);
      box-shadow: 0 8px 28px rgba(59,130,246,0.35);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .restart-btn:active { transform: scale(0.97); }
    .restart-btn:hover { box-shadow: 0 12px 32px rgba(59,130,246,0.45); }

    .game-over {
      font-size: clamp(18px, 4vw, 22px);
      color: #f87171;
      margin-top: 12px;
      font-weight: 800;
      text-shadow: 0 0 10px rgba(248,113,113,0.45);
      animation: pulse 1.6s ease-in-out infinite alternate;
    }

    @keyframes pulse { from { opacity: .8; } to { opacity: 1; } }

    @media (max-width: 480px) {
      .game-panel { padding: 14px; margin: 8px; }
      .stats { gap: 12px; font-size: 14px; }
      .controls { max-width: 200px; gap: 8px; }
    }

    @media (orientation: landscape) and (max-height: 500px) {
      .container { flex-direction: row; gap: 20px; }
      #gameCanvas { max-height: 70vh; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="game-panel">
      <div class="stats" role="status" aria-live="polite">
        <div class="stat-item">Score: <span id="score">0</span></div>
        <div class="stat-item">Lives: <span id="lives">3</span></div>
        <div class="stat-item">Level: <span id="level">1</span></div>
      </div>
      <canvas id="gameCanvas" width="480" height="480"></canvas>
      <div class="info">Use arrow keys, swipe, or tap controls. Avoid traffic, ride the logs, reach the top!</div>
      <div class="controls" aria-label="Touch controls">
        <div class="empty" aria-hidden="true"></div>
        <button class="control-btn" id="up" aria-label="Move up">↑</button>
        <div class="empty" aria-hidden="true"></div>
        <button class="control-btn" id="left" aria-label="Move left">←</button>
        <button class="control-btn" id="down" aria-label="Move down">↓</button>
        <button class="control-btn" id="right" aria-label="Move right">→</button>
      </div>
      <div id="gameOver" class="game-over" style="display:none;">
        Game Over!
        <br>
        <button class="restart-btn" onclick="restartGame()">Restart Game</button>
      </div>
    </div>
  </div>

  <script>
    // Canvas and UI
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const gameOverEl = document.getElementById('gameOver');

    // Device pixel ratio scaling
    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    let CSS_SIZE = 480;
    const ROWS = 12;
    let gridSize = 40;
    let cols = 12, rows = 12;

    // Game state
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameRunning = true;
    let particles = [];
    let lastTime = 0;
    let waterTime = 0;

    // Assets (SVG data URIs)
    const svgFrog = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
        <defs>
          <radialGradient id="gBody" cx="50%" cy="40%" r="60%">
            <stop offset="0%" stop-color="#67e38f"/>
            <stop offset="60%" stop-color="#27c36a"/>
            <stop offset="100%" stop-color="#179a52"/>
          </radialGradient>
          <radialGradient id="gBelly" cx="50%" cy="70%" r="55%">
            <stop offset="0%" stop-color="#d9f99d"/>
            <stop offset="100%" stop-color="#a3e635" stop-opacity="0.9"/>
          </radialGradient>
          <filter id="soft" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="1.2"/>
          </filter>
        </defs>
        <!-- Shadow -->
        <ellipse cx="128" cy="210" rx="60" ry="20" fill="#000" opacity="0.18" filter="url(#soft)"/>
        <!-- Back legs -->
        <g opacity="0.95">
          <path d="M30 160c18-10 44-18 54-10s4 24-10 28-40-1-44-18z" fill="#1a7c4a"/>
          <path d="M226 160c-18-10-44-18-54-10s-4 24 10 28 40-1 44-18z" fill="#1a7c4a"/>
        </g>
        <!-- Body -->
        <ellipse cx="128" cy="120" rx="68" ry="86" fill="url(#gBody)"/>
        <!-- Belly -->
        <ellipse cx="128" cy="150" rx="38" ry="46" fill="url(#gBelly)" opacity="0.85"/>
        <!-- Spots -->
        <g fill="#0d6b3f" opacity="0.35">
          <circle cx="98" cy="110" r="6"/>
          <circle cx="156" cy="100" r="5"/>
          <circle cx="126" cy="86" r="4"/>
          <circle cx="148" cy="128" r="3.5"/>
          <circle cx="110" cy="134" r="4"/>
        </g>
        <!-- Front legs -->
        <g>
          <path d="M64 122c-18 8-26 22-24 28 2 6 12 5 20 0 8-5 16-16 18-22 2-6-4-10-14-6z" fill="#1a7c4a"/>
          <path d="M192 122c18 8 26 22 24 28-2 6-12 5-20 0-8-5-16-16-18-22-2-6 4-10 14-6z" fill="#1a7c4a"/>
        </g>
        <!-- Eyes -->
        <g>
          <ellipse cx="94" cy="72" rx="18" ry="16" fill="#1f9d5b"/>
          <ellipse cx="162" cy="72" rx="18" ry="16" fill="#1f9d5b"/>
          <circle cx="94" cy="72" r="10" fill="#ffffff"/>
          <circle cx="162" cy="72" r="10" fill="#ffffff"/>
          <circle cx="96" cy="74" r="6" fill="#171717"/>
          <circle cx="164" cy="74" r="6" fill="#171717"/>
          <circle cx="99" cy="71" r="2.5" fill="#fff" opacity="0.9"/>
          <circle cx="167" cy="71" r="2.5" fill="#fff" opacity="0.9"/>
        </g>
        <!-- Highlights -->
        <ellipse cx="120" cy="62" rx="32" ry="14" fill="#fff" opacity="0.08"/>
        <ellipse cx="148" cy="186" rx="26" ry="10" fill="#fff" opacity="0.06"/>
      </svg>
    `;
    const svgCar = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 160">
        <defs>
          <linearGradient id="carPaint" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#d0d3d6"/>
            <stop offset="50%" stop-color="#b4b8bd"/>
            <stop offset="100%" stop-color="#dfe2e5"/>
          </linearGradient>
          <linearGradient id="glass" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#7cc7ff" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#2a6fb8" stop-opacity="0.9"/>
          </linearGradient>
          <linearGradient id="shadow" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#000" stop-opacity="0.12"/>
            <stop offset="100%" stop-color="#000" stop-opacity="0.28"/>
          </linearGradient>
        </defs>
        <!-- Shadow -->
        <rect x="10" y="20" width="300" height="120" rx="24" fill="url(#shadow)"/>
        <!-- Body -->
        <rect x="10" y="10" width="300" height="120" rx="24" fill="url(#carPaint)"/>
        <!-- Windows -->
        <rect x="70" y="24" width="180" height="40" rx="8" fill="url(#glass)"/>
        <rect x="70" y="76" width="180" height="40" rx="8" fill="url(#glass)"/>
        <!-- Pillars -->
        <rect x="62" y="24" width="6" height="92" fill="#2a2f36" opacity="0.6"/>
        <rect x="252" y="24" width="6" height="92" fill="#2a2f36" opacity="0.6"/>
        <!-- Wheels -->
        <rect x="18" y="18" width="8" height="104" rx="4" fill="#1e1e1e"/>
        <rect x="294" y="18" width="8" height="104" rx="4" fill="#1e1e1e"/>
        <!-- Highlights -->
        <rect x="14" y="14" width="292" height="8" rx="4" fill="#fff" opacity="0.2"/>
        <rect x="14" y="122" width="292" height="6" rx="3" fill="#000" opacity="0.12"/>
      </svg>
    `;
    const svgLog = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 100">
        <defs>
          <linearGradient id="bark" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#a76a3d"/>
            <stop offset="100%" stop-color="#6a3f20"/>
          </linearGradient>
          <linearGradient id="rim" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#4a2b15"/>
            <stop offset="100%" stop-color="#321c0e"/>
          </linearGradient>
        </defs>
        <!-- Bark -->
        <rect x="6" y="8" width="308" height="84" rx="20" fill="url(#bark)"/>
        <!-- Texture lines -->
        <g stroke="#5b371c" stroke-width="2" opacity="0.6">
          <path d="M20 28c60 20 120 20 200 14 40-4 70-16 90-24"/>
          <path d="M18 48c70 20 160 26 230 10"/>
          <path d="M22 68c40 8 90 12 180 6 40-2 80-8 108-18"/>
        </g>
        <!-- Knots -->
        <g fill="#4f2e18" opacity="0.9">
          <circle cx="120" cy="40" r="6"/>
          <circle cx="210" cy="60" r="5"/>
          <circle cx="260" cy="36" r="7"/>
        </g>
        <!-- Rim shading -->
        <rect x="6" y="8" width="308" height="8" rx="4" fill="#fff" opacity="0.15"/>
        <rect x="6" y="84" width="308" height="8" rx="4" fill="#000" opacity="0.2"/>
        <!-- Ends -->
        <rect x="6" y="8" width="16" height="84" rx="10" fill="url(#rim)" opacity="0.9"/>
        <rect x="298" y="8" width="16" height="84" rx="10" fill="url(#rim)" opacity="0.9"/>
      </svg>
    `;

    function makeImage(svg) {
      const img = new Image();
      img.decoding = 'async';
      img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
      return img;
    }
    const frogImg = makeImage(svgFrog);
    const carImg = makeImage(svgCar);
    const logImg = makeImage(svgLog);

    const assetsReady = Promise.all([
      new Promise(res => frogImg.onload = res),
      new Promise(res => carImg.onload = res),
      new Promise(res => logImg.onload = res),
    ]);

    // Haptics
    function vibrate(pattern = 40) { try { navigator.vibrate && navigator.vibrate(pattern); } catch (e) {} }

    // Particles
    function createParticles(x, y, color, count = 6, size = 3) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x + (Math.random() - 0.5) * 16,
          y: y + (Math.random() - 0.5) * 16,
          vx: (Math.random() - 0.5) * 2.4,
          vy: -Math.random() * 2.4 - 0.6,
          color,
          life: 1,
          size: size + Math.random() * 2,
          decay: 0.025 + Math.random() * 0.02
        });
      }
    }
    function updateParticles(dt) {
      particles = particles.filter(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= p.decay * dt;
        return p.life > 0;
      });
    }
    function drawParticles() {
      for (const p of particles) {
        ctx.save();
        ctx.globalAlpha = Math.max(p.life, 0);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // World definition
    const lanes = [
      { y: 11, type: 'safe', speed: 0 },
      { y: 10, type: 'road', speed: 1.2, dir: 1 },
      { y: 9,  type: 'road', speed: 1.6, dir: -1 },
      { y: 8,  type: 'road', speed: 1.2, dir: 1 },
      { y: 7,  type: 'road', speed: 2.0, dir: -1 },
      { y: 6,  type: 'safe', speed: 0 },
      { y: 5,  type: 'water', speed: 1.2, dir: 1 },
      { y: 4,  type: 'water', speed: 1.6, dir: -1 },
      { y: 3,  type: 'water', speed: 1.2, dir: 1 },
      { y: 2,  type: 'water', speed: 1.4, dir: -1 },
      { y: 1,  type: 'water', speed: 1.6, dir: 1 },
      { y: 0,  type: 'goal', speed: 0 }
    ];

    // Entities
    const frog = {
      x: 0, y: 0, size: 0,
      hop: 0, // 0..1
      blink: 0, blinkTimer: 0
    };
    let vehicles = [];
    let logs = [];

    // Resize and scale
    function resizeCanvas() {
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      const container = canvas.parentElement;
      const maxWidth = Math.min(container.clientWidth - 32, 540);
      const maxHeight = Math.min(container.clientHeight * 0.62, 540);
      CSS_SIZE = Math.max(280, Math.min(maxWidth, maxHeight));
      canvas.style.width = CSS_SIZE + 'px';
      canvas.style.height = CSS_SIZE + 'px';
      canvas.width = Math.round(CSS_SIZE * DPR);
      canvas.height = Math.round(CSS_SIZE * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      gridSize = CSS_SIZE / ROWS;
      cols = Math.round(CSS_SIZE / gridSize);
      rows = ROWS;

      // Adjust frog size and reposition to grid
      frog.size = gridSize * 0.9;
      resetFrog(false);
      initLevel(); // rebuild entities to fit new sizes
    }
    window.addEventListener('resize', () => {
      const prevGS = gridSize;
      resizeCanvas();
      // keep score etc
      updateHUD();
    });

    function updateHUD() {
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      levelEl.textContent = level;
    }

    function initLevel() {
      vehicles = [];
      logs = [];

      for (const lane of lanes) {
        const y = lane.y * gridSize;
        if (lane.type === 'road') {
          const count = 3;
          for (let i = 0; i < count; i++) {
            const width = gridSize * (1.8 + Math.random() * 0.4);
            const height = gridSize * 0.78;
            vehicles.push({
              x: i * (CSS_SIZE / count) + Math.random() * (gridSize * 0.8) - width,
              y: y + (gridSize - height) * 0.5,
              width,
              height,
              speed: lane.speed * lane.dir * (1 + level * 0.14),
              color: lane.dir > 0 ? '#e11d48' : '#f59e0b',
              glow: lane.dir > 0 ? 'rgba(225,29,72,0.55)' : 'rgba(245,158,11,0.55)'
            });
          }
        } else if (lane.type === 'water') {
          const count = 2;
          for (let i = 0; i < count; i++) {
            const width = gridSize * (2.6 + Math.random() * 1.1);
            const height = gridSize * 0.74;
            logs.push({
              x: i * (CSS_SIZE / count) + Math.random() * (gridSize * 1.2) - width,
              y: y + (gridSize - height) * 0.5,
              width,
              height,
              speed: lane.speed * lane.dir * (1 + level * 0.1)
            });
          }
        }
      }
    }

    function resetFrog(emitParticles = true) {
      frog.x = Math.floor(cols / 2) * gridSize + (gridSize - frog.size) * 0.5;
      frog.y = (rows - 1) * gridSize + (gridSize - frog.size) * 0.5;
      frog.hop = 0;
      if (emitParticles) createParticles(frog.x + frog.size / 2, frog.y + frog.size / 2, 'rgba(16,185,129,0.6)', 8, 3);
    }

    function loseLife() {
      if (!gameRunning) return;
      lives--;
      updateHUD();
      vibrate([120, 60, 120]);
      createParticles(frog.x + frog.size/2, frog.y + frog.size/2, 'rgba(239,68,68,0.9)', 12, 4);
      if (lives <= 0) {
        gameOver();
      } else {
        resetFrog();
      }
    }

    function gameOver() {
      gameRunning = false;
      gameOverEl.style.display = 'block';
      vibrate([180, 80, 180, 80, 180]);
    }

    function restartGame() {
      score = 0;
      lives = 3;
      level = 1;
      updateHUD();
      gameOverEl.style.display = 'none';
      resetFrog(false);
      initLevel();
      particles = [];
      gameRunning = true;
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }
    window.restartGame = restartGame;

    // Drawing helpers
    function drawVignette() {
      const g = ctx.createRadialGradient(CSS_SIZE/2, CSS_SIZE/2, CSS_SIZE*0.2, CSS_SIZE/2, CSS_SIZE/2, CSS_SIZE*0.7);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.45)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, CSS_SIZE, CSS_SIZE);
    }

    function drawLightOnFrog() {
      const cx = frog.x + frog.size/2;
      const cy = frog.y + frog.size/2;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const R = Math.max(gridSize * 1.5, 50);
      const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
      rg.addColorStop(0, 'rgba(180,255,210,0.35)');
      rg.addColorStop(0.6, 'rgba(100,220,170,0.12)');
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawLanes() {
      for (const lane of lanes) {
        const y = lane.y * gridSize;
        if (lane.type === 'safe') {
          const grad = ctx.createLinearGradient(0, y, 0, y + gridSize);
          grad.addColorStop(0, '#0b6a3b');
          grad.addColorStop(1, '#0a5a33');
          ctx.fillStyle = grad;
          ctx.fillRect(0, y, CSS_SIZE, gridSize);
          // Grass blades
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 18; i++) {
            const gx = (i / 18) * CSS_SIZE;
            ctx.beginPath();
            ctx.moveTo(gx, y + gridSize);
            ctx.lineTo(gx + 4, y + gridSize - 8 - (i % 3));
            ctx.stroke();
          }
          ctx.restore();
        } else if (lane.type === 'road') {
          const grad = ctx.createLinearGradient(0, y, 0, y + gridSize);
          grad.addColorStop(0, '#3b3f47');
          grad.addColorStop(1, '#2a2e35');
          ctx.fillStyle = grad;
          ctx.fillRect(0, y, CSS_SIZE, gridSize);
          // Lane stripe
          ctx.save();
          ctx.strokeStyle = 'rgba(251,191,36,0.9)';
          ctx.lineWidth = Math.max(2, gridSize * 0.05);
          ctx.setLineDash([Math.max(10, gridSize * 0.6), Math.max(6, gridSize * 0.4)]);
          ctx.shadowColor = 'rgba(251,191,36,0.6)';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.moveTo(0, y + gridSize / 2);
          ctx.lineTo(CSS_SIZE, y + gridSize / 2);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        } else if (lane.type === 'water') {
          // Base water gradient
          const g = ctx.createLinearGradient(0, y, 0, y + gridSize);
          g.addColorStop(0, '#113b86');
          g.addColorStop(1, '#0d255a');
          ctx.fillStyle = g;
          ctx.fillRect(0, y, CSS_SIZE, gridSize);

          // Animated water shimmer
          const waves = 6;
          const amp = Math.max(2, gridSize * 0.06);
          ctx.save();
          ctx.globalAlpha = 0.18;
          ctx.lineWidth = Math.max(1.2, gridSize * 0.03);
          for (let i = 0; i < waves; i++) {
            ctx.beginPath();
            const color = i % 2 ? '#a5f3fc' : '#93c5fd';
            ctx.strokeStyle = color;
            const k = 0.012 + i * 0.003;
            const phase = waterTime * (0.7 + i * 0.15) + i;
            for (let x = 0; x <= CSS_SIZE; x += 6) {
              const yy = y + gridSize * (0.2 + 0.6 * (i / waves)) + Math.sin(x * k + phase) * amp;
              if (x === 0) ctx.moveTo(x, yy);
              else ctx.lineTo(x, yy);
            }
            ctx.stroke();
          }
          ctx.restore();

          // Soft reflective highlight band
          const rg = ctx.createLinearGradient(0, y, 0, y + gridSize);
          rg.addColorStop(0.2, 'rgba(255,255,255,0.06)');
          rg.addColorStop(0.5, 'rgba(255,255,255,0.12)');
          rg.addColorStop(0.8, 'rgba(255,255,255,0.06)');
          ctx.fillStyle = rg;
          ctx.globalCompositeOperation = 'screen';
          ctx.fillRect(0, y, CSS_SIZE, gridSize);
          ctx.globalCompositeOperation = 'source-over';
        } else if (lane.type === 'goal') {
          const grad = ctx.createLinearGradient(0, y, CSS_SIZE, y);
          grad.addColorStop(0, '#fbbf24');
          grad.addColorStop(0.5, '#f59e0b');
          grad.addColorStop(1, '#fbbf24');
          ctx.fillStyle = grad;
          ctx.fillRect(0, y, CSS_SIZE, gridSize);
          // Glow line
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(0, y + gridSize - 4, CSS_SIZE, 4);
          ctx.restore();
        }
      }
    }

    function drawVehicles() {
      for (const v of vehicles) {
        ctx.save();
        // Car sprite
        ctx.shadowColor = v.glow;
        ctx.shadowBlur = 10;
        ctx.drawImage(carImg, v.x, v.y, v.width, v.height);
        // Tint paint
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = v.color;
        ctx.fillRect(v.x, v.y, v.width, v.height);
        ctx.globalCompositeOperation = 'source-over';

        // Headlights / taillights
        const isRight = v.speed > 0;
        const lx = isRight ? v.x + v.width - 5 : v.x + 2;
        const ly = v.y + v.height * 0.15;
        const lh = v.height * 0.7;
        ctx.save();
        ctx.shadowBlur = 8;
        if (isRight) {
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.shadowColor = 'rgba(255,255,255,0.8)';
        } else {
          ctx.fillStyle = 'rgba(255,40,40,0.95)';
          ctx.shadowColor = 'rgba(255,50,50,0.9)';
        }
        ctx.fillRect(lx, ly, 3, lh);
        ctx.restore();

        ctx.restore();
      }
    }

    function drawLogs() {
      for (const l of logs) {
        ctx.save();
        ctx.drawImage(logImg, l.x, l.y, l.width, l.height);

        // Wet shine
        ctx.globalCompositeOperation = 'overlay';
        const grad = ctx.createLinearGradient(l.x, l.y, l.x, l.y + l.height);
        grad.addColorStop(0, 'rgba(255,255,255,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0.2)');
        ctx.fillStyle = grad;
        ctx.fillRect(l.x, l.y, l.width, l.height);
        ctx.globalCompositeOperation = 'source-over';

        ctx.restore();
      }
    }

    function drawFrog() {
      ctx.save();
      // Hop animation scale/offset
      const hopLift = Math.sin(Math.PI * frog.hop) * gridSize * 0.14;
      const scale = 1 + Math.sin(Math.PI * frog.hop) * 0.06;

      const drawX = frog.x + frog.size * (1 - scale) * 0.5;
      const drawY = frog.y - hopLift + frog.size * (1 - scale) * 0.5;
      const drawW = frog.size * scale;
      const drawH = frog.size * scale;

      // Frog rim glow
      ctx.shadowColor = 'rgba(16,185,129,0.6)';
      ctx.shadowBlur = 12;

      ctx.drawImage(frogImg, drawX, drawY, drawW, drawH);

      // Eye blink overlay (simple darker lids)
      frog.blinkTimer -= 0.016;
      if (frog.blinkTimer <= 0) {
        frog.blink = Math.min(1, frog.blink + 0.25);
        if (frog.blink >= 1) {
          frog.blinkTimer = 2 + Math.random() * 3;
          frog.blink = 0;
        }
      }
      if (frog.blink > 0) {
        const eW = drawW * 0.12, eH = drawH * 0.09 * frog.blink;
        const eY = drawY + drawH * 0.28;
        const e1x = drawX + drawW * 0.34;
        const e2x = drawX + drawW * 0.66;
        ctx.fillStyle = 'rgba(20,83,45,0.8)';
        ctx.fillRect(e1x - eW/2, eY - eH/2, eW, eH);
        ctx.fillRect(e2x - eW/2, eY - eH/2, eW, eH);
      }

      ctx.restore();
    }

    function drawBackground() {
      // Night sky gradient already via CSS background; add subtle stars
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 40; i++) {
        const x = (i * 97) % CSS_SIZE;
        const y = ((i * 53 + 200) % Math.max(80, CSS_SIZE * 0.35));
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.restore();
    }

    // Update
    function updateObjects(dt) {
      // Vehicles
      for (const v of vehicles) {
        v.x += v.speed * dt * (1.0 + level * 0.02);
        if (v.speed > 0 && v.x > CSS_SIZE) v.x = -v.width - 4;
        if (v.speed < 0 && v.x < -v.width) v.x = CSS_SIZE + 4;
      }
      // Logs
      for (const l of logs) {
        l.x += l.speed * dt * (1.0 + level * 0.01);
        if (l.speed > 0 && l.x > CSS_SIZE) l.x = -l.width - 4;
        if (l.speed < 0 && l.x < -l.width) l.x = CSS_SIZE + 4;
      }
    }

    function checkCollisions() {
      const frogRow = Math.floor((frog.y + frog.size * 0.5) / gridSize);
      const lane = lanes.find(l => l.y === frogRow);
      if (!lane) return;

      // Road collisions
      if (lane.type === 'road') {
        for (const v of vehicles) {
          if (rectsOverlap(frog.x, frog.y, frog.size, frog.size, v.x + 2, v.y + 2, v.width - 4, v.height - 4)) {
            loseLife();
            return;
          }
        }
      }

      // Water check
      if (lane.type === 'water') {
        let onLog = false;
        for (const l of logs) {
          if (rectsOverlap(frog.x + 6, frog.y + 6, frog.size - 12, frog.size - 12, l.x, l.y, l.width, l.height)) {
            onLog = true;
            frog.x += l.speed; // carry frog with log
            break;
          }
        }
        if (!onLog) {
          // Drown
          createParticles(frog.x + frog.size/2, frog.y + frog.size/2, 'rgba(59,130,246,0.9)', 10, 3);
          loseLife();
          return;
        }
      }

      // Goal reached
      if (lane.type === 'goal') {
        score += Math.round(100 * level);
        level++;
        updateHUD();
        createParticles(frog.x + frog.size/2, frog.y + frog.size/2, 'rgba(251,191,36,0.95)', 16, 4);
        vibrate([50, 50, 50]);
        resetFrog();
        initLevel();
      }

      // Bounds
      if (frog.x < -4 || frog.x > CSS_SIZE - frog.size + 4) {
        loseLife();
      }
    }

    function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2) {
      return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
    }

    function draw() {
      // Clear
      ctx.clearRect(0, 0, CSS_SIZE, CSS_SIZE);
      drawBackground();
      drawLanes();
      drawLogs();
      drawVehicles();
      drawFrog();
      drawParticles();
      drawLightOnFrog();
      drawVignette();
    }

    function gameLoop(ts) {
      if (!gameRunning) return;
      const dt = Math.max(0.5, Math.min((ts - lastTime) / 16.67, 2.5));
      lastTime = ts;
      waterTime += 0.015 * dt;

      updateObjects(dt);
      checkCollisions();
      updateParticles(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Movement
    function moveFrog(dx, dy) {
      if (!gameRunning) return;

      const nx = frog.x + dx * gridSize;
      const ny = frog.y + dy * gridSize;

      if (nx >= -2 && nx <= CSS_SIZE - frog.size + 2 &&
          ny >= -2 && ny <= CSS_SIZE - frog.size + 2) {
        frog.x = nx;
        frog.y = ny;

        vibrate(20);
        frog.hop = 0.0001; // trigger hop anim

        if (dy < 0) {
          score += 10;
          updateHUD();
          createParticles(frog.x + frog.size/2, frog.y + frog.size/2, 'rgba(16,185,129,0.8)', 4, 3);
        }
      }
    }

    // Animate hop over time
    function updateHop(dt) {
      if (frog.hop > 0) {
        frog.hop += 0.12 * dt;
        if (frog.hop >= 1) frog.hop = 0;
      }
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;
      if (e.key === 'ArrowUp') { e.preventDefault(); moveFrog(0, -1); }
      else if (e.key === 'ArrowDown') { e.preventDefault(); moveFrog(0, 1); }
      else if (e.key === 'ArrowLeft') { e.preventDefault(); moveFrog(-1, 0); }
      else if (e.key === 'ArrowRight') { e.preventDefault(); moveFrog(1, 0); }
    });

    function setupButton(id, dx, dy) {
      const btn = document.getElementById(id);
      if (!btn) return;
      const press = (e) => { e.preventDefault(); btn.classList.add('pressed'); moveFrog(dx, dy); };
      const release = (e) => { e.preventDefault(); btn.classList.remove('pressed'); };
      btn.addEventListener('mousedown', press);
      document.addEventListener('mouseup', release);
      btn.addEventListener('touchstart', press, { passive: false });
      btn.addEventListener('touchend', release, { passive: false });
      btn.addEventListener('touchcancel', release, { passive: false });
      btn.addEventListener('mouseleave', release);
    }
    setupButton('up', 0, -1);
    setupButton('down', 0, 1);
    setupButton('left', -1, 0);
    setupButton('right', 1, 0);

    // Swipe on canvas
    let touchStartX = null, touchStartY = null;
    canvas.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchStartX = t.clientX - rect.left;
      touchStartY = t.clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (touchStartX === null || touchStartY === null) return;
      const rect = canvas.getBoundingClientRect();
      const t = e.changedTouches[0];
      const endX = t.clientX - rect.left;
      const endY = t.clientY - rect.top;
      const dx = endX - touchStartX;
      const dy = endY - touchStartY;
      const threshold = Math.max(24, gridSize * 0.4);
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
        moveFrog(dx > 0 ? 1 : -1, 0);
      } else if (Math.abs(dy) > threshold) {
        moveFrog(0, dy > 0 ? 1 : -1);
      }
      touchStartX = touchStartY = null;
    }, { passive: false });

    // Pause when hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) gameRunning = false;
      else if (lives > 0) { gameRunning = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); }
    });

    // Kickoff
    function start() {
      resizeCanvas();
      frog.size = gridSize * 0.9;
      frog.blinkTimer = 1 + Math.random() * 2.5;
      resetFrog(false);
      initLevel();
      updateHUD();
      lastTime = performance.now();

      // Animate loop with hop updater wrapped
      (function loop(ts) {
        if (!gameRunning) return;
        const dt = Math.max(0.5, Math.min((ts - lastTime) / 16.67, 2.5));
        lastTime = ts;
        waterTime += 0.015 * dt;
        updateObjects(dt);
        checkCollisions();
        updateParticles(dt);
        updateHop(dt);
        draw();
        requestAnimationFrame(loop);
      })(lastTime);
    }

    assetsReady.then(start);
  </script>
</body>
</html>