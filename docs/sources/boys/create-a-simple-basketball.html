<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Hoop Tap - Mini Basketball</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0f1631">
<style>
  :root{
    --ui-bg: rgba(15,22,49,0.55);
    --ui-fg: #f6f8ff;
    --accent: #ff8d2c;
    --accent-dim: rgba(255,141,44,0.2);
    --green: #2ee59d;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: linear-gradient(180deg, #0f1631 0%, #15214a 60%, #1b2e63 100%);
    color: var(--ui-fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol";
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    overscroll-behavior: none;
  }
  #game {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
  }
  #hud {
    position: fixed;
    inset: env(safe-area-inset-top) 0 auto 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 10px 12px;
    pointer-events: none;
  }
  .pill {
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    background: var(--ui-bg);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    pointer-events: auto;
  }
  #scoreWrap {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
  }
  #score, #best {
    font-weight: 800;
    letter-spacing: 0.4px;
  }
  #best {
    opacity: 0.75;
    font-weight: 700;
    font-size: 14px;
  }
  #controls {
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  .btn {
    appearance: none;
    border: none;
    background: var(--ui-bg);
    color: var(--ui-fg);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    padding: 8px 12px;
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    line-height: 1;
    transition: transform 0.08s ease, background 0.2s ease, opacity 0.2s ease;
  }
  .btn:active { transform: scale(0.96); }
  #help {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: calc(14px + env(safe-area-inset-bottom));
    padding: 10px 14px;
    text-align: center;
    max-width: min(92vw, 600px);
    line-height: 1.25;
  }
  #help.hidden { opacity: 0; pointer-events: none; transition: opacity 0.5s ease 0.1s; }
  #help .title {
    font-weight: 800;
    font-size: 16px;
    margin-bottom: 6px;
    letter-spacing: 0.3px;
  }
  #help .lines {
    opacity: 0.9;
    font-size: 14px;
  }
  #footerTip {
    position: fixed;
    left: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom));
    font-size: 12px;
    opacity: 0.65;
    pointer-events: none;
  }
  a, a:visited { color: #d5e2ff; text-decoration: none; border-bottom: 1px dashed rgba(255,255,255,0.25); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div id="scoreWrap" class="pill">
    <div id="score">Score: 0</div>
    <div id="best">Best: 0</div>
  </div>
  <div id="controls">
    <button id="muteBtn" class="btn" aria-label="Toggle Voice">ðŸ”Š Voice</button>
    <button id="resetBtn" class="btn" aria-label="Reset Game">â†» Reset</button>
  </div>
</div>

<div id="help" class="pill">
  <div class="title">How to Play</div>
  <div class="lines">
    - Hold anywhere to aim and build power, release to shoot.<br>
    - Desktop: hold Space or mouse; Mobile: touch and hold.<br>
    - Sink it through the hoop to score. Good luck!
  </div>
</div>

<div id="footerTip">Tip: Turn on device sound for voice feedback.</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let W = 0, H = 0;

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const muteBtn = document.getElementById('muteBtn');
  const resetBtn = document.getElementById('resetBtn');
  const helpEl = document.getElementById('help');

  let score = 0;
  let best = parseInt(localStorage.getItem('hoop_best') || '0', 10) || 0;
  let ttsMuted = localStorage.getItem('hoop_tts_muted') === '1';

  function updateHUD(){
    scoreEl.textContent = 'Score: ' + score;
    bestEl.textContent = 'Best: ' + best;
    muteBtn.textContent = (ttsMuted ? 'ðŸ”‡ Voice' : 'ðŸ”Š Voice');
  }
  updateHUD();

  // World / game parameters (dynamic with size)
  let base = 0;
  let gravity = 1200; // px/s^2 (set on resize)
  const floorH = 28;

  const state = {
    phase: 'idle', // 'idle' | 'charging' | 'flying'
    startedOnce: false,
    holdStart: 0,
    lastAimTime: 0,
    releaseAngle: 0,
    releaseSpeed: 0
  };

  const ball = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    r: 16,
    scorable: false,
    scored: false
  };

  const hoop = {
    x: 0, y: 0,
    rimR: 28,
    boardW: 10,
    boardH: 100,
    boardGap: 10
  };

  let netStretch = 0; // 0..1 animation on score
  let particles = [];

  function resize(){
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth, clientHeight } = document.documentElement;
    canvas.width = Math.floor(clientWidth * dpr);
    canvas.height = Math.floor(clientHeight * dpr);
    W = clientWidth;
    H = clientHeight;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    base = Math.min(W, H);
    ball.r = Math.max(10, Math.floor(base * 0.032));
    hoop.rimR = Math.max(24, Math.floor(base * 0.045));
    hoop.boardW = Math.max(8, Math.floor(base * 0.018));
    hoop.boardH = Math.max(80, Math.floor(base * 0.22));
    hoop.boardGap = Math.max(8, Math.floor(base * 0.02));
    gravity = Math.max(900, Math.floor(base * 2.7));

    // Positions
    spawnBall(true);
    hoop.x = Math.floor(W * 0.78);
    hoop.y = Math.floor(H * 0.26);

    // Reset flight if resizing mid-air
    if (state.phase === 'flying') {
      resetBall();
    }
  }

  function spawnBall(hard=false){
    if (hard) {
      ball.x = Math.floor(W * 0.22);
      ball.y = Math.floor(H * 0.86);
    }
    ball.vx = 0;
    ball.vy = 0;
    ball.scorable = false;
    ball.scored = false;
  }

  function resetBall(){
    state.phase = 'idle';
    spawnBall();
  }

  window.addEventListener('resize', resize);
  resize();

  // Input handling
  let pointerActive = false;
  let pointerId = null;

  function beginCharge(){
    if (state.phase !== 'idle') return;
    pointerActive = true;
    state.phase = 'charging';
    state.holdStart = performance.now();
    state.lastAimTime = state.holdStart;
    showHelp(false);
  }

  function endCharge(){
    if (state.phase !== 'charging') return;
    pointerActive = false;
    const now = performance.now();

    const { angle, power01 } = getAim(now);
    const speed = lerp(base * 1.25, base * 2.2, power01);
    ball.vx = Math.cos(angle) * speed;
    ball.vy = -Math.sin(angle) * speed;
    state.releaseAngle = angle;
    state.releaseSpeed = speed;
    state.phase = 'flying';
    ball.scorable = true;
    ball.scored = false;
    state.startedOnce = true;
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if (e.button !== 0) return;
    const onUI = e.target !== canvas;
    if (onUI) return;
    e.preventDefault();
    pointerId = e.pointerId;
    beginCharge();
  }, {passive:false});
  window.addEventListener('pointerup', (e)=>{
    if (!pointerActive || e.pointerId !== pointerId) return;
    e.preventDefault();
    endCharge();
  }, {passive:false});
  window.addEventListener('pointercancel', (e)=>{
    if (!pointerActive || e.pointerId !== pointerId) return;
    e.preventDefault();
    state.phase = 'idle';
    pointerActive = false;
  }, {passive:false});

  // Keyboard (Space or Enter)
  let keyCharging = false;
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      if (!keyCharging) {
        keyCharging = true;
        beginCharge();
      }
    } else if (e.code === 'KeyR') {
      e.preventDefault();
      hardReset();
    }
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      if (keyCharging) {
        keyCharging = false;
        endCharge();
      }
    }
  }, {passive:false});

  // Buttons
  muteBtn.addEventListener('click', ()=>{
    ttsMuted = !ttsMuted;
    localStorage.setItem('hoop_tts_muted', ttsMuted ? '1':'0');
    updateHUD();
    try {
      if (!ttsMuted && 'speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance('Voice enabled');
        u.rate = 1; u.pitch = 1; u.lang = 'en-US';
        window.speechSynthesis.speak(u);
      }
    } catch {}
  });

  resetBtn.addEventListener('click', ()=>{
    hardReset();
  });

  function hardReset(){
    score = 0;
    updateHUD();
    resetBall();
    particles = [];
    netStretch = 0;
  }

  function showHelp(on){
    if (on) helpEl.classList.remove('hidden');
    else helpEl.classList.add('hidden');
  }

  // Physics / update loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    update(dt, now);
    render(now);

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  function update(dt, now){
    // Ball flight
    if (state.phase === 'flying') {
      const prevX = ball.x;
      const prevY = ball.y;

      ball.vy += gravity * dt;
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Backboard bounce
      const boardX = hoop.x + hoop.rimR + hoop.boardGap;
      const withinBoardY = (ball.y > hoop.y - hoop.boardH * 0.5) && (ball.y < hoop.y + hoop.boardH * 0.5);
      if ((prevX + ball.r) <= boardX && (ball.x + ball.r) > boardX && withinBoardY) {
        ball.x = boardX - ball.r - 0.01;
        ball.vx = -Math.abs(ball.vx) * 0.55;
        ball.vy *= 0.92;
      }

      // Simple rim deflection (outer edge)
      // Push out if overlapping rim ring
      const dx = ball.x - hoop.x;
      const dy = ball.y - hoop.y;
      const dist = Math.hypot(dx, dy);
      const rimOuter = hoop.rimR + Math.max(2, ball.r*0.25);
      if (dist < rimOuter && dist > 1) {
        // Only apply small repel when above the rim to reduce weirdness
        if (ball.y < hoop.y + ball.r) {
          const nx = dx / dist, ny = dy / dist;
          const overlap = rimOuter - dist;
          ball.x += nx * overlap * 0.5;
          ball.y += ny * overlap * 0.5;
          const vn = ball.vx * nx + ball.vy * ny;
          ball.vx -= (1.4) * vn * nx;
          ball.vy -= (1.4) * vn * ny;
          ball.vx *= 0.9;
          ball.vy *= 0.9;
        }
      }

      // Scoring: Passing downward through rim center region
      const wasAbove = prevY < hoop.y - 4;
      const nowBelow = ball.y > hoop.y + Math.max(5, ball.r * 0.25);
      const withinX = Math.abs(ball.x - hoop.x) < (hoop.rimR - Math.max(2, ball.r*0.25));
      if (!ball.scored && ball.scorable && wasAbove && nowBelow && withinX && ball.vy > 0) {
        onScore();
      }

      // Ground reset or out of bounds
      const off = (ball.y - ball.r) > (H + 120) || (ball.x + ball.r) < -120 || (ball.x - ball.r) > (W + 120);
      if (off) {
        resetBall();
      }
    }

    // Animate net
    netStretch *= Math.pow(0.02, dt); // decay to 0 quickly but smoothly

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vx *= 0.995;
      p.vy += gravity * 0.6 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }
  }

  function onScore(){
    score += 1;
    if (score > best) {
      best = score;
      localStorage.setItem('hoop_best', String(best));
    }
    updateHUD();
    ball.scored = true;
    ball.scorable = false;
    netStretch = 1;

    // Confetti
    spawnConfetti(hoop.x, hoop.y + hoop.rimR * 0.4);

    // TTS and vibration
    praise();
    if (navigator.vibrate) {
      try { navigator.vibrate(40); } catch {}
    }
  }

  function spawnConfetti(x,y){
    const N = 18;
    for (let i=0;i<N;i++){
      const a = (Math.random()*Math.PI) - Math.PI/2;
      const sp = lerp(base*0.8, base*1.5, Math.random());
      particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp - base*0.2,
        life: lerp(0.5, 1.1, Math.random()),
        size: lerp(3, 6, Math.random()),
        color: randomConfetti()
      });
    }
  }

  function randomConfetti(){
    const palette = ['#ff8d2c','#ffd84f','#2ee59d','#33a7ff','#ff5c9a','#7c78ff'];
    return palette[(Math.random()*palette.length)|0];
  }

  function praise(){
    if (ttsMuted || !('speechSynthesis' in window)) return;
    try {
      window.speechSynthesis.cancel();
      const msgs = ['Great shot!', 'Nice!', 'Swish!', 'Buckets!'];
      const u = new SpeechSynthesisUtterance(msgs[(Math.random()*msgs.length)|0]);
      u.rate = 1;
      u.pitch = 1;
      u.volume = 1;
      u.lang = 'en-US';
      window.speechSynthesis.speak(u);
    } catch {}
  }

  // Aim logic during charging
  function getAim(nowMs){
    const t = (nowMs - state.holdStart) / 1000;
    const power01 = clamp(t / 1.4, 0, 1);
    const minDeg = 40, maxDeg = 72;
    const mid = (minDeg + maxDeg) * 0.5 * Math.PI / 180;
    const amp = (maxDeg - minDeg) * 0.5 * Math.PI / 180;
    const freq = 1.15; // Hz
    const angle = mid + Math.sin(t * Math.PI * 2 * freq) * amp;
    return { angle, power01 };
  }

  // Rendering
  function render(now){
    // Background court gradient
    drawBackground();

    // Court baseline
    drawCourt();

    // Hoop and backboard
    drawHoop();

    // Predicted path and aim when charging
    if (state.phase === 'charging') {
      drawAim(now);
    }

    // Ball
    drawBall();

    // Particles
    drawParticles();

    // UI overlays (handled by DOM)
  }

  function drawBackground(){
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#0f1631');
    g.addColorStop(0.5, '#15214a');
    g.addColorStop(1, '#1b2e63');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // Ambient stars subtle
    const n = 18;
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#ffffff';
    for (let i=0;i<n;i++){
      const x = (i * 137) % W;
      const y = (i * 79) % (H*0.6);
      ctx.beginPath();
      ctx.arc(x, y, 1.2 + ((i*37)%3)*0.3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawCourt(){
    const floorY = H - Math.max(18, floorH);
    const g2 = ctx.createLinearGradient(0, floorY-120, 0, H);
    g2.addColorStop(0, 'rgba(0,0,0,0)');
    g2.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = g2;
    ctx.fillRect(0, 0, W, H);

    const g = ctx.createLinearGradient(0, floorY-12, 0, H);
    g.addColorStop(0, '#263869');
    g.addColorStop(1, '#1b2e63');
    ctx.fillStyle = g;
    ctx.fillRect(0, floorY, W, H - floorY);

    // Subtle center line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, floorY);
    ctx.lineTo(W, floorY);
    ctx.stroke();
  }

  function drawHoop(){
    // Backboard
    const boardX = hoop.x + hoop.rimR + hoop.boardGap;
    const boardTop = hoop.y - hoop.boardH * 0.5;
    const boardBottom = hoop.y + hoop.boardH * 0.5;

    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(boardX, boardTop, hoop.boardW, hoop.boardH);
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 2;
    ctx.strokeRect(boardX, boardTop, hoop.boardW, hoop.boardH);

    // Rim (outer)
    ctx.lineWidth = Math.max(3, Math.floor(base * 0.01));
    ctx.strokeStyle = '#ff8d2c';
    ctx.beginPath();
    ctx.arc(hoop.x, hoop.y, hoop.rimR, 0, Math.PI*2);
    ctx.stroke();

    // Net (stylized)
    const strands = 6;
    const netLen = hoop.rimR * (1.2 + netStretch * 0.75);
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 2;
    for (let i=0;i<strands;i++){
      const a = (i / strands) * Math.PI * 2;
      const sx = hoop.x + Math.cos(a) * hoop.rimR * 0.92;
      const sy = hoop.y + Math.sin(a) * hoop.rimR * 0.92;
      const ex = hoop.x + Math.cos(a + Math.PI/strands) * hoop.rimR * 0.25;
      const ey = hoop.y + netLen;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(hoop.x, hoop.y + netLen*0.5, ex, ey);
      ctx.stroke();
    }
  }

  function drawBall(){
    // Shadow
    const floorY = H - Math.max(18, floorH);
    const dx = clamp((ball.x - hoop.x) / (W*0.5), -1, 1);
    const shadowX = clamp(ball.x + dx * 16, ball.r, W - ball.r);
    const shadowY = floorY;
    const drop = clamp(1 - (floorY - ball.y) / (H * 0.9), 0.15, 1);
    const shR = clamp(ball.r * (1.2 + (1 - drop) * 1.2), ball.r*0.8, ball.r*2.2);
    const shA = clamp(0.22 * drop, 0.04, 0.28);
    const g = ctx.createRadialGradient(shadowX, shadowY, 2, shadowX, shadowY, shR);
    g.addColorStop(0, `rgba(0,0,0,${shA})`);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(shadowX, shadowY, shR, 0, Math.PI*2);
    ctx.fill();

    // Ball body
    const grd = ctx.createRadialGradient(ball.x - ball.r*0.5, ball.y - ball.r*0.6, 2, ball.x, ball.y, ball.r);
    grd.addColorStop(0, '#ffa85b');
    grd.addColorStop(1, '#ff7a1f');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();

    // Ball seams
    ctx.strokeStyle = 'rgba(60,23,7,0.8)';
    ctx.lineWidth = Math.max(1.6, ball.r * 0.12);
    // Vertical-ish seam
    ctx.beginPath();
    ctx.arc(ball.x - ball.r*0.15, ball.y, ball.r*0.95, -1.2, 1.2);
    ctx.stroke();
    // Horizontal seam
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r*0.85, 3.2, 6.1);
    ctx.stroke();

    // Specular highlight
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(ball.x - ball.r*0.35, ball.y - ball.r*0.45, ball.r*0.5, ball.r*0.28, -0.6, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawAim(nowMs){
    const { angle, power01 } = getAim(nowMs);
    const len = lerp(ball.r * 1.8, ball.r * 4.2, power01);
    const ax = ball.x + Math.cos(angle) * len;
    const ay = ball.y - Math.sin(angle) * len;

    // Direction arrow
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(ax, ay);
    ctx.stroke();
    // Arrow head
    const ah = 8;
    const left = angle + Math.PI * 0.85;
    const right = angle - Math.PI * 0.85;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax + Math.cos(left) * ah, ay - Math.sin(left) * ah);
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax + Math.cos(right) * ah, ay - Math.sin(right) * ah);
    ctx.stroke();

    // Power ring
    const r0 = ball.r + 6;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, r0, 0, Math.PI*2);
    ctx.stroke();
    ctx.strokeStyle = '#2ee59d';
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, r0, -Math.PI/2, -Math.PI/2 + power01 * Math.PI*2);
    ctx.stroke();

    // Predicted trajectory
    const speed = lerp(base * 1.25, base * 2.2, power01);
    drawTrajectory(ball.x, ball.y, angle, speed);
  }

  function drawTrajectory(x0, y0, angle, speed){
    // Simulate path
    const vx0 = Math.cos(angle) * speed;
    const vy0 = -Math.sin(angle) * speed;
    const maxT = 2.0;
    const step = 1/45;
    let t = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    for (let i=0;i<90;i++){
      t += step;
      if (t > maxT) break;
      const x = x0 + vx0 * t;
      const y = y0 + vy0 * t + 0.5 * gravity * t * t;
      if (y > H - floorH - 6) break;
      const alpha = clamp(1 - t / maxT, 0, 1) * 0.6;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(x, y, 2.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawParticles(){
    for (const p of particles) {
      ctx.globalAlpha = clamp(p.life, 0, 1);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Helpers
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a, b, t){ return a + (b - a) * t; }

  // Initialize position after first paint
  spawnBall(true);

  // Show help until first interaction
  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState === 'visible' && !state.startedOnce) {
      showHelp(true);
    }
  });
  setTimeout(()=>{
    if (!state.startedOnce) showHelp(true);
  }, 600);

})();
</script>
</body>
</html>