<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Goal Kick: Street League+</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    :root{
      --bg-1:#0a1329;
      --bg-2:#081a2d;
      --ui:#0ea5e9;
      --ui-2:#22c55e;
      --accent:#f59e0b;
      --danger:#ef4444;
      --white:#ffffff;
      --shadow:rgba(0,0,0,.35);
      --shadow-2:rgba(0,0,0,.55);
      --glass:rgba(255,255,255,.12);
      --glass-2:rgba(255,255,255,.08);
      --field:#116530;
      --field-2:#0f5a2b;
      --line:rgba(255,255,255,.45);
    }
    *{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent;touch-action:none;user-select:none}
    html,body{width:100%;height:100%;overflow:hidden;overscroll-behavior:none;background:radial-gradient(1400px 900px at 20% 10%,var(--bg-1),var(--bg-2))}
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial;color:var(--white);padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
    .game{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    canvas{width:100%;height:100%;display:block;cursor:crosshair}

    /* Ambient stadium glow */
    .glow{
      position:fixed;inset:0;z-index:1;pointer-events:none;
      background:
        radial-gradient(800px 300px at 20% 8%, rgba(56,189,248,.16), transparent 60%),
        radial-gradient(800px 300px at 80% 8%, rgba(56,189,248,.16), transparent 60%),
        radial-gradient(1200px 500px at 50% 0%, rgba(255,255,255,.06), transparent 70%);
      mix-blend-mode:screen;
      animation:lights 8s ease-in-out infinite alternate;
    }
    @keyframes lights{
      0%{filter:brightness(1)}
      100%{filter:brightness(1.15)}
    }

    /* HUD */
    .hud{
      position:fixed;z-index:10;top:calc(8px + env(safe-area-inset-top));
      left:calc(10px + env(safe-area-inset-left));right:calc(10px + env(safe-area-inset-right));
      display:grid;grid-template-columns:1fr auto auto auto auto;gap:8px;align-items:center
    }
    .chip{
      display:flex;align-items:center;gap:10px;padding:10px 14px;border-radius:999px;
      background:linear-gradient(135deg,var(--glass),var(--glass-2));
      box-shadow:0 10px 24px var(--shadow);backdrop-filter:blur(10px);
      font-weight:800;font-size:clamp(.8rem,3.5vw,1rem)
    }
    .chip strong{color:var(--ui);letter-spacing:.5px}
    .chip .val{font-variant-numeric:tabular-nums}
    .btn{cursor:pointer;transition:transform .12s ease, box-shadow .12s ease}
    @media(hover:hover){
      .btn:hover{transform:translateY(-2px);box-shadow:0 14px 30px var(--shadow)}
    }
    .btn:active{transform:scale(.96)}
    .chip.badge{background:linear-gradient(135deg,rgba(34,197,94,.25),rgba(14,165,233,.25));color:#e8faff}
    .chip.warn{background:linear-gradient(135deg,rgba(245,158,11,.25),rgba(14,165,233,.2))}
    .chip.action{background:linear-gradient(135deg,#111827,#0b1220);border:1px solid rgba(255,255,255,.08)}
    .icon{width:22px;height:22px;display:inline-grid;place-items:center}
    .icon svg{width:100%;height:100%;display:block}

    /* Instructions & Power */
    .instructions{
      position:fixed;z-index:8;bottom:calc(18px + env(safe-area-inset-bottom));
      left:50%;transform:translateX(-50%);
      background:linear-gradient(135deg,var(--glass),var(--glass-2));
      backdrop-filter:blur(8px);padding:10px 16px;border-radius:999px;
      font-weight:800;font-size:clamp(.85rem,3.6vw,1rem);letter-spacing:.2px;
      color:#d9f0ff;box-shadow:0 8px 20px var(--shadow);animation:hint 2s infinite
    }
    @keyframes hint{0%,100%{transform:translateX(-50%) scale(1)}50%{transform:translateX(-50%) scale(1.05)}}

    .power{
      position:fixed;z-index:9;bottom:calc(70px + env(safe-area-inset-bottom));left:50%;transform:translateX(-50%);
      width:min(64vw,320px);height:18px;background:rgba(255,255,255,.12);border-radius:999px;overflow:hidden;display:none;box-shadow:0 6px 16px var(--shadow)
    }
    .power-bar{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444)}

    /* Overlays */
    .overlay{
      position:fixed;inset:0;display:none;place-items:center;z-index:20;background:linear-gradient(180deg,rgba(2,6,23,.7),rgba(2,6,23,.85))
    }
    .panel{
      width:min(92vw,760px);background:linear-gradient(135deg,rgba(16,24,40,.78),rgba(18,28,48,.9));
      border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:20px;box-shadow:0 20px 60px var(--shadow-2);color:#eaf4ff
    }
    .title{font-weight:900;letter-spacing:.5px;font-size:clamp(1.4rem,6vw,2rem);margin-bottom:10px;color:#a5f3fc}
    .subtitle{opacity:.85;margin-bottom:16px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:12px 0}
    .tag{padding:10px 14px;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);cursor:pointer;font-weight:800}
    .tag.active{background:linear-gradient(135deg,rgba(14,165,233,.3),rgba(34,197,94,.25));border-color:rgba(14,165,233,.4)}
    .cta{width:100%;display:grid;grid-auto-flow:column;gap:10px;margin-top:10px}
    .btn-lg{padding:14px 16px;border-radius:12px;border:1px solid rgba(255,255,255,.1);background:linear-gradient(135deg,#0b1220,#0f172a);color:#d9f0ff;font-weight:900;letter-spacing:.6px;cursor:pointer;text-align:center}
    .btn-lg.primary{background:linear-gradient(135deg,#0ea5e9,#2563eb)}
    .btn-lg.danger{background:linear-gradient(135deg,#ef4444,#b91c1c)}
    .grid{display:grid;gap:10px}

    /* Celebration emoji pop */
    .celebrate{
      position:fixed;z-index:30;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);font-size:clamp(2.5rem,12vw,5rem);pointer-events:none;animation:pop 1s ease-out
    }
    @keyframes pop{0%{transform:translate(-50%,-50%) scale(0) rotate(0)}50%{transform:translate(-50%,-50%) scale(1.4) rotate(8deg)}100%{transform:translate(-50%,-50%) scale(0);opacity:0}}

    /* Wind flag */
    .flag{display:flex;align-items:center;gap:6px}
    .arrow{width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-left:12px solid var(--ui);filter:drop-shadow(0 2px 6px rgba(14,165,233,.5))}
    .flag-txt{font-weight:900;color:#a5f3fc}

    /* Safe for ultra tall/short screens */
    @media (max-height:520px){ .instructions{display:none} }

    /* Tiny screens adjustments */
    @media (max-width:380px){
      .hud{grid-template-columns:1fr auto auto auto}
      #multWrap{display:none}
    }
  </style>
</head>
<body>
  <div class="game">
    <div class="glow" aria-hidden="true"></div>

    <div class="hud">
      <div class="chip badge">
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" stroke="#a5f3fc" stroke-width="1.5">
            <circle cx="12" cy="12" r="9" fill="#ffffff"/>
            <path d="M12 3.5c2.2 2 4.7 2.4 6.5 4.9M12 3.5c-2.5 2.2-5.1 2.4-6.8 5M4.5 12c2.8.8 4.1 2.7 6.6 4.5M19.5 12c-3 .7-4.3 2.5-7 4.3M12 20.5c-1.2-2.6-2.7-3.9-5.1-5.6M12 20.5c1.3-2.7 2.7-3.9 5.4-5.7" stroke="#94a3b8"/>
          </svg>
        </span>
        <strong>GOALS</strong><span class="val" id="goals">0</span>
      </div>
      <div class="chip warn">
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" stroke="#fcd34d" stroke-width="1.8" stroke-linecap="round">
            <circle cx="12" cy="12" r="8.6" stroke="#fde68a"/>
            <path d="M12 6v6l4 2"/>
          </svg>
        </span>
        <strong>TIME</strong><span class="val" id="time">10:00</span>
      </div>
      <div class="chip" id="multWrap">
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" stroke="#34d399" stroke-width="2">
            <path d="M5 7l14 10M19 7L5 17"/>
          </svg>
        </span>
        <strong>MULTI</strong><span class="val" id="mult">x1</span>
      </div>
      <div class="chip">
        <div class="flag"><div id="windArrow" class="arrow"></div><span class="flag-txt" id="windTxt">0</span></div>
      </div>
      <div class="chip action btn" id="pauseBtn" aria-label="Pause">
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="#a5b4fc"><rect x="5" y="4" width="5" height="16" rx="1"/><rect x="14" y="4" width="5" height="16" rx="1"/></svg>
        </span><span>PAUSE</span>
      </div>
    </div>

    <canvas id="game"></canvas>

    <div class="instructions" id="hint">Drag to aim, release to shoot. While ball flies, swipe to bend! Targets give bonus time.</div>
    <div class="power" id="power"><div class="power-bar" id="powerBar"></div></div>

    <!-- Start -->
    <div class="overlay" id="menu">
      <div class="panel grid">
        <div class="title">Goal Kick: Street League+</div>
        <div class="subtitle">Neon-night street pitch. Bend screamers past the keeper, stack combos, and chase a massive score.</div>
        <div class="row">
          <div>Select match length</div>
          <div class="row" id="lengthRow">
            <div class="tag active" data-min="10">10 minutes</div>
            <div class="tag" data-min="12">12 minutes</div>
            <div class="tag" data-min="15">15 minutes</div>
          </div>
        </div>
        <div class="row">
          <div>Difficulty</div>
          <div class="row" id="difficultyRow">
            <div class="tag active" data-diff="0">Rookie</div>
            <div class="tag" data-diff="1">Pro</div>
            <div class="tag" data-diff="2">Legend</div>
          </div>
        </div>
        <div class="cta">
          <div class="btn-lg" id="muteBtn">ðŸ”Š Sound On</div>
          <div class="btn-lg primary" id="startBtn">Kickoff â–¶</div>
        </div>
        <div class="row" style="justify-content:space-between;opacity:.85">
          <div>Best: <span id="bestScore">0</span></div>
          <div>Tip: Curve your swipe to add spin. Aftertouch works mid-flight. Green drone targets = bonus.</div>
        </div>
      </div>
    </div>

    <!-- Pause -->
    <div class="overlay" id="pause">
      <div class="panel grid">
        <div class="title">Paused</div>
        <div class="row" style="gap:12px">
          <div class="btn-lg primary" id="resumeBtn">Resume</div>
          <div class="btn-lg" id="restartBtn">Restart Match</div>
          <div class="btn-lg danger" id="quitBtn">Quit to Menu</div>
        </div>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="over">
      <div class="panel grid">
        <div class="title">Full Time</div>
        <div class="row" style="flex-direction:column;gap:6px">
          <div>Goals: <strong id="finalGoals">0</strong></div>
          <div>Best: <strong id="finalBest">0</strong></div>
        </div>
        <div class="row">
          <div class="btn-lg primary" id="againBtn">Play Again</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    ;(()=>{
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // HUD/UI
      const goalsEl = document.getElementById('goals');
      const timeEl = document.getElementById('time');
      const windTxt = document.getElementById('windTxt');
      const windArrow = document.getElementById('windArrow');
      const hint = document.getElementById('hint');
      const powerBox = document.getElementById('power');
      const powerBar = document.getElementById('powerBar');
      const pauseBtn = document.getElementById('pauseBtn');
      const multEl = document.getElementById('mult');

      // Overlays
      const menu = document.getElementById('menu');
      const pause = document.getElementById('pause');
      const over = document.getElementById('over');

      const lengthRow = document.getElementById('lengthRow');
      const difficultyRow = document.getElementById('difficultyRow');
      const startBtn = document.getElementById('startBtn');
      const muteBtn = document.getElementById('muteBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      const restartBtn = document.getElementById('restartBtn');
      const quitBtn = document.getElementById('quitBtn');
      const againBtn = document.getElementById('againBtn');
      const bestScoreEl = document.getElementById('bestScore');
      const finalGoalsEl = document.getElementById('finalGoals');
      const finalBestEl = document.getElementById('finalBest');

      // Device pixels and logical size
      let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
      let W = 0, H = 0;

      // Game state
      let state = 'menu'; // menu, ready, aiming, kicked, scored, missed, paused, over
      let goals = 0;
      let best = parseInt(localStorage.getItem('gk_best')||'0',10);
      bestScoreEl.textContent = best;
      let timeLeft = 600; // seconds
      let selectedMinutes = 10;
      let difficulty = 0; // 0 rookie, 1 pro, 2 legend
      let lastTime = performance.now();

      // Meta systems
      let multiplier = 1;
      let streak = 0;

      // Background patterns
      let grassPattern = null;

      // Audio
      const audio = {
        ctx:null, enabled:true,
        init(){ if(this.ctx) return; try{ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ this.enabled=false; } },
        beep(freq=600,time=0.06,type='sine',gain=0.04){
          if(!this.enabled||!this.ctx) return;
          const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
          o.type=type; o.frequency.value=freq; g.gain.value=gain;
          o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+time);
        },
        kick(){ this.beep(160,0.08,'triangle',0.08) },
        save(){ this.beep(220,0.15,'square',0.06) },
        goal(){ this.beep(660,0.08,'sine',0.06); setTimeout(()=>this.beep(880,0.12,'sine',0.06),100) },
        post(){ this.beep(300,0.06,'square',0.05) }
      };

      // Entities
      const ball = {
        x:0,y:0,vx:0,vy:0, r:12, spin:0, // -1..1
        trail:[], wobble:0,
        reset(){
          this.x = W*0.5; this.y = H*0.78; this.vx=0; this.vy=0; this.spin=0; this.trail.length=0; this.wobble=0;
        }
      };

      const goal = { x:0,y:0,w:0,h:0, depth:40 };
      let netSag = 0; // animate after goal

      const keeper = {
        x:0,y:0,w:46,h:76, baseSpeed:180, dir:1, dive:0, diveDir:1, gloveAnim:0,
        reset(){
          this.x = goal.x + goal.w*0.5;
          this.y = goal.y + goal.h*0.58;
          this.dir = Math.random()<.5?-1:1;
          this.dive = 0; this.gloveAnim = 0;
        },
        speed(){
          const diffMul = [1,1.25,1.5][difficulty] || 1;
          const timeBoost = 1 + (1 - timeLeft/(selectedMinutes*60)) * 0.6;
          return this.baseSpeed * diffMul * timeBoost;
        }
      };

      // Obstacles (defenders/mannequins)
      const obstacles = [];
      function createObstacles(){
        obstacles.length=0;
        const count = 1 + Math.floor((difficulty) + (1 - timeLeft/(selectedMinutes*60))*2); // up to ~3-4
        for(let i=0;i<count;i++){
          const spread = goal.w*0.6;
          const ox = goal.x + goal.w*0.2 + (i*(spread/Math.max(1,count-1)));
          obstacles.push({
            x:ox, y: H*0.48 + (i%2?18:-18), w:28, h:70,
            vy: (i%2?60:-60), phase:Math.random()*Math.PI*2
          });
        }
      }

      // Targets for bonus points/time (moving drone)
      let target = null;
      let targetTimer = 0;
      function spawnTarget(){
        const y = goal.y + goal.h*0.18 + Math.random()*goal.h*0.2;
        const left = goal.x + goal.w*0.14, right = goal.x + goal.w*0.86;
        const dir = Math.random()<0.5 ? 1 : -1;
        const speed = 80 + Math.random()*60 + difficulty*20;
        const x = dir>0 ? left : right;
        target = {x,y,r:14,ttl:8, vx:dir*speed};
        targetTimer = target.ttl;
      }

      // Wind
      const wind = { x:0, y:0, timer:0 };
      function randomWind(){
        const magBase = [12,22,34][difficulty]||12;
        const mag = (magBase*0.5) + Math.random()*magBase;
        const ang = Math.random()*Math.PI*2;
        wind.x = Math.cos(ang) * mag;
        wind.y = Math.sin(ang) * mag * 0.6;
        wind.timer = 10 + Math.random()*12;
        updateWindHUD();
      }
      function updateWindHUD(){
        const m = Math.hypot(wind.x, wind.y);
        windTxt.textContent = Math.round(m);
        const ang = Math.atan2(wind.y, wind.x);
        const deg = ang * 180 / Math.PI;
        windArrow.style.transform = `rotate(${deg}deg)`;
      }

      // Aiming
      let aimStart = null;
      let aimEnd = null;
      let aimPath = []; // for spin estimate

      // Aftertouch
      let aftertouchActive = false;
      let aftertouchUntil = 0;
      let lastTouch = null;

      // Camera shake
      let shake = 0;

      // Utils
      const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
      const lerp = (a,b,t)=>a+(b-a)*t;
      function formatTime(s){
        const m = Math.floor(s/60);
        const r = Math.floor(s%60);
        return `${m}:${r<10?'0':''}${r}`;
      }

      // Resize
      function resize(){
        const rect = canvas.getBoundingClientRect();
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
        canvas.width = Math.max(1, Math.floor(rect.width*DPR));
        canvas.height = Math.max(1, Math.floor(rect.height*DPR));
        ctx.setTransform(DPR,0,0,DPR,0,0);
        W = rect.width; H = rect.height;

        // Layout field
        goal.x = W*0.14;
        goal.w = W*0.72;
        goal.h = H*0.24;
        goal.y = H*0.11;
        goal.depth = clamp(H*0.06, 26, 64);

        ball.r = Math.max(10, Math.min(14, Math.round(W/40)));
        keeper.w = Math.max(40, Math.min(58, Math.round(W/18)));
        keeper.h = Math.max(62, Math.min(88, Math.round(H/8.5)));

        buildGrassPattern();

        if(state==='menu') {
          // nothing
        }else{
          ball.reset();
          keeper.reset();
          createObstacles();
        }
      }
      window.addEventListener('resize', resize, {passive:true});

      function buildGrassPattern(){
        const p = document.createElement('canvas');
        const g = p.getContext('2d');
        p.width = 128; p.height = 128;
        // base
        const grd = g.createLinearGradient(0,0,128,128);
        grd.addColorStop(0,'#0f6d34'); grd.addColorStop(1,'#0b5d2d');
        g.fillStyle = grd; g.fillRect(0,0,128,128);
        // noise blades
        for(let i=0;i<1800;i++){
          const x = Math.random()*128, y = Math.random()*128;
          const a = Math.random()*Math.PI*2;
          g.strokeStyle = `rgba(255,255,255,${Math.random()*0.04})`;
          g.beginPath();
          g.moveTo(x,y);
          g.lineTo(x+Math.cos(a)*1.2, y+Math.sin(a)*1.2);
          g.stroke();
        }
        grassPattern = ctx.createPattern(p,'repeat');
      }

      // Init new match
      function newMatch(){
        goals = 0;
        multiplier = 1;
        streak = 0;
        timeLeft = selectedMinutes*60;
        netSag = 0;
        updateHUD();
        ball.reset();
        keeper.reset();
        createObstacles();
        randomWind();
        target=null; targetTimer=0;
        state='ready';
        hint.textContent = 'Drag to aim, release to shoot. While ball flies, swipe to bend! Targets give bonus time.';
        hint.style.display='block';
      }

      function updateHUD(){
        goalsEl.textContent = goals;
        timeEl.textContent = formatTime(Math.max(0,timeLeft));
        multEl.textContent = `x${multiplier}`;
      }

      function showOverlay(el, show=true){ el.style.display = show?'grid':'none'; }

      // Physics & Update
      function update(dt){
        if(state==='menu' || state==='paused' || state==='over') return;

        // Countdown
        timeLeft -= dt;
        if(timeLeft<=0){
          timeLeft=0;
          endMatch();
        }
        updateHUD();

        // Wind
        wind.timer -= dt;
        if(wind.timer<=0) randomWind();

        // Target
        if(!target){
          if(Math.random()<dt*0.18) spawnTarget();
        }else{
          targetTimer -= dt;
          target.ttl = targetTimer;
          target.x += target.vx*dt;
          // bounce within goal area
          if(target.x < goal.x+goal.w*0.12 || target.x > goal.x+goal.w*0.88) target.vx*=-1;
          if(targetTimer<=0) target=null;
        }

        // Obstacles move
        const baseTop = H*0.42, range = H*0.08;
        for(const o of obstacles){
          o.phase += dt*1.2;
          o.y = baseTop + Math.sin(o.phase + o.x*0.01)*range;
        }

        // Keeper logic
        if(state!=='kicked'){
          const speed = keeper.speed();
          keeper.x += keeper.dir * speed * dt;
          if(keeper.x - keeper.w*0.5 < goal.x+8){ keeper.x = goal.x+8+keeper.w*0.5; keeper.dir*=-1; }
          if(keeper.x + keeper.w*0.5 > goal.x+goal.w-8){ keeper.x = goal.x+goal.w-8-keeper.w*0.5; keeper.dir*=-1; }
          keeper.dive = Math.max(0, keeper.dive - dt*1.8);
          keeper.gloveAnim = Math.max(0, keeper.gloveAnim - dt);
        }else{
          // Track ball x a bit, and dive if threatened
          const targetX = clamp(ball.x, goal.x+keeper.w*0.5+4, goal.x+goal.w-keeper.w*0.5-4);
          keeper.x = lerp(keeper.x, targetX, dt*2.4);
          // Dive trigger when ball inside goal box vertically and near keeper x
          if(keeper.dive<=0.01 && Math.abs(ball.y - keeper.y) < keeper.h*0.75){
            if(Math.abs(ball.x - keeper.x) < keeper.w*0.9){
              keeper.dive = 1; keeper.diveDir = (ball.x > keeper.x) ? 1 : -1;
              keeper.gloveAnim = 0.8;
            }
          }else{
            keeper.dive = Math.max(0, keeper.dive - dt*1.2);
            keeper.gloveAnim = Math.max(0, keeper.gloveAnim - dt*1.3);
          }
        }

        // Ball movement
        if(state==='kicked'){
          // Drag
          const drag = 0.06 + difficulty*0.02;
          const fr = Math.max(0, 1 - drag*dt);
          ball.vx *= fr;
          ball.vy *= fr;

          // wind
          ball.vx += (wind.x/200) * dt;
          ball.vy += (wind.y/230) * dt;

          // spin curve (Magnus)
          const s = clamp(ball.spin, -1.5, 1.5);
          const magnus = 50 + difficulty*23;
          const ax = -s * ball.vy / magnus;
          const ay =  s * ball.vx / magnus;
          ball.vx += ax;
          ball.vy += ay;

          // knuckle wobble: low spin + high speed
          const spd = Math.hypot(ball.vx,ball.vy);
          if(Math.abs(s) < 0.2 && spd > 9){
            ball.wobble += dt*12;
            ball.vx += Math.sin(ball.wobble*3.1)*0.06;
            ball.vy += Math.cos(ball.wobble*2.6)*0.05;
          }

          // Move
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Trail
          ball.trail.push({x:ball.x,y:ball.y,a:0.6});
          if(ball.trail.length>22) ball.trail.shift();

          // Keeper collision (use expanded gloves area during dive)
          const kx = keeper.x - keeper.w/2, ky = keeper.y - keeper.h/2;
          const kw = keeper.w, kh = keeper.h;
          const extra = keeper.dive>0.2 ? 16 : 0;
          if(circleRect(ball.x,ball.y,ball.r, kx-extra, ky+8, kw+extra*2, kh-16)){
            onSave();
          }

          // Goal in-box
          const inGoalX = ball.x>goal.x && ball.x<goal.x+goal.w;
          const inGoalY = ball.y>goal.y && ball.y<goal.y+goal.h;
          if(inGoalX && inGoalY){
            // Consider cross line behind keeper (simulate depth)
            onGoal();
          }

          // Posts and bar
          if(circleRect(ball.x,ball.y,ball.r, goal.x-6, goal.y, 6, goal.h)){ reflectX(); pingPost(); }
          if(circleRect(ball.x,ball.y,ball.r, goal.x+goal.w, goal.y, 6, goal.h)){ reflectX(); pingPost(); }
          if(circleRect(ball.x,ball.y,ball.r, goal.x-6, goal.y-6, goal.w+12, 6)){ reflectY(); pingPost(); }

          // Obstacles
          for(const o of obstacles){
            if(circleRect(ball.x,ball.y,ball.r, o.x-o.w/2, o.y-o.h/2, o.w, o.h)){
              const penX = (o.w/2 + ball.r) - Math.abs(ball.x - o.x);
              const penY = (o.h/2 + ball.r) - Math.abs(ball.y - o.y);
              if(penX < penY) reflectX(); else reflectY();
              createBurst(ball.x,ball.y,'#94a3b8',18);
              audio.save();
              vibrate(60);
            }
          }

          // Target hit
          if(target && dist(ball.x,ball.y,target.x,target.y) < ball.r + target.r){
            const add = 2 * multiplier;
            goals += add;
            timeLeft = Math.min(selectedMinutes*60, timeLeft + 10);
            updateHUD();
            createBurst(target.x,target.y,'#22c55e',36);
            target = null;
            hintFlash(`Bonus! +${add} goals +10s`);
          }

          // Out of bounds -> reset
          if(ball.y < -50 || ball.y > H+60 || ball.x<-80 || ball.x>W+80){
            onMiss();
          }
        }

        // Net relax animation
        netSag = Math.max(0, netSag - dt*14);
      }

      function reflectX(){ ball.vx = -ball.vx*0.72; ball.x += ball.vx*0.4 }
      function reflectY(){ ball.vy = -ball.vy*0.72; ball.y += ball.vy*0.4 }
      function pingPost(){ createBurst(ball.x,ball.y,'#f59e0b',22); audio.post(); vibrate(40) }

      function onGoal(){
        state = 'scored';
        streak += 1;
        multiplier = clamp(multiplier+1, 1, 5);
        const add = 1 * multiplier;
        goals += add;
        if(multiplier>=4){ timeLeft = Math.min(timeLeft + 2, selectedMinutes*60); hintFlash('Hot streak! +2s'); }
        updateHUD();
        netSag = 28; // net sway
        createBurst(ball.x, ball.y, '#22c55e', 54);
        audio.goal();
        vibrate([90,40,90]);
        pop('ðŸ”¥');
        shake = 6;
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 850);
      }
      function onSave(){
        state='missed';
        streak = 0; multiplier = 1; updateHUD();
        createBurst(ball.x, ball.y, '#ef4444', 40);
        audio.save();
        vibrate(80);
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 700);
      }
      function onMiss(){
        state='missed';
        streak = 0; multiplier = 1; updateHUD();
        audio.beep(160,0.08,'sawtooth',0.05);
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 400);
      }

      // Particles
      const parts=[];
      function createBurst(x,y,color='#ffffff',count=20){
        for(let i=0;i<count;i++){
          const a = Math.random()*Math.PI*2;
          const s = (Math.random()*2+1);
          parts.push({x,y,vx:Math.cos(a)*s*3,vy:Math.sin(a)*s*3,life:1, color});
        }
        while(parts.length>260) parts.shift();
      }
      function updateParticles(dt){
        for(let i=parts.length-1;i>=0;i--){
          const p = parts[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98; p.vy *= 0.98; p.life -= dt*1.8;
          if(p.life<=0) parts.splice(i,1);
        }
      }

      // Draw
      function draw(){
        ctx.clearRect(0,0,W,H);

        // Field + stadium
        drawScene();

        // Goal and net
        drawGoal();

        // Target
        if(target){
          ctx.save();
          const alpha = 0.7*(target.ttl/8) + 0.2*Math.sin(performance.now()/150);
          ctx.globalAlpha = clamp(alpha,0.2,1);
          const grad = ctx.createRadialGradient(target.x,target.y,2,target.x,target.y,target.r+8);
          grad.addColorStop(0,'rgba(56,189,248,.1)');
          grad.addColorStop(1,'rgba(56,189,248,.45)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(target.x,target.y,target.r+6,0,Math.PI*2); ctx.fill();
          ctx.lineWidth = 3; ctx.strokeStyle = '#22c55e';
          ctx.beginPath(); ctx.arc(target.x,target.y,target.r,0,Math.PI*2); ctx.stroke();
          ctx.restore();
        }

        // Obstacles
        for(const o of obstacles) drawDefender(o);

        // Keeper
        drawKeeper();

        // Aiming line + predictive curve
        if(state==='aiming' && aimStart && aimEnd){
          drawAim(aimStart, aimEnd);
          drawPredictPath();
        }

        // Ball trail
        for(let i=0;i<ball.trail.length;i++){
          const t = ball.trail[i];
          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${(i/ball.trail.length)*0.35})`;
          ctx.arc(t.x, t.y, Math.max(1, ball.r*(i/ball.trail.length)*0.8), 0, Math.PI*2);
          ctx.fill();
        }

        // Ball
        drawBall();

        // Particles
        for(const p of parts){
          ctx.beginPath();
          ctx.fillStyle = p.color;
          ctx.globalAlpha = Math.max(0,p.life);
          ctx.arc(p.x,p.y, 3.5*p.life, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        if(shake>0){ shake = Math.max(0, shake-0.3); }
      }

      function drawScene(){
        // Stands background
        const standTop = 0;
        const standHeight = H*0.18;
        const grad = ctx.createLinearGradient(0, standTop, 0, standTop+standHeight);
        grad.addColorStop(0,'#0a1020'); grad.addColorStop(1,'#0a2035');
        ctx.fillStyle = grad;
        ctx.fillRect(0, standTop, W, standHeight);

        // Crowd dots
        for(let i=0;i<3;i++){
          ctx.fillStyle = `rgba(255,255,255,${0.015 + i*0.005})`;
          const rows = 4, cols = 40;
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              const x = (c/cols)*W + ((r%2)*W/cols/2);
              const y = standTop + (r/rows)*standHeight + (i*2);
              ctx.fillRect(x, y, 2, 2);
            }
          }
        }

        // Floodlights
        ctx.fillStyle = 'rgba(180,220,255,.12)';
        for(let i=0;i<5;i++){
          const x = (i+0.5)/5 * W;
          ctx.beginPath();
          ctx.ellipse(x, standTop+8, 80, 16, 0, 0, Math.PI*2);
          ctx.fill();
        }

        // Pitch stripes with pattern
        const stripes = 10;
        for(let i=0;i<stripes;i++){
          ctx.fillStyle = (i%2)?'rgba(9,83,37,0.98)':'rgba(13,104,47,0.98)';
          const sw = W/stripes;
          ctx.fillRect(i*sw, 0, sw+1, H);
        }
        if(grassPattern){
          ctx.save();
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = grassPattern;
          ctx.fillRect(0, 0, W, H);
          ctx.restore();
        }

        // Penalty box & spot arcs (perspective)
        ctx.strokeStyle = 'rgba(255,255,255,.28)';
        ctx.lineWidth = 2;
        roundRect(goal.x-50, goal.y-16, goal.w+100, goal.h+96, 12, false, true);
        ctx.beginPath(); ctx.arc(W*0.5, H*0.78, 50, 0, Math.PI*2); ctx.stroke();
      }

      function drawGoal(){
        // posts & crossbar with subtle shading
        ctx.save();
        // frame
        const shadow = ctx.createLinearGradient(goal.x,goal.y-4,goal.x,goal.y+goal.h+4);
        shadow.addColorStop(0,'#f8fafc'); shadow.addColorStop(1,'#cbd5e1');
        ctx.fillStyle=shadow;
        ctx.fillRect(goal.x-5, goal.y-4, goal.w+10, 6); // crossbar
        ctx.fillRect(goal.x-5, goal.y-2, 6, goal.h+2);  // left
        ctx.fillRect(goal.x+goal.w-1, goal.y-2, 6, goal.h+2); // right
        ctx.restore();

        // net with slight sag animation
        const sag = netSag;
        ctx.save();
        ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.lineWidth=1;
        const cols=14, rows=7;
        for(let i=0;i<=cols;i++){
          const t = i/cols;
          const x = goal.x + goal.w*t;
          ctx.beginPath();
          ctx.moveTo(x, goal.y+2);
          const sY = goal.y + goal.h + Math.sin((t*3 + performance.now()/500))*2 + sag*Math.sin(t*Math.PI);
          ctx.lineTo(x, sY);
          ctx.stroke();
        }
        for(let j=0;j<=rows;j++){
          const t = j/rows;
          const y = goal.y + goal.h*t;
          ctx.beginPath();
          const sx = goal.x - Math.sin((t*2 + performance.now()/600))*2;
          const ex = goal.x+goal.w + Math.sin((t*2 + performance.now()/600))*2;
          ctx.moveTo(sx, y + (sag*0.15)*(1-Math.abs(t-0.5)*2));
          ctx.lineTo(ex, y + (sag*0.15)*(1-Math.abs(t-0.5)*2));
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawKeeper(){
        // shadow
        ctx.fillStyle='rgba(0,0,0,.25)';
        ctx.beginPath();
        ctx.ellipse(keeper.x, keeper.y+keeper.h/2, keeper.w/2, 10, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.save();
        // dive rotation
        const rot = keeper.dive * 0.6 * keeper.diveDir;
        ctx.translate(keeper.x, keeper.y);
        ctx.rotate(rot);

        // body
        const bw = keeper.w, bh = keeper.h;
        const g = ctx.createLinearGradient(-bw/2, -bh/2, bw/2, bh/2);
        g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#2563eb');
        ctx.fillStyle = g;
        roundRect(-bw/2, -bh/2+6, bw, bh-12, 10, true, false);

        // head
        ctx.fillStyle='#e5e7eb';
        ctx.beginPath(); ctx.arc(0, -bh/2+12, 10, 0, Math.PI*2); ctx.fill();

        // gloves (animated when diving)
        const gloveOff = 8 + Math.sin(performance.now()/120)*(keeper.gloveAnim>0?2:0);
        ctx.fillStyle='#f59e0b';
        roundRect(-bw/2-6, -8 - gloveOff, 12, 18, 6, true, false);
        roundRect(bw/2-6, -8 - gloveOff, 12, 18, 6, true, false);

        ctx.restore();
      }

      function drawDefender(o){
        // shadow
        ctx.fillStyle='rgba(0,0,0,.2)';
        ctx.beginPath(); ctx.ellipse(o.x, o.y+o.h/2, o.w/2, 8, 0,0,Math.PI*2); ctx.fill();
        // body pole with chest stripe
        const grad = ctx.createLinearGradient(o.x-o.w/2,o.y-o.h/2,o.x+o.w/2,o.y+o.h/2);
        grad.addColorStop(0,'#64748b'); grad.addColorStop(1,'#334155');
        ctx.fillStyle = grad;
        roundRect(o.x-o.w/2, o.y-o.h/2+8, o.w, o.h-16, 8, true, false);
        // head
        ctx.fillStyle='#e5e7eb';
        ctx.beginPath(); ctx.arc(o.x, o.y-o.h/2+14, 10, 0, Math.PI*2); ctx.fill();
        // stripe
        ctx.fillStyle='#94a3b8';
        ctx.fillRect(o.x-o.w/2+4, o.y-2, o.w-8, 5);
      }

      function drawBall(){
        // shake translate
        if(shake>0){
          const ox = (Math.random()-0.5)*shake;
          const oy = (Math.random()-0.5)*shake;
          ctx.save(); ctx.translate(ox,oy);
        }

        // shadow
        ctx.fillStyle='rgba(0,0,0,.35)';
        ctx.beginPath(); ctx.ellipse(ball.x, ball.y+5, ball.r, ball.r/2, 0,0,Math.PI*2); ctx.fill();

        // ball fill
        const grad = ctx.createRadialGradient(ball.x-ball.r/3, ball.y-ball.r/3, 2, ball.x, ball.y, ball.r+1);
        grad.addColorStop(0,'#ffffff'); grad.addColorStop(.7,'#eaeaea'); grad.addColorStop(1,'#cfcfcf');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();

        // seams/panels
        ctx.strokeStyle='#8b8b8b'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r-1,0,Math.PI*2); ctx.stroke();
        // simple pentagon seams illusion
        ctx.save();
        ctx.translate(ball.x, ball.y);
        const rot = performance.now()/400 * ball.spin;
        ctx.rotate(rot);
        ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1;
        for(let i=0;i<5;i++){
          const a = i*(Math.PI*2/5);
          ctx.beginPath();
          ctx.moveTo(Math.cos(a)*(ball.r-2), Math.sin(a)*(ball.r-2));
          ctx.lineTo(Math.cos(a+0.8)*(ball.r-6), Math.sin(a+0.8)*(ball.r-6));
          ctx.stroke();
        }
        ctx.restore();

        if(shake>0) ctx.restore();
      }

      function drawAim(a,b){
        const dx=b.x-a.x, dy=b.y-a.y;
        const ang = Math.atan2(dy,dx);
        // guideline
        ctx.setLineDash([10,8]); ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.7)';
        ctx.beginPath(); ctx.moveTo(ball.x,ball.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.setLineDash([]);

        // arrow head
        const head = 14;
        ctx.fillStyle='#a5f3fc';
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x - Math.cos(ang-0.4)*head, b.y - Math.sin(ang-0.4)*head);
        ctx.lineTo(b.x - Math.cos(ang+0.4)*head, b.y - Math.sin(ang+0.4)*head);
        ctx.closePath(); ctx.fill();
      }

      function drawPredictPath(){
        // Predict simple path based on current aim + estimated spin
        if(!aimStart||!aimEnd) return;
        const dx = aimEnd.x - aimStart.x;
        const dy = aimEnd.y - aimStart.y;
        let d = Math.hypot(dx,dy);
        if(d<10) return;
        const maxSpeed = 24 + difficulty*4;
        const spd = Math.min(maxSpeed, d/10);
        let vx = (dx/d) * spd;
        let vy = (dy/d) * spd;
        // estimate spin from aimPath curvature
        let spin=0;
        for(let i=2;i<aimPath.length;i++){
          const p0=aimPath[i-2], p1=aimPath[i-1], p2=aimPath[i];
          const v1x=p1.x-p0.x, v1y=p1.y-p0.y;
          const v2x=p2.x-p1.x, v2y=p2.y-p1.y;
          spin += (v1x*v2y - v1y*v2x);
        }
        spin = clamp(spin/60000, -1.2, 1.2);

        const pts=[];
        let px = ball.x, py = ball.y;
        let s = spin;
        const steps = 42;
        for(let i=0;i<steps;i++){
          const dt = 0.03;
          const drag = 0.06 + difficulty*0.02;
          const fr = Math.max(0, 1 - drag*dt);
          vx*=fr; vy*=fr;
          vx += (wind.x/200)*dt; vy += (wind.y/230)*dt;
          const magnus = 50 + difficulty*23;
          vx += (-s * vy / magnus);
          vy += ( s * vx / magnus);
          px+=vx; py+=vy;
          pts.push({x:px,y:py});
          if(py < goal.y-20) break;
        }
        ctx.save();
        ctx.strokeStyle='rgba(56,189,248,.6)';
        ctx.setLineDash([3,6]); ctx.lineWidth=2;
        ctx.beginPath();
        if(pts.length){
          ctx.moveTo(ball.x,ball.y);
          for(const p of pts) ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      // Shapes
      function roundRect(x,y,w,h,r,fill=true,stroke=false){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        if(fill) ctx.fill();
        if(stroke) ctx.stroke();
      }

      // Collision helpers
      function circleRect(cx,cy,cr, rx,ry,rw,rh){
        const nx = clamp(cx, rx, rx+rw);
        const ny = clamp(cy, ry, ry+rh);
        const dx = cx-nx, dy=cy-ny;
        return dx*dx + dy*dy <= cr*cr;
      }
      function dist(x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; return Math.hypot(dx,dy) }

      // Input with Pointer events + aftertouch
      canvas.addEventListener('pointerdown', (e)=>{
        if(state==='menu' || state==='paused' || state==='over') return;
        audio.init();
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left, cy = e.clientY - rect.top;

        if(state==='kicked'){
          // Start aftertouch
          aftertouchActive = true;
          lastTouch = {x:cx,y:cy};
          return;
        }

        canvas.setPointerCapture(e.pointerId);
        state='aiming';
        aimStart = {x:ball.x, y:ball.y};
        aimEnd = {x:cx, y:cy};
        aimPath = [{x:aimEnd.x,y:aimEnd.y, t:performance.now()}];
        hint.style.display='none';
        powerBox.style.display='block';
        updatePowerBar();
      });
      canvas.addEventListener('pointermove', (e)=>{
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left, cy = e.clientY - rect.top;

        if(aftertouchActive && state==='kicked'){
          if(performance.now() < aftertouchUntil){
            if(lastTouch){
              const dx = cx - lastTouch.x;
              const dy = cy - lastTouch.y;
              ball.spin = clamp(ball.spin + dx*0.003 - dy*0.0015, -1.5, 1.5);
              createAftertouchSpark(cx, cy);
            }
            lastTouch = {x:cx,y:cy};
          }
          return;
        }

        if(state!=='aiming') return;
        aimEnd = {x:cx, y:cy};
        aimPath.push({x:aimEnd.x,y:aimEnd.y, t:performance.now()});
        if(aimPath.length>16) aimPath.shift();
        updatePowerBar();
      });
      canvas.addEventListener('pointerup', ()=>{
        if(aftertouchActive){
          aftertouchActive = false; lastTouch=null;
          return;
        }
        if(state!=='aiming') return;
        shoot();
      });
      canvas.addEventListener('pointercancel', ()=>{
        if(state==='aiming') { powerBox.style.display='none'; state='ready'; }
        aftertouchActive=false; lastTouch=null;
      });

      function updatePowerBar(){
        const dx = aimEnd.x - aimStart.x;
        const dy = aimEnd.y - aimStart.y;
        const d = Math.hypot(dx,dy);
        const power = clamp(d / 3.2, 0, 100);
        powerBar.style.width = `${power}%`;
      }

      function shoot(){
        const dx = aimEnd.x - aimStart.x;
        const dy = aimEnd.y - aimStart.y;
        let d = Math.hypot(dx,dy);
        if(d<10){ powerBox.style.display='none'; state='ready'; return; }
        // Power scale by difficulty
        const maxSpeed = 24 + difficulty*4;
        const spd = Math.min(maxSpeed, d/10);
        // dir
        ball.vx = (dx/d) * spd;
        ball.vy = (dy/d) * spd;
        // Spin estimate
        let spin = 0;
        for(let i=2;i<aimPath.length;i++){
          const p0=aimPath[i-2], p1=aimPath[i-1], p2=aimPath[i];
          const v1x=p1.x-p0.x, v1y=p1.y-p0.y;
          const v2x=p2.x-p1.x, v2y=p2.y-p1.y;
          const cross = (v1x*v2y - v1y*v2x);
          spin += cross;
        }
        spin = clamp(spin/60000, -1.2, 1.2);
        ball.spin = spin;

        // Keeper prep
        keeper.dive = 0; keeper.gloveAnim = 0.5;

        state='kicked';
        powerBox.style.display='none';
        createBurst(ball.x,ball.y,'#e2e8f0',14);
        audio.kick();
        vibrate(30);

        // Aftertouch window
        aftertouchUntil = performance.now() + 900; // ms
      }

      function createAftertouchSpark(x,y){
        parts.push({x,y,vx:(Math.random()-.5)*1.5,vy:(Math.random()-.5)*1.5,life:.4,color:'#38bdf8'});
        if(parts.length>280) parts.shift();
      }

      // Pause/Resume/Restart
      pauseBtn.addEventListener('click', ()=>{
        if(state==='menu' || state==='over') return;
        state='paused';
        showOverlay(pause,true);
      });
      resumeBtn.addEventListener('click', ()=>{ state='ready'; showOverlay(pause,false); });
      restartBtn.addEventListener('click', ()=>{ showOverlay(pause,false); newMatch(); state='ready'; });
      quitBtn.addEventListener('click', ()=>{ showOverlay(pause,false); showOverlay(menu,true); state='menu'; });

      // Menu selections
      lengthRow.addEventListener('click', e=>{
        const el = e.target.closest('.tag'); if(!el) return;
        [...lengthRow.children].forEach(c=>c.classList.remove('active'));
        el.classList.add('active');
        selectedMinutes = parseInt(el.dataset.min,10)||10;
      });
      difficultyRow.addEventListener('click', e=>{
        const el = e.target.closest('.tag'); if(!el) return;
        [...difficultyRow.children].forEach(c=>c.classList.remove('active'));
        el.classList.add('active');
        difficulty = parseInt(el.dataset.diff,10)||0;
      });
      muteBtn.addEventListener('click', ()=>{
        audio.enabled = !audio.enabled;
        muteBtn.textContent = audio.enabled ? 'ðŸ”Š Sound On' : 'ðŸ”‡ Sound Off';
        if(audio.enabled) audio.init();
      });
      startBtn.addEventListener('click', ()=>{
        audio.init();
        showOverlay(menu,false);
        newMatch();
      });
      againBtn.addEventListener('click', ()=>{
        showOverlay(over,false);
        showOverlay(menu,true);
        state='menu';
      });

      // End match
      function endMatch(){
        state='over';
        finalGoalsEl.textContent = goals;
        if(goals>best){ best=goals; localStorage.setItem('gk_best', String(best)); }
        finalBestEl.textContent = best;
        setTimeout(()=>showOverlay(over,true), 300);
      }

      // FX
      function pop(char='âš½'){
        const d = document.createElement('div');
        d.className='celebrate'; d.textContent=char;
        document.body.appendChild(d);
        setTimeout(()=>d.remove(), 1000);
      }
      function hintFlash(text){
        hint.textContent = text;
        hint.style.display='block';
        hint.style.animation='none';
        void hint.offsetWidth;
        hint.style.animation='';
        setTimeout(()=>{ hint.style.display='none'; }, 1200);
      }
      function vibrate(pattern){ if(navigator.vibrate) navigator.vibrate(pattern) }

      // Main loop
      function loop(t){
        const dt = Math.min(0.033, (t-lastTime)/1000);
        lastTime = t;
        update(dt);
        updateParticles(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // Initialize
      resize();
      showOverlay(menu,true);
      requestAnimationFrame(loop);

      // Prevent scroll on iOS
      document.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

      // Accessibility keyboard quick controls
      window.addEventListener('keydown', (e)=>{
        if(e.key===' '){
          if(state==='paused'){ resumeBtn.click(); }
          else if(state!=='menu' && state!=='over'){ pauseBtn.click(); }
        }
      });
    })();
  </script>
</body>
</html>