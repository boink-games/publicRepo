<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <meta name="theme-color" content="#0b1426">
  <title>Archery & Target+ (Nature)</title>
  <style>
    :root{
      --bg1:#0a1428; --bg2:#0b1426;
      --card:#0e1b33; --glass:rgba(255,255,255,.08);
      --accent:#7ecbff; --accent2:#ffd166;
      --ok:#29d39a; --warn:#ffcc00; --bad:#ff5964;
      --text:#eaf1ff; --muted:#a9bcec;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0;overflow:hidden;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Arial;overscroll-behavior:none;-webkit-tap-highlight-color:transparent}
    *{box-sizing:border-box}
    canvas{display:block;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}
    .hud{position:fixed;top:calc(env(safe-area-inset-top,0px) + 10px);left:10px;right:10px;display:flex;align-items:center;justify-content:space-between;gap:8px;pointer-events:none;z-index:5}
    .hud-left,.hud-right{display:flex;gap:8px;align-items:center}
    .pill{background:rgba(12,20,40,.55);border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 12px;font-weight:800;font-size:14px;backdrop-filter:blur(6px);box-shadow:var(--shadow);pointer-events:auto;letter-spacing:.2px;white-space:nowrap}
    .pill[data-accent]{border-color:rgba(126,203,255,.35)}
    .pill small{opacity:.8;font-weight:700}
    .btn{appearance:none;border:1px solid var(--glass);background:rgba(255,255,255,.06);color:var(--text);border-radius:999px;padding:8px 14px;font-weight:900;letter-spacing:.5px;cursor:pointer;backdrop-filter:blur(8px);box-shadow:var(--shadow);pointer-events:auto;transition:transform .08s ease, background .15s ease, border-color .15s ease}
    .btn:active{transform:scale(.97)}
    .btn[aria-pressed="true"]{background:rgba(255,255,255,.12);border-color:rgba(255,255,255,.25)}
    .hint{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 14px);left:0;right:0;text-align:center;font-size:13px;opacity:.85;padding:0 12px;z-index:4;text-shadow:0 1px 0 rgba(0,0,0,.35)}
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:24px;z-index:10}
    .overlay.show{display:flex}
    .panel{width:min(680px, 94vw);background:rgba(11,20,48,.75);border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:18px 16px 16px;backdrop-filter:blur(10px);box-shadow:var(--shadow);text-align:center}
    .panel h1{margin:6px 0 4px;font-size:30px;letter-spacing:.5px;color:#dff5ff}
    .panel h2{margin:6px 0 0;font-size:24px}
    .panel p{margin:6px 0 10px;color:var(--muted)}
    .panel .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .panel .row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin:10px 0}
    .kbd{display:inline-block;border:1px solid rgba(255,255,255,.15);border-bottom-width:3px;border-radius:8px;padding:4px 8px;margin:2px;background:rgba(255,255,255,.06);font-weight:800}
    .list{margin:8px auto 0;max-width:62ch;text-align:left;font-size:14px;color:#c9d6ff}
    .list li{margin:6px 0}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;background:rgba(126,203,255,.15);border:1px solid rgba(126,203,255,.35);font-weight:800;color:#d7f9ff}
    @media (min-width:600px){
      .pill{font-size:15px}
      .hint{font-size:14px}
      .panel h1{font-size:34px}
    }
    .blink{animation:blink 1.2s infinite}
    @keyframes blink{0%,50%{opacity:1}60%{opacity:.3}100%{opacity:1}}
    .glow{box-shadow:0 0 0 0 rgba(126,203,255,.45);animation:glow 2.2s ease-out infinite}
    @keyframes glow{from{box-shadow:0 0 0 0 rgba(126,203,255,.45)}to{box-shadow:0 0 0 16px rgba(126,203,255,0)}}
    .hidden{display:none}
  </style>
</head>
<body>
  <div class="hud" aria-hidden="false">
    <div class="hud-left">
      <div class="pill" id="scorePill" data-accent>Score: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill" id="livesPill"><span id="lives">‚ù§‚ù§‚ù§</span></div>
      <div class="pill">Lv <span id="level">1</span></div>
      <div class="pill hidden" id="comboPill">Combo x<span id="comboVal">1</span></div>
      <div class="pill" id="windPill">Wind: <span id="windVal">0</span></div>
    </div>
    <div class="hud-right">
      <button class="btn glow" id="btnPause" aria-label="Pause (P)">Pause</button>
      <button class="btn" id="btnHUDMute" aria-pressed="false" aria-label="Sound">üîà</button>
    </div>
  </div>

  <div class="hint" id="hint">
    Hold or swipe left to draw, release to shoot ‚Ä¢ Up/Down to aim ‚Ä¢ Space/Enter to shoot ‚Ä¢ Wind affects trajectory ‚Ä¢ P to pause
  </div>

  <div class="overlay show" id="ovStart" aria-modal="true" role="dialog">
    <div class="panel">
      <h1>Archery & Target+ Nature</h1>
      <p>More realistic experience: wooden target, wind, bonus birds, power‚Äëups and challenges. Designed for 10‚Äì15 minute sessions.</p>
      <div class="row">
        <span class="badge">Dynamic Wind</span>
        <span class="badge">Realistic Target</span>
        <span class="badge">Bonus Birds</span>
        <span class="badge">Responsive + Touch</span>
        <span class="badge">Combos & Power‚Äëups</span>
      </div>
      <ul class="list">
        <li>Hold/swipe left to draw, release to shoot. Watch the guide trajectory.</li>
        <li>Up/Down arrows for fine aim. Space/Enter to draw/release.</li>
        <li>Wind varies gradually ‚Äî check the indicator and compensate drift.</li>
        <li>Power‚Äëups: Slow motion, Bigger Target, x2 Score, +Life (rare). Hit birds for bonus points.</li>
        <li>Combos: consecutive hits increase multiplier. A miss resets combo.</li>
      </ul>
      <div class="grid">
        <button id="btnStart" class="btn" style="font-size:18px">Play</button>
        <button id="btnMute" class="btn" aria-pressed="false">üîà Sound</button>
      </div>
      <p class="blink" style="margin-top:10px;color:#cfe0ff">Press Play to start</p>
    </div>
  </div>

  <div class="overlay" id="ovPause" aria-modal="true" role="dialog">
    <div class="panel">
      <h2>Pause</h2>
      <p>Take a deep breath. Calm nature. The target waits.</p>
      <div class="grid">
        <button id="btnResume" class="btn">Resume (P)</button>
        <button id="btnRetryFromPause" class="btn">Restart</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="ovGameOver" aria-modal="true" role="dialog">
    <div class="panel">
      <h2>Game Over</h2>
      <p>Score: <strong id="finalScore">0</strong> ‚Ä¢ Best: <strong id="finalBest">0</strong></p>
      <div class="grid">
        <button id="btnRetry" class="btn">Play Again</button>
        <button id="btnMenu" class="btn">Menu</button>
      </div>
    </div>
  </div>

  <canvas id="cv"></canvas>

  <script>
  (() => {
    const cv = document.getElementById('cv');
    const cx = cv.getContext('2d', { alpha: false, desynchronized: true });

    // DOM refs
    const elScore = document.getElementById('score');
    const elBest = document.getElementById('best');
    const elLives = document.getElementById('lives');
    const elLevel = document.getElementById('level');
    const elComboPill = document.getElementById('comboPill');
    const elComboVal = document.getElementById('comboVal');
    const elWindVal = document.getElementById('windVal');
    const pills = {
      score: document.getElementById('scorePill'),
      lives: document.getElementById('livesPill'),
      combo: elComboPill
    };
    const hintEl = document.getElementById('hint');

    // Overlays & buttons
    const ovStart = document.getElementById('ovStart');
    const ovPause = document.getElementById('ovPause');
    const ovOver  = document.getElementById('ovGameOver');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnResume = document.getElementById('btnResume');
    const btnRetryFromPause = document.getElementById('btnRetryFromPause');
    const btnRetry = document.getElementById('btnRetry');
    const btnMenu = document.getElementById('btnMenu');
    const btnMute = document.getElementById('btnMute');
    const btnHUDMute = document.getElementById('btnHUDMute');
    const finalScore = document.getElementById('finalScore');
    const finalBest = document.getElementById('finalBest');

    // Canvas size / DPR
    let DPR = 1, W = 1, H = 1;

    // Storage
    const LS_KEY = 'arc_target_best_v4_nature';
    function getBest(){ const v = +localStorage.getItem(LS_KEY); return Number.isFinite(v) ? v : 0; }
    function setBest(v){ localStorage.setItem(LS_KEY, String(v)); }

    // Audio (tiny synth)
    let AC = null, audioEnabled = false, muted = false;
    function ensureAudio(){
      if (audioEnabled) return;
      try{
        AC = new (window.AudioContext || window.webkitAudioContext)();
        audioEnabled = true;
      }catch(e){}
    }
    function sfx(type, volume=0.18){
      if (!audioEnabled || muted || !AC) return;
      const o = AC.createOscillator();
      const g = AC.createGain();
      const now = AC.currentTime;
      let freq = 440, dur = .08, typeOsc = 'sine';
      switch(type){
        case 'shoot': freq = 520; dur=.06; typeOsc='triangle'; break;
        case 'hit': freq = 760; dur=.10; typeOsc='square'; break;
        case 'bull': freq = 980; dur=.16; typeOsc='sawtooth'; break;
        case 'miss': freq = 180; dur=.18; typeOsc='sine'; break;
        case 'pu': freq = 620; dur=.14; typeOsc='triangle'; break;
        case 'life': freq = 340; dur=.2; typeOsc='square'; break;
        case 'bird': freq = 660; dur=.12; typeOsc='triangle'; break;
        case 'ui': freq = 420; dur=.07; typeOsc='square'; break;
        case 'pause': freq = 300; dur=.08; typeOsc='sine'; break;
      }
      o.type = typeOsc; o.frequency.value = freq;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.connect(g).connect(AC.destination);
      o.start(now);
      o.stop(now + dur + 0.02);
    }

    // Game objects
    const Game = {
      state: 'menu', // menu|playing|paused|over
      time: 0,
      level: 1,
      difficulty: 0,
      score: 0,
      best: getBest(),
      lives: 3,
      maxLives: 5,
      timeScale: 1,
      multiplier: 1,
      combo: 0,
      comboMul: 1,
      effects: { slow: 0, bigTarget: 0, double: 0 }
    };

    // Environment
    const Wind = { value: 0, target: 0, t: 0 };
    const Clouds = [];
    const Leaves = [];

    // Entities
    const bow = { x: 62, y: 0, pull: 0, pulling: false };
    const arrow = { x: 0, y: 0, vx: 0, vy: 0, flying: false, trail: [] };
    const target = { x: 0, y: 0, r: 36, baseR: 36, vy: 1.0, phase: 0, swayAmp: 8 };
    const powerUps = []; // {x,y,r,type,vy,vx,ttl}
    const particles = []; // {x,y,vx,vy,life,clr,s,grav,fade}
    const texts = []; // {x,y,vx,vy,life,text,color}
    const stuckArrows = []; // {rr,phi,ang,life}
    const birds = []; // {x,y,vx,vy,phase,alive,r,ttl}

    // Gesture state
    const gesture = { active:false, startX:0, startY:0, currX:0, currY:0, dx:0, dy:0, isTouch:false };

    // Keyboard
    const keys = { ArrowUp:false, ArrowDown:false, Space:false, Enter:false };

    // Offscreen render of target for realism
    let targetTex = null;
    function makeTargetTexture(radius){
      const size = Math.ceil((radius+18)*2);
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const cxm = size/2, cym = size/2;

      // Wood base
      const woodGrad = ctx.createRadialGradient(cxm-6, cym-6, radius*0.2, cxm, cym, radius+14);
      woodGrad.addColorStop(0, '#6f4c2a');
      woodGrad.addColorStop(1, '#3c2b16');
      ctx.fillStyle = woodGrad;
      ctx.beginPath(); ctx.arc(cxm, cym, radius+14, 0, Math.PI*2); ctx.fill();

      // Wood rings
      ctx.globalAlpha = 0.2;
      ctx.strokeStyle = 'rgba(255,255,255,.1)';
      for(let i=0;i<6;i++){
        ctx.beginPath(); ctx.arc(cxm, cym, radius+14 - i*6, 0, Math.PI*2); ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Paper rings (real archery colors): white, black, blue, red, yellow
      const ringColors = ['#ffffff','#d9d9d9','#333333','#1f1f1f','#2b66c5','#6ea3ff','#cc2b2b','#ff6060','#f1c40f','#ffe07a'];
      const steps = ringColors.length;
      for(let i=0;i<steps;i++){
        const r0 = radius * (1 - i/steps);
        ctx.fillStyle = ringColors[i];
        ctx.beginPath(); ctx.arc(cxm, cym, r0, 0, Math.PI*2); ctx.fill();
      }

      // Pin + shadow
      ctx.shadowColor = 'rgba(0,0,0,.5)';
      ctx.shadowBlur = 6; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 2;
      ctx.fillStyle = '#8e9bb5';
      ctx.beginPath(); ctx.arc(cxm, cym, 4, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;

      return { canvas:c, size, radius };
    }

    function resetArrow(){
      arrow.x = bow.x;
      arrow.y = bow.y;
      arrow.vx = 0;
      arrow.vy = 0;
      arrow.flying = false;
      arrow.trail.length = 0;
    }

    function resetGame(){
      Game.time = 0;
      Game.level = 1;
      Game.difficulty = 0;
      Game.score = 0;
      Game.lives = 4;
      Game.multiplier = 1;
      Game.combo = 0;
      Game.comboMul = 1;
      Game.effects.slow = 0;
      Game.effects.bigTarget = 0;
      Game.effects.double = 0;
      target.baseR = Math.max(34, Math.min(W, H) * 0.05 + 24);
      target.r = target.baseR;
      target.vy = 1.0;
      target.phase = 0;
      target.swayAmp = 8;
      powerUps.length = 0;
      particles.length = 0;
      texts.length = 0;
      stuckArrows.length = 0;
      birds.length = 0;
      bow.pull = 0;
      bow.pulling = false;
      bow.y = H/2;
      target.x = Math.max(180, W - 140);
      target.y = H * 0.5;
      Wind.value = 0; Wind.target = (Math.random()*2-1)*40; Wind.t = 0;
      spawnInitialClouds();
      spawnInitialLeaves();
      resetArrow();
      updateHUD();
      flashPill(pills.lives);
      flashPill(pills.score);
      hideCombo();
    }

    function updateHUD(){
      elScore.textContent = Game.score;
      Game.best = Math.max(Game.best, Game.score);
      elBest.textContent = Game.best;
      const hearts = '‚ù§'.repeat(Game.lives) + '¬∑'.repeat(Math.max(0, Game.maxLives - Game.lives));
      elLives.textContent = hearts;
      elLevel.textContent = Game.level;
      if (Game.comboMul > 1){
        elComboVal.textContent = Game.comboMul.toFixed(1).replace(/\.0$/,'');
        elComboPill.classList.remove('hidden');
      } else hideCombo();
      elWindVal.textContent = (Wind.value>=0?'+':'') + Math.round(Wind.value).toString();
    }
    function hideCombo(){ elComboPill.classList.add('hidden'); }

    function flashPill(el){
      el.style.transition = 'none';
      el.style.transform = 'scale(1.06)';
      el.style.filter = 'brightness(1.2)';
      requestAnimationFrame(()=>{
        el.style.transition = 'transform .15s ease, filter .3s ease';
        el.style.transform = 'scale(1)';
        el.style.filter = 'brightness(1)';
      });
    }

    function resize(){
      const r = cv.getBoundingClientRect();
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      W = Math.max(1, Math.floor(r.width));
      H = Math.max(1, Math.floor(r.height));
      const needW = Math.floor(W * DPR), needH = Math.floor(H * DPR);
      if (cv.width !== needW) cv.width = needW;
      if (cv.height !== needH) cv.height = needH;
      cx.setTransform(DPR,0,0,DPR,0,0);
      bow.y = H/2;
      target.x = Math.max(180, W - 140);
      target.y = H * 0.5;
      targetTex = makeTargetTexture(Math.max(44, Math.min(W,H)*0.085));
      resetArrow();
      spawnInitialClouds();
      spawnInitialLeaves();
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    function getCanvasPos(clientX, clientY){
      const r = cv.getBoundingClientRect();
      return { x: clientX - r.left, y: clientY - r.top };
    }

    function normalizeEvent(e){
      let clientX, clientY, isTouch = false;
      if (e.touches && e.touches.length){
        clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; isTouch = true;
      } else if (e.changedTouches && e.changedTouches.length){
        clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; isTouch = true;
      } else {
        clientX = e.clientX; clientY = e.clientY;
        isTouch = e.pointerType === 'touch' || e.type.startsWith('touch');
      }
      return { clientX, clientY, isTouch, original: e };
    }

    function canShoot(){ return Game.state === 'playing' && !arrow.flying; }

    function startPull(raw){
      ensureAudio();
      if (Game.state !== 'playing') return;
      const n = normalizeEvent(raw);
      if (arrow.flying) { raw.preventDefault(); return; }
      const pos = getCanvasPos(n.clientX, n.clientY);
      gesture.active = true;
      gesture.isTouch = n.isTouch;
      gesture.startX = gesture.currX = pos.x;
      gesture.startY = gesture.currY = pos.y;
      gesture.dx = 0; gesture.dy = 0;

      bow.pulling = true;
      bow.pull = 0;
      bow.y = Math.max(32, Math.min(H - 32, pos.y));
      raw.preventDefault();
      try { if (raw.pointerId != null) cv.setPointerCapture(raw.pointerId); } catch(err){}
    }

    function movePull(raw){
      const n = normalizeEvent(raw);
      if (!bow.pulling) return;
      const pos = getCanvasPos(n.clientX, n.clientY);
      gesture.currX = pos.x; gesture.currY = pos.y;
      gesture.dx = gesture.startX - gesture.currX; // left swipe -> positive
      gesture.dy = gesture.currY - gesture.startY;

      if (gesture.isTouch) {
        bow.pull = Math.max(0, Math.min(120, gesture.dx));
        bow.y += (pos.y - bow.y) * 0.35;
        bow.y = Math.max(32, Math.min(H - 32, bow.y));
      } else {
        bow.pull = Math.min(120, bow.pull + 3.0);
      }
      raw.preventDefault();
    }

    function endPull(raw){
      if (!bow.pulling || arrow.flying) return;
      bow.pulling = false;

      let power, vy;
      if (gesture.isTouch && (gesture.dx > 5 || Math.hypot(gesture.dx, gesture.dy) > 12)) {
        power = Math.min(36, 8 + Math.max(0, gesture.dx) * 0.125);
        vy = Math.max(-20, Math.min(20, gesture.dy * 0.04));
      } else {
        power = Math.min(36, 6 + bow.pull * 0.14);
        vy = (target.y - bow.y) * 0.015;
      }
      shoot(power, vy);
      try { if (raw.pointerId != null) cv.releasePointerCapture(raw.pointerId); } catch(err){}
      raw.preventDefault();
    }

    function shoot(power, vy){
      if (!canShoot()) return;
      arrow.x = bow.x;
      arrow.y = bow.y;
      arrow.vx = power;
      arrow.vy = vy;
      arrow.flying = true;
      bow.pull = 0;
      addMuzzleParticles(arrow.x, arrow.y);
      sfx('shoot', 0.12 + Math.min(0.1, power/400));
      if (navigator.vibrate) navigator.vibrate(10);
    }

    // Pointer + touch
    cv.addEventListener('pointerdown', startPull, { passive: false });
    cv.addEventListener('pointermove', movePull, { passive: false });
    cv.addEventListener('pointerup', endPull, { passive: false });
    cv.addEventListener('pointercancel', endPull, { passive: false });
    cv.addEventListener('touchstart', startPull, { passive: false });
    cv.addEventListener('touchmove', movePull, { passive: false });
    cv.addEventListener('touchend', endPull, { passive: false });
    cv.addEventListener('touchcancel', endPull, { passive: false });

    // Prevent long-press context menu
    window.addEventListener('contextmenu', e => { e.preventDefault(); });

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      ensureAudio();
      if (e.key === 'p' || e.key === 'P'){
        e.preventDefault();
        togglePause();
        return;
      }
      if (Game.state === 'menu' || Game.state === 'paused' || Game.state === 'over') return;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.ArrowUp = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.ArrowDown = true;
      if (e.key === ' ' || e.key === 'Enter'){
        keys.Space = true;
        bow.pulling = true;
        bow.pull = 0;
        e.preventDefault();
      }
    }, { passive:false });

    window.addEventListener('keyup', (e) => {
      if (Game.state !== 'playing') return;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.ArrowUp = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.ArrowDown = false;
      if ((e.key === ' ' || e.key === 'Enter') && bow.pulling){
        keys.Space = false;
        bow.pulling = false;
        const power = Math.min(36, 6 + bow.pull * 0.14);
        const vy = (target.y - bow.y) * 0.015;
        shoot(power, vy);
      }
    });

    // UI buttons
    function toggleMute(){
      ensureAudio();
      muted = !muted;
      const label = muted ? 'üîá' : 'üîà';
      btnMute.setAttribute('aria-pressed', String(muted));
      btnMute.textContent = (muted ? 'üîá Mute' : 'üîà Sound');
      btnHUDMute.setAttribute('aria-pressed', String(muted));
      btnHUDMute.textContent = label;
      sfx('ui');
    }
    btnStart.addEventListener('click', () => { ensureAudio(); sfx('ui'); hideAllOverlays(); startGame(); });
    btnPause.addEventListener('click', () => { togglePause(); });
    btnResume.addEventListener('click', () => { sfx('ui'); resumeGame(); });
    btnRetryFromPause.addEventListener('click', () => { sfx('ui'); hideAllOverlays(); startGame(); });
    btnRetry.addEventListener('click', () => { sfx('ui'); hideAllOverlays(); startGame(); });
    btnMenu.addEventListener('click', () => { sfx('ui'); showOverlay(ovStart); Game.state='menu'; });
    btnMute.addEventListener('click', () => toggleMute());
    btnHUDMute.addEventListener('click', () => toggleMute());

    // Auto-pause on tab hide
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && Game.state === 'playing') pauseGame();
    });

    function hideAllOverlays(){
      [ovStart, ovPause, ovOver].forEach(o => o.classList.remove('show'));
    }
    function showOverlay(ov){
      hideAllOverlays();
      ov.classList.add('show');
    }

    function startGame(){
      resetGame();
      Game.state = 'playing';
      btnPause.textContent = 'Pause';
      btnPause.setAttribute('aria-pressed','false');
      hintEl.style.opacity = '0.9';
      setTimeout(()=>{ hintEl.style.opacity = '0.45'; }, 3500);
    }

    function pauseGame(){
      if (Game.state !== 'playing') return;
      Game.state = 'paused';
      btnPause.textContent = 'Resume';
      btnPause.setAttribute('aria-pressed','true');
      showOverlay(ovPause);
      sfx('pause');
    }
    function resumeGame(){
      if (Game.state !== 'paused') return;
      Game.state = 'playing';
      hideAllOverlays();
      btnPause.textContent = 'Pause';
      btnPause.setAttribute('aria-pressed','false');
      sfx('pause');
    }
    function togglePause(){
      if (Game.state === 'menu') return;
      if (Game.state === 'playing') pauseGame();
      else if (Game.state === 'paused') resumeGame();
    }
    function gameOver(){
      Game.state = 'over';
      setBest(Game.best);
      finalScore.textContent = Game.score;
      finalBest.textContent = Game.best;
      showOverlay(ovOver);
    }

    // Power-ups
    const PU_TYPES = ['slow', 'big', 'double', 'life'];
    function pickPU(){
      const r = Math.random();
      if (r < 0.4) return 'slow';
      if (r < 0.7) return 'big';
      if (r < 0.92) return 'double';
      return 'life';
    }
    function spawnPowerUp(x=undefined, y=undefined){
      const t = pickPU();
      const px = x ?? (W*0.4 + Math.random()*W*0.4);
      const py = y ?? (H*0.2 + Math.random()*H*0.6);
      const r = 14;
      const vx = (Math.random() < .5 ? -1 : 1) * (0.2 + Math.random()*0.4);
      const vy = (Math.random() < .5 ? -1 : 1) * (0.15 + Math.random()*0.3);
      powerUps.push({ x: px, y: py, r, type: t, vx, vy, ttl: 14 + Math.random()*8 });
    }

    function activatePowerUp(type){
      switch(type){
        case 'slow': Game.effects.slow = 7; break;
        case 'big': Game.effects.bigTarget = 7; break;
        case 'double': Game.effects.double = 10; Game.multiplier = 2; break;
        case 'life':
          if (Game.lives < Game.maxLives){
            Game.lives++;
            flashPill(pills.lives);
            updateHUD();
          }
          sfx('life', .22);
          break;
      }
      if (type !== 'life') sfx('pu', .22);
      if (navigator.vibrate) navigator.vibrate([10,40,10]);
      // Visual feedback
      for(let i=0;i<24;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 0.8 + Math.random()*2.2;
        const c = type==='slow' ? '#7ecbff' : type==='big' ? '#ffd166' : type==='double' ? '#a8ff8a' : '#8cf7ff';
        particles.push({x:target.x,y:target.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.6,clr:c,s:2.2,grav:0,fade:1});
      }
    }

    // Birds (bonus targets)
    function spawnBird(){
      const sideLeft = Math.random() < 0.5;
      const y = 60 + Math.random()*(H-120);
      const vx = (1.2 + Math.random()*1.6) * (sideLeft ? 1 : -1);
      const x = sideLeft ? -30 : W + 30;
      birds.push({x, y, vx, vy: (Math.random()*0.4-0.2), phase: Math.random()*Math.PI*2, alive: true, r: 16, ttl: 16});
    }

    function addFeatherBurst(x,y,color='#eae7da'){
      for(let i=0;i<16;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 0.6 + Math.random()*2;
        particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.8,clr:color,s:1.3,grav:0.02,fade:1});
      }
    }

    // Particles
    function addHitParticles(x,y,color,amount=20){
      for(let i=0;i<amount;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 1 + Math.random()*2.8;
        const s  = 1.5 + Math.random()*2;
        particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.7+Math.random()*0.5,clr:color,s,grav:0.08,fade:1});
      }
    }
    function addMuzzleParticles(x,y){
      for(let i=0;i<8;i++){
        const a = (Math.random()-.5)*0.6;
        const sp = 1 + Math.random()*2;
        particles.push({x:x+10,y, vx: Math.cos(a)*sp+2, vy: Math.sin(a)*sp, life:.3+Math.random()*0.2, clr:'#ffd3a6', s:1.2, grav:0.02, fade:1});
      }
    }
    function addFloatingText(x,y,text,color='#dff5ff'){
      texts.push({x,y,vx:0,vy:-0.4,life:1.0,text,color});
    }

    function circleHit(ax,ay,bx,by,br){ const dx=ax-bx, dy=ay-by; return (dx*dx + dy*dy) <= br*br; }

    // Ambient
    function spawnInitialClouds(){
      Clouds.length = 0;
      const n = Math.round(5 + W/300);
      for(let i=0;i<n;i++){
        Clouds.push({
          x: Math.random()*W, y: 30 + Math.random()*(H*0.4),
          w: 80 + Math.random()*160, h: 20 + Math.random()*30,
          s: 0.06 + Math.random()*0.08, a: 0.06 + Math.random()*0.05
        });
      }
    }
    function spawnInitialLeaves(){
      Leaves.length = 0;
      const n = Math.round(14 + W/60);
      for(let i=0;i<n;i++){
        Leaves.push({
          x: Math.random()*W, y: Math.random()*H,
          vx: -0.2 + Math.random()*0.4, vy: 0.1 + Math.random()*0.4,
          a: 0.4 + Math.random()*0.6, r: 1 + Math.random()*1.8, t: Math.random()*Math.PI*2
        });
      }
    }

    // Update loop with dt
    let lastT = performance.now();
    function loop(now){
      const rawDt = Math.min(0.05, (now - lastT) / 1000);
      lastT = now;
      const dt = rawDt * (Game.state === 'playing' ? (Game.timeScale * (Game.effects.slow>0 ? 0.6 : 1)) : 1);
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt){
      // Pull growth on keyboard hold
      if (Game.state === 'playing' && bow.pulling && !gesture.isTouch && !arrow.flying){
        bow.pull = Math.min(120, bow.pull + 160 * dt);
      }

      // Move bow with keys
      if (Game.state === 'playing'){
        const sp = 280 * dt;
        if (keys.ArrowUp) bow.y = Math.max(32, bow.y - sp);
        if (keys.ArrowDown) bow.y = Math.min(H - 32, bow.y + sp);
      }

      // Effects timers
      if (Game.effects.slow > 0){ Game.effects.slow = Math.max(0, Game.effects.slow - dt); }
      if (Game.effects.bigTarget > 0){ Game.effects.bigTarget = Math.max(0, Game.effects.bigTarget - dt); }
      if (Game.effects.double > 0){
        Game.effects.double = Math.max(0, Game.effects.double - dt);
        if (Game.effects.double === 0) Game.multiplier = 1;
      }

      // Difficulty progression tuned for 10‚Äì15 min sessions
      if (Game.state === 'playing'){
        Game.time += dt;
        const difRate = 0.010;
        Game.difficulty += difRate * dt;
        // Level up by score and time
        const levelByScore = Math.floor(Game.score / 20) + 1;
        const levelByTime = Math.floor(Game.time / 60) + 1;
        const newLevel = Math.max(levelByScore, levelByTime);
        if (newLevel !== Game.level){
          Game.level = newLevel;
          flashPill(pills.score);
          if (Math.random() < 0.9) spawnPowerUp();
        }
      }

      // Wind update (slowly drift target)
      Wind.t += dt;
      if (Wind.t > 3 + Math.random()*2){
        Wind.target = (Math.random()*2-1) * (20 + Math.min(60, Game.level*4)); // px/sec
        Wind.t = 0;
      }
      Wind.value += (Wind.target - Wind.value) * 0.02;
      updateHUD();

      // Target motion
      const baseVy = (1.0 + Game.difficulty*0.55) * (H/760);
      if (target.vy === 0) target.vy = baseVy;
      const swayAmp = 10 + Game.level * 1.2;
      target.phase += dt * (0.8 + Game.difficulty);
      const sway = Math.sin(target.phase) * swayAmp;
      target.y += (Game.state === 'playing' ? 1 : 0.4) * (target.vy + Math.sin(target.phase*0.6) * 0.2);
      if (target.y < 80 || target.y > H - 80) target.vy *= -1;
      const txBase = Math.max(180, W - 140);
      target.x = txBase + sway * 0.9;

      // Target size adjusts with difficulty + effect
      target.baseR = Math.max(34, 66 - Game.level * 1.2);
      const desiredR = target.baseR + (Game.effects.bigTarget>0 ? 12 : 0);
      target.r += (desiredR - target.r) * 0.15;

      // Arrow physics
      const gravity = 18 * dt * (1 + Game.difficulty*0.08) * (Game.effects.slow>0 ? 0.6 : 1);
      if (arrow.flying){
        // trail
        arrow.trail.push({x:arrow.x, y:arrow.y, life:0.4});
        if (arrow.trail.length > 26) arrow.trail.shift();

        // Apply wind drift (px/sec -> integrate)
        arrow.x += arrow.vx;
        arrow.x += Wind.value * dt * 0.8;
        arrow.y += arrow.vy;
        arrow.vy += gravity * 0.06;

        // Power-up collision
        for(let i=powerUps.length-1;i>=0;i--){
          const pu = powerUps[i];
          if (circleHit(arrow.x,arrow.y,pu.x,pu.y,pu.r+6)){
            activatePowerUp(pu.type);
            powerUps.splice(i,1);
          }
        }

        // Collision with target
        const dx = arrow.x - target.x, dy = arrow.y - target.y;
        const d = Math.hypot(dx, dy);
        if (d < target.r){
          const ring = d / target.r; // 0 center .. 1 edge
          let pts = ring < 0.2 ? 6 : (ring < 0.4 ? 4 : (ring < 0.7 ? 2 : 1));
          Game.combo++;
          Game.comboMul = Math.min(4, 1 + Math.floor(Game.combo/5));
          pts = Math.floor(pts * Game.multiplier * Game.comboMul);
          Game.score += pts;
          Game.best = Math.max(Game.best, Game.score);
          updateHUD();
          // visual/audio feedback
          const col = ring < 0.33 ? '#ffcc00' : '#7ecbff';
          addHitParticles(arrow.x, arrow.y, col, 28);
          addFloatingText(arrow.x+6, arrow.y-10, '+'+pts, Game.multiplier>1?'#a8ff8a':(Game.comboMul>1?'#22ff88':'#dff5ff'));
          // stick arrow to target
          const phi = Math.atan2(dy, dx);
          const rr = d;
          const ang = Math.atan2(arrow.vy, arrow.vx);
          stuckArrows.push({ rr, phi, ang, life: 2.2 });
          if (ring < 0.2){
            sfx('bull', .18);
            if (Math.random() < 0.6) spawnPowerUp(arrow.x+20, arrow.y);
          } else sfx('hit', .16);
          if (navigator.vibrate) navigator.vibrate(ring < 0.33 ? [12, 20, 12] : 12);
          // Difficulty nudges
          Game.difficulty += 0.02;
          target.vy = (target.y < H*0.5 ? Math.abs(target.vy) : -Math.abs(target.vy));
          cameraShake(6, 200);
          resetArrow();
          flashPill(pills.score);
          flashPill(pills.combo);
        }

        // Birds collision
        for(let i=birds.length-1;i>=0;i--){
          const b = birds[i];
          if (!b.alive) continue;
          if (circleHit(arrow.x,arrow.y,b.x,b.y,b.r)){
            b.alive = false; b.ttl = 0.6;
            const pts = Math.floor(3 * Game.multiplier * (1 + (Game.comboMul-1)*0.4));
            Game.score += pts;
            updateHUD();
            addFeatherBurst(b.x,b.y);
            addFloatingText(b.x+6, b.y-10, '+'+pts, '#ffd166');
            sfx('bird', .18);
            if (Math.random() < 0.4) spawnPowerUp(b.x, b.y);
          }
        }

        // Miss: arrow out of screen
        if (arrow.x > W + 40 || arrow.y < -40 || arrow.y > H + 40){
          resetArrow();
          if (Game.state === 'playing'){
            Game.lives--;
            Game.combo = 0; Game.comboMul = 1; hideCombo();
            sfx('miss', .12);
            addHitParticles(target.x-40, target.y, '#ff7b88', 14);
            addFloatingText(bow.x+20, bow.y-10, 'Miss', '#ff7b88');
            updateHUD();
            if (navigator.vibrate) navigator.vibrate([15,60,15]);
            if (Game.lives <= 0){
              setBest(Game.best);
              gameOver();
              return;
            }
          }
        }
      } else {
        // Auto-follow to keep reachable when idle
        if (!bow.pulling && Game.state === 'playing'){
          bow.y += (target.y - bow.y) * 0.05;
        }
      }

      // Power-ups update
      for (let i=powerUps.length-1;i>=0;i--){
        const pu = powerUps[i];
        pu.x += pu.vx * (Game.effects.slow>0 ? 0.7 : 1);
        pu.y += pu.vy * (Game.effects.slow>0 ? 0.7 : 1);
        pu.ttl -= dt;
        if (pu.x < W*0.25 || pu.x > W-40) pu.vx *= -1;
        if (pu.y < 60 || pu.y > H-60) pu.vy *= -1;
        if (pu.ttl <= 0) powerUps.splice(i,1);
      }

      // Birds update
      if (Game.state === 'playing' && Math.random() < 0.003 * (1 + Game.level*0.06)){
        spawnBird();
      }
      for (let i=birds.length-1;i>=0;i--){
        const b = birds[i];
        b.phase += dt*10;
        b.x += b.vx + Wind.value * 0.005; // slight wind influence
        b.y += b.vy + Math.sin(b.phase)*0.06;
        b.ttl -= dt;
        if (!b.alive && b.ttl <= 0) { birds.splice(i,1); continue; }
        if (b.x < -60 || b.x > W+60) birds.splice(i,1);
      }

      // Particles update
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.x += p.vx + Wind.value * 0.002;
        p.y += p.vy;
        p.vy += p.grav * (Game.effects.slow>0 ? 0.7 : 1);
        p.life -= dt;
        p.fade = Math.max(0, p.life);
        if (p.life <= 0) particles.splice(i,1);
      }

      // Floating texts update
      for (let i=texts.length-1;i>=0;i--){
        const t = texts[i];
        t.x += t.vx;
        t.y += t.vy;
        t.life -= dt;
        if (t.life <= 0) texts.splice(i,1);
      }

      // Stuck arrows update
      for (let i=stuckArrows.length-1;i>=0;i--){
        const s = stuckArrows[i];
        s.life -= dt;
        if (s.life <= 0) stuckArrows.splice(i,1);
      }

      // Ambient clouds
      for (const c of Clouds){
        c.x += c.s + Wind.value*0.002;
        if (c.x - c.w*0.6 > W) c.x = -c.w*0.6;
      }
      // Ambient leaves
      for (const l of Leaves){
        l.t += dt;
        l.x += l.vx + Wind.value*0.01;
        l.y += l.vy + Math.sin(l.t*2)*0.05;
        if (l.x < -10) l.x = W+10;
        if (l.x > W+10) l.x = -10;
        if (l.y > H+10){ l.y = -10; l.x = Math.random()*W; }
      }

      // Occasional random pu while playing
      if (Game.state === 'playing' && Math.random() < 0.0022 * (1 + Game.level*0.08)){
        spawnPowerUp();
      }
    }

    // Aim guide (predictive path)
    function drawAimGuide(){
      if (!bow.pulling || arrow.flying || Game.state!=='playing') return;
      let power, vy;
      if (gesture.isTouch){
        power = Math.min(36, 8 + Math.max(0, gesture.dx) * 0.125);
        vy = Math.max(-20, Math.min(20, gesture.dy * 0.04));
      } else {
        power = Math.min(36, 6 + bow.pull * 0.14);
        vy = (target.y - bow.y) * 0.015;
      }
      let px = bow.x, py = bow.y, vx = power, vyy = vy;
      const g = (18 * 0.016) * (Game.effects.slow>0 ? 0.6 : 1) * 0.06;
      cx.save();
      cx.setLineDash([5,6]);
      cx.lineWidth = 2;
      cx.strokeStyle = 'rgba(126,203,255,.85)';
      cx.beginPath();
      cx.moveTo(px, py);
      for (let i=0;i<38;i++){
        px += vx;
        px += Wind.value * 0.016 * 0.8; // preview drift
        py += vyy;
        vyy += g;
        if (i%2===0) cx.lineTo(px, py);
        if (px > W || py < 0 || py > H) break;
      }
      cx.stroke();
      cx.restore();
    }

    // Camera shake
    let shakeMag = 0, shakeEnd = 0;
    function cameraShake(mag, durationMs){
      shakeMag = mag;
      shakeEnd = performance.now() + durationMs;
    }

    function drawBackground(){
      // Sky gradient
      const sky = cx.createLinearGradient(0,0,0,H);
      sky.addColorStop(0,'#0a1836');
      sky.addColorStop(1,'#0a1428');
      cx.fillStyle = sky;
      cx.fillRect(0,0,W,H);

      // Sun glow
      cx.save();
      cx.globalAlpha = 0.08;
      cx.fillStyle = '#ffd166';
      cx.beginPath(); cx.arc(W*0.15, H*0.25, Math.min(W,H)*0.18, 0, Math.PI*2); cx.fill();
      cx.restore();

      // Distant mountains
      cx.fillStyle = '#0b1a2f';
      cx.beginPath();
      cx.moveTo(0, H*0.65);
      for(let x=0; x<=W; x+=40){
        const y = H*0.65 + Math.sin(x*0.01)*10 - 20;
        cx.lineTo(x, y);
      }
      cx.lineTo(W,H); cx.lineTo(0,H); cx.closePath(); cx.fill();

      // Near hills
      cx.fillStyle = '#0d203a';
      cx.beginPath();
      cx.moveTo(0, H*0.78);
      for(let x=0; x<=W; x+=30){
        const y = H*0.78 + Math.sin(x*0.02+1)*8 - 10;
        cx.lineTo(x, y);
      }
      cx.lineTo(W,H); cx.lineTo(0,H); cx.closePath(); cx.fill();

      // Ground
      const ground = cx.createLinearGradient(0,H*0.85,0,H);
      ground.addColorStop(0,'#0c1b32');
      ground.addColorStop(1,'#071020');
      cx.fillStyle = ground;
      cx.fillRect(0, H*0.85, W, H*0.15);

      // Clouds
      for(const c of Clouds){
        cx.save();
        cx.globalAlpha = c.a;
        cx.fillStyle = '#dde7ff';
        drawCloud(c.x, c.y, c.w, c.h);
        cx.restore();
      }

      // Leaves drifting
      for(const l of Leaves){
        cx.save();
        cx.globalAlpha = 0.6;
        cx.translate(l.x, l.y);
        cx.rotate(Math.sin(l.t*3)*0.6);
        cx.fillStyle = '#86a87f';
        cx.beginPath(); cx.ellipse(0,0,l.r*2,l.r,0,0,Math.PI*2); cx.fill();
        cx.restore();
      }

      // Wooden post shadow behind target area
      cx.save();
      cx.globalAlpha = 0.12;
      cx.fillStyle = '#000';
      cx.beginPath(); cx.roundRect(Math.max(160, W-160), 60, 20, H-120, 8); cx.fill();
      cx.restore();
    }

    function drawCloud(x,y,w,h){
      cx.beginPath();
      cx.ellipse(x, y, w*0.35, h, 0, 0, Math.PI*2);
      cx.ellipse(x-w*0.2, y+2, w*0.25, h*0.9, 0, 0, Math.PI*2);
      cx.ellipse(x+w*0.22, y+1, w*0.3, h*0.95, 0, 0, Math.PI*2);
      cx.fill();
    }

    function drawTarget(){
      const tex = targetTex || makeTargetTexture(target.r+18);
      const sx = target.x - tex.size/2;
      const sy = target.y - tex.size/2;
      // Effects outline
      if (Game.effects.double>0){
        cx.save(); cx.shadowColor = '#9bff96'; cx.shadowBlur = 16;
        cx.beginPath(); cx.arc(target.x, target.y, target.r+6, 0, Math.PI*2);
        cx.strokeStyle='rgba(168,255,154,.8)'; cx.lineWidth=2; cx.stroke(); cx.restore();
      }
      if (Game.effects.slow>0){
        cx.save(); cx.strokeStyle='rgba(126,203,255,.7)'; cx.setLineDash([6,4]);
        cx.beginPath(); cx.arc(target.x, target.y, target.r+12, 0, Math.PI*2); cx.stroke(); cx.restore();
      }
      cx.drawImage(tex.canvas, sx, sy);
    }

    function drawBow(){
      // Wooden recurve bow
      cx.save();
      cx.translate(bow.x, bow.y);
      // Shadow
      cx.save();
      cx.globalAlpha = 0.25;
      cx.fillStyle = '#000';
      cx.beginPath(); cx.ellipse(10, 14, 26, 6, 0.2, 0, Math.PI*2); cx.fill();
      cx.restore();

      const wood = cx.createLinearGradient(-32,-34, -32,34);
      wood.addColorStop(0, '#8a5a30');
      wood.addColorStop(1, '#5b3a1e');
      cx.strokeStyle = wood;
      cx.lineWidth = 7;
      cx.beginPath(); cx.arc(0, 0, 36, -Math.PI/2, Math.PI/2); cx.stroke();

      // Grip
      cx.fillStyle = '#2c3e50';
      cx.beginPath(); cx.roundRect(-6, -10, 12, 20, 4); cx.fill();

      // String
      cx.strokeStyle='#f3f3f3'; cx.lineWidth=2;
      cx.beginPath();
      cx.moveTo(0, -36);
      cx.lineTo((bow.pull*0.85), 0);
      cx.lineTo(0, 36);
      cx.stroke();

      cx.restore();
    }

    function drawArrow(x, y, ang, alpha=1){
      cx.save();
      cx.globalAlpha = alpha;
      cx.translate(x, y);
      cx.rotate(ang);

      // Drop shadow
      cx.save(); cx.globalAlpha = 0.25; cx.fillStyle = '#000';
      cx.beginPath(); cx.rect(-12, 3, 28, 2); cx.fill(); cx.restore();

      // Shaft (wood gradient)
      const shaft = cx.createLinearGradient(-14,0, 14,0);
      shaft.addColorStop(0, '#6d4b2f');
      shaft.addColorStop(0.5, '#b08653');
      shaft.addColorStop(1, '#6d4b2f');
      cx.fillStyle = shaft; cx.fillRect(-14,-1.5, 28, 3);

      // Fletching (feathers)
      cx.fillStyle = '#9bc2ff';
      cx.beginPath();
      cx.moveTo(-14,0);
      cx.lineTo(-20,4);
      cx.lineTo(-14,2);
      cx.lineTo(-20,-4);
      cx.closePath(); cx.fill();

      // Head (metal)
      const head = cx.createLinearGradient(12,0, 20,0);
      head.addColorStop(0,'#c9d3df'); head.addColorStop(1,'#8193a5');
      cx.fillStyle = head;
      cx.beginPath(); cx.moveTo(14,0); cx.lineTo(20,3); cx.lineTo(20,-3); cx.closePath(); cx.fill();

      cx.restore();
    }

    function drawPowerUps(){
      for(const pu of powerUps){
        cx.save();
        cx.translate(pu.x, pu.y);
        // Glow
        const glow = cx.createRadialGradient(0,0,2,0,0,16);
        let c1 = '#7ecbff';
        if (pu.type==='big') c1 = '#ffd166';
        else if (pu.type==='double') c1 = '#8cff9a';
        else if (pu.type==='life') c1 = '#6dd7ff';
        glow.addColorStop(0, c1 + 'cc');
        glow.addColorStop(1, c1 + '00');
        cx.fillStyle = glow;
        cx.beginPath(); cx.arc(0,0,16,0,Math.PI*2); cx.fill();
        // Token (more detailed)
        cx.fillStyle = '#0e172a';
        cx.beginPath(); cx.arc(0,0,14,0,Math.PI*2); cx.fill();
        cx.strokeStyle = c1; cx.lineWidth = 2; cx.beginPath(); cx.arc(0,0,14,0,Math.PI*2); cx.stroke();
        // emblem
        cx.fillStyle = c1;
        if (pu.type==='slow'){ // hourglass-ish
          cx.beginPath(); cx.moveTo(-6,-6); cx.lineTo(6,-6); cx.lineTo(-6,6); cx.lineTo(6,6); cx.strokeStyle=c1; cx.lineWidth=2; cx.stroke();
        } else if (pu.type==='big'){
          cx.beginPath(); cx.arc(0,0,6,0,Math.PI*2); cx.strokeStyle=c1; cx.lineWidth=3; cx.stroke();
        } else if (pu.type==='double'){
          cx.font = '900 13px system-ui,Segoe UI,Roboto'; cx.textAlign='center'; cx.textBaseline='middle'; cx.fillText('x2', 0, 1);
        } else { // life
          cx.fillStyle = c1;
          cx.beginPath();
          cx.moveTo(0,6);
          cx.bezierCurveTo(-10,0,-4,-8,0,-3);
          cx.bezierCurveTo(4,-8,10,0,0,6);
          cx.fill();
        }
        cx.restore();
      }
    }

    function drawBird(b){
      cx.save();
      cx.translate(b.x, b.y);
      cx.scale(b.vx>0?1:-1, 1);
      cx.fillStyle = b.alive ? '#1f2a3e' : 'rgba(31,42,62,.4)';
      // body
      cx.beginPath();
      cx.ellipse(0,0,10,6,0,0,Math.PI*2); cx.fill();
      // wing flapping
      const flap = Math.sin(b.phase)*0.7;
      cx.save();
      cx.rotate(-0.4+flap*0.3);
      cx.beginPath(); cx.ellipse(-2,-2,10,4,0,0,Math.PI*2); cx.fill();
      cx.restore();
      cx.restore();
    }

    function draw(){
      // Camera shake transform
      cx.save();
      if (performance.now() < shakeEnd){
        const m = shakeMag * (shakeEnd - performance.now())/200;
        cx.translate((Math.random()-0.5)*m, (Math.random()-0.5)*m);
      }

      drawBackground();

      drawPowerUps();

      drawTarget();

      // Stuck arrows on target
      for (const s of stuckArrows){
        const x = target.x + Math.cos(s.phi)*s.rr;
        const y = target.y + Math.sin(s.phi)*s.rr;
        drawArrow(x, y, s.ang, Math.max(0, s.life/2.2));
      }

      // Bow
      drawBow();

      // Aim guide
      drawAimGuide();

      // Arrow trail
      for (const t of arrow.trail){
        cx.globalAlpha = Math.max(0, t.life*1.6);
        cx.fillStyle = '#ffd3a6';
        cx.fillRect(t.x-6, t.y-1, 12, 2);
        t.life -= 0.03;
      }
      cx.globalAlpha = 1;

      // Arrow
      const ang = arrow.flying ? Math.atan2(arrow.vy, arrow.vx + 0.0001) : (gesture.isTouch && bow.pulling ? Math.atan2(gesture.dy*0.8, Math.max(1, 12 + bow.pull)) : 0);
      drawArrow(arrow.x, arrow.y, ang, 1);

      // Birds
      for (const b of birds) drawBird(b);

      // Particles
      for (const p of particles){
        cx.globalAlpha = Math.max(0, p.fade);
        cx.fillStyle = p.clr;
        cx.beginPath(); cx.arc(p.x, p.y, p.s, 0, Math.PI*2); cx.fill();
      }
      cx.globalAlpha = 1;

      // Floating texts
      for (const t of texts){
        cx.globalAlpha = Math.max(0, t.life);
        cx.fillStyle = t.color;
        cx.font = '900 14px system-ui,Segoe UI,Roboto';
        cx.textAlign = 'left'; cx.textBaseline = 'middle';
        cx.fillText(t.text, t.x, t.y);
      }
      cx.globalAlpha = 1;

      // UI effect timers bars
      const bars = [];
      if (Game.effects.slow>0) bars.push({name:'Slow', v:Game.effects.slow/7, col:'#7ecbff'});
      if (Game.effects.bigTarget>0) bars.push({name:'Big', v:Game.effects.bigTarget/7, col:'#ffd166'});
      if (Game.effects.double>0) bars.push({name:'x2', v:Game.effects.double/10, col:'#8cff9a'});
      if (bars.length){
        const bx = 12, by = Math.max(54, (parseFloat(getComputedStyle(document.querySelector('.hud')).top) || 10) + 48);
        bars.forEach((b, i)=>{
          const w = 86, h = 6, gap = 10;
          cx.fillStyle='rgba(255,255,255,.15)';
          cx.fillRect(bx, by + i*(h+gap), w, h);
          cx.fillStyle = b.col;
          cx.fillRect(bx, by + i*(h+gap), Math.max(0, b.v*w), h);
          cx.fillStyle='#dfe9ff';
          cx.font='bold 10px system-ui'; cx.textAlign='left'; cx.textBaseline='bottom';
          cx.fillText(b.name, bx, by + i*(h+gap) - 2);
        });
      }

      // Wind indicator flag
      const wx = 10, wy = H - 60;
      cx.save();
      cx.translate(wx, wy);
      cx.strokeStyle = '#8aa3c8'; cx.lineWidth = 2;
      cx.beginPath(); cx.moveTo(0,0); cx.lineTo(0,-26); cx.stroke();
      const dir = Math.sign(Wind.value)||1;
      const len = Math.min(26, Math.abs(Wind.value)*0.6 + 8);
      cx.fillStyle = '#ffd166';
      cx.beginPath();
      cx.moveTo(0,-26); cx.lineTo(dir*len,-20); cx.lineTo(0,-14); cx.closePath(); cx.fill();
      cx.restore();

      cx.restore(); // end shake transform
    }

    // Start in menu
    elBest.textContent = Game.best;
    showOverlay(ovStart);

    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
