<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Neon Street Racer+</title>
<style>
:root{
  --primary:#00e5ff;
  --primary-2:#00baff;
  --secondary:#0a67ff;
  --accent:#ff8c00;
  --danger:#ff3b3b;
  --ok:#23d18b;
  --text:#e6f4ff;
  --bg-1:#050914;
  --bg-2:#0a0f1f;
  --road:#0b1220;
  --guard:#0e1a32;
  --stripe:#00f7ff;
  --glass:#8fd3ff;
  --shadow:rgba(0,0,0,.55);
  --glow:0 0 18px rgba(0,229,255,.35), 0 0 45px rgba(0,106,255,.2);
}

*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:manipulation;margin:0;padding:0}
html,body{height:100%;width:100%;overflow:hidden;overscroll-behavior:none;background:radial-gradient(1200px 800px at 50% -10%, var(--bg-2), var(--bg-1));font-family:Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;color:var(--text)}
body{display:flex;align-items:center;justify-content:center;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);-webkit-user-select:none;user-select:none}

.header{
  position:fixed;top:10px;left:0;right:0;display:flex;justify-content:center;pointer-events:none;z-index:5
}
.header h1{
  font-size:clamp(1.2rem,3.8vw,2rem);
  letter-spacing:.04em;
  font-weight:900;
  background:linear-gradient(90deg,var(--primary),var(--secondary));
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;
  text-shadow:0 8px 30px rgba(0,229,255,.18)
}

.game-container{
  position:relative;width:min(480px,94vw);aspect-ratio:4/7;border-radius:18px;box-shadow:0 30px 80px var(--shadow);
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  backdrop-filter:blur(10px);overflow:hidden
}
/* touch visual steer zones */
.game-container::before,
.game-container::after{
  content:"";position:absolute;inset:0;opacity:0;transition:opacity .15s ease;pointer-events:none
}
.game-container::before{
  background:linear-gradient(90deg, rgba(0,229,255,.22), transparent 55%);
}
.game-container::after{
  background:linear-gradient(-90deg, rgba(0,229,255,.22), transparent 55%);
}
.game-container.hold-left::before{opacity:.16}
.game-container.hold-right::after{opacity:.16}

canvas{display:block;width:100%;height:100%;border-radius:18px;filter:drop-shadow(0 10px 25px rgba(0,0,0,.35));touch-action:none}

.hud{
  position:absolute;inset:0;pointer-events:none;z-index:3
}
.hud .top{
  position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:nowrap
}
.stack-left,.stack-right{display:flex;gap:.5rem;align-items:center;flex-wrap:nowrap}
.badge{
  pointer-events:auto;
  display:inline-flex;align-items:center;gap:.45rem;padding:.45rem .65rem;border-radius:12px;
  background:linear-gradient(135deg, rgba(0,229,255,.16), rgba(10,103,255,.12));
  border:1px solid rgba(0,229,255,.12);
  box-shadow:var(--glow);white-space:nowrap
}
.badge .label{opacity:.85;font-weight:800;font-size:.8rem;letter-spacing:.03em}
.badge .value{font-weight:900;color:var(--primary);font-size:1rem}
.hearts{display:flex;gap:.25rem}
.heart{width:18px;height:18px;background:conic-gradient(from 180deg, #ff7b7b, #ff3b3b, #ff7b7b);clip-path:path("M12 21s-1-.5-2.25-1.6C7.4 17.8 6 16.3 4.8 14.7 3.3 12.7 2 10.4 2 8.3 2 5.5 4.2 3 7 3c1.3 0 2.6.6 3.5 1.6L12 6l1.5-1.4C14.4 3.6 15.7 3 17 3c2.8 0 5 2.5 5 5.3 0 2.1-1.3 4.4-2.8 6.4-1.2 1.6-2.6 3.1-4.95 4.7C13 20.5 12 21 12 21z");filter:drop-shadow(0 0 6px rgba(255,59,59,.35))}
.heart.off{opacity:.25;filter:none}

.btn{
  pointer-events:auto;border:none;cursor:pointer;border-radius:12px;
  background:linear-gradient(135deg, rgba(0,229,255,.18), rgba(10,103,255,.18));
  color:var(--text);padding:.5rem .75rem;font-weight:900;letter-spacing:.05em;
  box-shadow:var(--glow);transition:transform .08s ease, box-shadow .2s ease
}
.btn:active{transform:translateY(1px);box-shadow:0 0 0 rgba(0,0,0,0)}
.pause-btn{font-size:.9rem}

.status-chips{
  position:absolute;top:46px;left:8px;right:8px;display:flex;gap:.4rem;justify-content:center;flex-wrap:wrap;pointer-events:none
}
.chip{
  display:flex;align-items:center;gap:.35rem;padding:.25rem .5rem;border-radius:10px;
  background:rgba(0,229,255,.12);border:1px solid rgba(255,255,255,.1);box-shadow:var(--glow);font-size:.8rem;font-weight:800
}
.chip .bar{width:50px;height:6px;border-radius:6px;background:rgba(255,255,255,.08);overflow:hidden}
.chip .bar .fill{height:100%;width:0%;background:linear-gradient(90deg, var(--primary), var(--secondary));transition:width .15s ease}

.chip .label{opacity:.9}

.bars{
  position:absolute;bottom:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none
}
.bar{flex:1;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);border-radius:10px;height:14px;overflow:hidden;position:relative}
.bar > .fill{position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,var(--accent),#ffd166);box-shadow:0 0 14px rgba(255,140,0,.45);transition:width .18s ease}
.bar.nitro > .fill{background:linear-gradient(90deg,var(--primary),var(--secondary));box-shadow:0 0 14px rgba(0,229,255,.5)}

@keyframes nitroPulse{
  0%{filter:drop-shadow(0 0 0 rgba(0,229,255,.4))}
  50%{filter:drop-shadow(0 0 14px rgba(0,229,255,.8))}
  100%{filter:drop-shadow(0 0 0 rgba(0,229,255,.4))}
}
.bar.nitro > .fill.full{animation:nitroPulse 1s ease-in-out infinite}

.controls{
  position:absolute;left:10px;right:10px;bottom:32px;display:flex;gap:10px;pointer-events:auto
}
.control-btn{
  flex:1;min-height:64px;border:none;border-radius:14px;
  background:linear-gradient(135deg, rgba(0,229,255,.15), rgba(10,103,255,.15));
  color:var(--text);font-size:1.05rem;font-weight:900;letter-spacing:.06em;
  box-shadow:var(--glow);transition:transform .06s ease, box-shadow .2s ease
}
.control-btn:active{transform:translateY(2px)}
.control-btn.primary{flex:.95;background:linear-gradient(135deg, rgba(0,229,255,.25), rgba(10,103,255,.25))}
#nitroBtn{flex:.7;background:linear-gradient(135deg, rgba(0,229,255,.35), rgba(10,103,255,.35))}

@media (min-width: 768px){
  .controls{display:none}
}

/* Overlays */
.overlay{
  position:fixed;inset:0;background:rgba(3,7,18,.78);backdrop-filter:blur(8px);
  display:none;align-items:center;justify-content:center;z-index:10
}
.overlay.show{display:flex}
.panel{
  width:min(480px,94vw);border-radius:18px;padding:20px;
  background:linear-gradient(180deg, rgba(0,229,255,.08), rgba(10,103,255,.06));
  border:1px solid rgba(255,255,255,.1);box-shadow:0 30px 80px var(--shadow);text-align:center
}
.panel h2{
  font-size:1.5rem;margin-bottom:.4rem;
  background:linear-gradient(90deg,var(--primary),var(--secondary));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent
}
.panel p{opacity:.92;margin:.35rem 0}
.panel .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:.8rem}
.panel .grid .cell{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:.6rem}
.panel .actions{margin-top:1rem;display:flex;gap:.6rem;justify-content:center;flex-wrap:wrap}
.primary-btn{border:none;border-radius:14px;padding:.7rem 1.2rem;font-weight:900;letter-spacing:.06em;color:#001;
  background:linear-gradient(135deg,#00e5ff,#0a67ff);box-shadow:var(--glow);cursor:pointer}
.ghost-btn{border:1px solid rgba(255,255,255,.25);background:transparent;color:var(--text);border-radius:14px;padding:.7rem 1.2rem;font-weight:800;cursor:pointer}

.small{font-size:.85rem;opacity:.8}
.best{font-weight:900;color:var(--ok)}
.warning{color:var(--danger);font-weight:800}

/* Floating text */
.float-layer{position:absolute;inset:0;pointer-events:none;z-index:4}

/* Prevent iOS rubber band */
body, .overlay, .game-container{overscroll-behavior:contain}
</style>
</head>
<body>
<div class="header"><h1>NEON STREET RACER+</h1></div>

<div class="game-container" id="gameContainer" aria-label="Neon Street Racer game area">
  <canvas id="game"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="top">
      <div class="stack-left">
        <div class="badge">
          <span class="label">DIST</span><span class="value" id="distanceLabel">0 m</span>
        </div>
        <div class="badge">
          <span class="label">SPEED</span><span class="value" id="speedLabel">0 km/h</span>
        </div>
      </div>
      <div class="stack-right">
        <div class="badge">
          <span class="label">COINS</span><span class="value" id="coinsLabel">0</span>
        </div>
        <div class="badge">
          <span class="label">COMBO</span><span class="value" id="comboLabel">x1</span>
        </div>
        <div class="badge hearts" id="hearts" aria-label="Lives">
          <div class="heart"></div><div class="heart"></div><div class="heart"></div>
        </div>
        <button class="btn pause-btn" id="pauseBtn" aria-label="Pause game">PAUSE</button>
      </div>
    </div>

    <div class="status-chips" id="statusChips">
      <div class="chip" id="shieldChip" style="display:none"><span class="label">SHIELD</span><div class="bar"><div class="fill" id="shieldFill"></div></div></div>
      <div class="chip" id="magnetChip" style="display:none"><span class="label">MAGNET</span><div class="bar"><div class="fill" id="magnetFill"></div></div></div>
      <div class="chip" id="weatherChip" style="display:none"><span class="label" id="weatherLabel">RAIN</span></div>
    </div>

    <div class="bars" aria-hidden="true">
      <div class="bar fuel"><div class="fill" id="fuelFill"></div></div>
      <div class="bar nitro"><div class="fill" id="nitroFill"></div></div>
    </div>
  </div>

  <div class="float-layer" id="floatLayer"></div>

  <div class="controls" aria-label="Touch controls">
    <button class="control-btn primary" id="leftBtn" aria-label="Move Left">⟵ LEFT</button>
    <button class="control-btn" id="nitroBtn" aria-label="Nitro Boost">NITRO</button>
    <button class="control-btn primary" id="rightBtn" aria-label="Move Right">RIGHT ⟶</button>
  </div>
</div>

<!-- Start Overlay -->
<div class="overlay show" id="startOverlay">
  <div class="panel">
    <h2>Start Your Engines</h2>
    <p>Survive traffic, collect coins, draft for Nitro, and push your Combo with near-misses.</p>
    <div class="grid">
      <div class="cell"><strong>Move</strong><br>Arrow keys / A-D<br>Tap & hold LEFT/RIGHT side</div>
      <div class="cell"><strong>Nitro</strong><br>Hold Shift/Space<br>Tap center or Nitro button</div>
      <div class="cell"><strong>Extras</strong><br>Shield, Magnet, Fuel</div>
      <div class="cell"><strong>Tips</strong><br>Draft close behind cars<br>Near-miss for Combo</div>
    </div>
    <div class="actions">
      <button class="primary-btn" id="startBtn" aria-label="Tap to start">Tap to Start</button>
      <button class="ghost-btn" id="muteBtn" aria-label="Toggle sound">Sound: Off</button>
    </div>
    <p class="small">Mobile-ready: big touch zones, haptics, and optimized visuals.</p>
  </div>
</div>

<!-- Pause Overlay -->
<div class="overlay" id="pauseOverlay">
  <div class="panel">
    <h2>Paused</h2>
    <p>Take a breather, racer.</p>
    <div class="actions">
      <button class="primary-btn" id="resumeBtn">Resume</button>
      <button class="ghost-btn" id="restartFromPauseBtn">Restart</button>
    </div>
  </div>
</div>

<!-- Game Over Overlay -->
<div class="overlay" id="gameOverOverlay">
  <div class="panel">
    <h2>Crash Landing</h2>
    <p>Distance: <strong id="finalDistance">0 m</strong></p>
    <p>Coins: <strong id="finalCoins">0</strong></p>
    <p>Best: <span class="best" id="bestDistance">0 m</span></p>
    <div class="actions">
      <button class="primary-btn" id="playAgainBtn">Play Again</button>
      <button class="ghost-btn" id="backToMenuBtn">Main Menu</button>
    </div>
    <p class="small warning">Avoid trucks, keep drafting, and watch the fuel.</p>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const gameContainer = document.getElementById('gameContainer');

  // HUD elements
  const distanceLabel = document.getElementById('distanceLabel');
  const speedLabel = document.getElementById('speedLabel');
  const coinsLabel = document.getElementById('coinsLabel');
  const comboLabel = document.getElementById('comboLabel');
  const fuelFill = document.getElementById('fuelFill');
  const nitroFill = document.getElementById('nitroFill');
  const heartsEl = document.getElementById('hearts');
  const shieldChip = document.getElementById('shieldChip');
  const magnetChip = document.getElementById('magnetChip');
  const shieldFill = document.getElementById('shieldFill');
  const magnetFill = document.getElementById('magnetFill');
  const weatherChip = document.getElementById('weatherChip');
  const weatherLabel = document.getElementById('weatherLabel');
  const floatLayer = document.getElementById('floatLayer');

  // Overlays
  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  // Buttons
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartFromPauseBtn = document.getElementById('restartFromPauseBtn');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const backToMenuBtn = document.getElementById('backToMenuBtn');
  const muteBtn = document.getElementById('muteBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const nitroBtn = document.getElementById('nitroBtn');

  const W = 400, H = 700;
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  function resizeCanvas() {
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas, {passive:true});
  window.addEventListener('orientationchange', resizeCanvas, {passive:true});

  // Road / lanes
  const roadMargin = 40;
  const roadWidth = W - roadMargin * 2;
  const lanes = 3;
  const laneWidth = roadWidth / lanes;
  const laneCenters = [0,1,2].map(i => roadMargin + laneWidth*(i+0.5));

  // Game State
  let running = false;
  let paused = false;
  let gameOver = false;
  let started = false;
  let time = 0;
  let last = 0;
  let distance = 0;
  let coins = 0;
  let hearts = 3;
  let fuel = 100;
  let nitro = 40;
  let combo = 1;
  let comboTimeLeft = 0;
  let best = +(localStorage.getItem('neon_best') || 0);
  let vibrate = 'vibrate' in navigator;
  let muted = true;

  // Speed model & difficulty
  let baseSpeed = 230; // px/s
  let speed = baseSpeed;
  let speedBoost = 1;
  let nitroDown = false;

  // Conditions
  let weather = 'clear'; // 'clear' | 'rain'
  let weatherUntil = 0;
  let dayCycleT = 0; // 0..1 day-night blend

  // Car model
  const car = {
    lane: 1,
    x: laneCenters[1] - 22,
    y: H - 130,
    width: 44,
    height: 90,
    targetX: laneCenters[1] - 22,
    moveCooldown: 0,
    slip: 0, // lateral slip from oil/rain
    tilt: 0
  };

  // Entities
  const obstacles = []; // traffic and hazards
  const pickups = [];
  const particles = [];
  const messages = [];
  const roadside = []; // scenery

  // Powerups/Timers
  let invulnUntil = 0;
  let shieldUntil = 0;
  let magnetUntil = 0;
  let jumpUntil = 0; // reserved

  // Spawners
  let obstacleTimer = 0;
  let obstacleInterval = 1100;
  let pickupTimer = 0;
  let pickupInterval = 2300;
  let roadsideTimer = 0;

  // Input
  const keys = Object.create(null);
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (['arrowleft','arrowright','a','d',' ','shift','escape','p'].includes(k)) e.preventDefault();
    keys[k] = true;
    if (!started) return;
    if (k === 'escape' || k === 'p') togglePause(true);
    if ((k === 'arrowleft' || k === 'a')) tryLane(-1);
    if ((k === 'arrowright' || k === 'd')) tryLane(1);
    if (k === ' ' || k === 'shift') nitroDown = true;
  }, {passive:false});
  window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    keys[k] = false;
    if (k === ' ' || k === 'shift') nitroDown = false;
  }, {passive:true});

  // Touch buttons + haptic indicator on container
  const setHoldVisual = (side, on) => {
    if (on) {
      gameContainer.classList.add(side === 'left' ? 'hold-left' : 'hold-right');
    } else {
      gameContainer.classList.remove(side === 'left' ? 'hold-left' : 'hold-right');
    }
  };
  const press = (fn) => (e)=>{ e.preventDefault(); fn(true); };
  const release = (fn) => (e)=>{ e.preventDefault(); fn(false); };

  leftBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); tryLane(-1); setHoldVisual('left', true); });
  leftBtn.addEventListener('pointerup', e=>{ e.preventDefault(); setHoldVisual('left', false); });
  leftBtn.addEventListener('pointercancel', e=>{ setHoldVisual('left', false); });

  rightBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); tryLane(1); setHoldVisual('right', true); });
  rightBtn.addEventListener('pointerup', e=>{ e.preventDefault(); setHoldVisual('right', false); });
  rightBtn.addEventListener('pointercancel', e=>{ setHoldVisual('right', false); });

  nitroBtn.addEventListener('pointerdown', e=>{e.preventDefault(); nitroDown = true;});
  nitroBtn.addEventListener('pointerup', e=>{e.preventDefault(); nitroDown = false;});
  nitroBtn.addEventListener('pointercancel', e=>{ nitroDown = false; });

  // Canvas swipe + hold zones (full-area steering)
  let touchStartX = null;
  let holdLeft = false, holdRight = false, nextHoldMoveAt = 0, holdingPointer = null;
  canvas.addEventListener('pointerdown', e=>{
    e.preventDefault();
    if (!started) return;
    holdingPointer = e.pointerId;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const half = rect.width/2;
    if (x < half - rect.width*0.08){
      holdLeft = true; holdRight = false; tryLane(-1); nextHoldMoveAt = performance.now()+160; setHoldVisual('left', true);
    } else if (x > half + rect.width*0.08){
      holdRight = true; holdLeft = false; tryLane(1); nextHoldMoveAt = performance.now()+160; setHoldVisual('right', true);
    } else { // center tap toggles nitro short burst
      nitroDown = true; setTimeout(()=>nitroDown=false, 220);
    }
  }, {passive:false});
  window.addEventListener('pointerup', e=>{
    if (e.pointerId === holdingPointer){ holdLeft = holdRight = false; holdingPointer = null; gameContainer.classList.remove('hold-left','hold-right'); }
  }, {passive:true});
  window.addEventListener('pointercancel', e=>{
    if (e.pointerId === holdingPointer){ holdLeft = holdRight = false; holdingPointer = null; gameContainer.classList.remove('hold-left','hold-right'); }
  }, {passive:true});

  canvas.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
  }, {passive:true});
  canvas.addEventListener('touchend', e => {
    if (touchStartX == null) return;
    const endX = (e.changedTouches[0] || {}).clientX || touchStartX;
    const dx = endX - touchStartX;
    if (Math.abs(dx) > 30) {
      tryLane(dx > 0 ? 1 : -1);
    }
    touchStartX = null;
  }, {passive:true});

  // prevent context menu on long-press inside game area
  gameContainer.addEventListener('contextmenu', e => e.preventDefault());

  // UI controls
  startBtn.onclick = async () => {
    started = true; hide(startOverlay); initAudio(); await goFullscreen(); startGame();
  };
  pauseBtn.onclick = ()=> togglePause(true);
  resumeBtn.onclick = ()=> togglePause(false);
  restartFromPauseBtn.onclick = ()=> { hide(pauseOverlay); restartGame(); };
  playAgainBtn.onclick = ()=> { hide(gameOverOverlay); restartGame(); };
  backToMenuBtn.onclick = ()=> { hide(gameOverOverlay); show(startOverlay); resetToMenu(); };
  muteBtn.onclick = ()=> { muted = !muted; muteBtn.textContent = `Sound: ${muted?'Off':'On'}`; };

  // Auto pause on tab hidden (mobile friendly)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && running && !paused) togglePause(true);
  }, {passive:true});

  // Utils
  function show(el){ el.classList.add('show'); }
  function hide(el){ el.classList.remove('show'); }
  function clamp(v,min,max){ return v<min?min:v>max?max:v; }
  function lerp(a,b,t){ return a+(b-a)*t; }

  async function goFullscreen(){
    const el = document.documentElement;
    try{
      if (!document.fullscreenElement && el.requestFullscreen){
        await el.requestFullscreen({navigationUI:'hide'});
      }
    }catch(_){}
  }

  function tryLane(dir){
    if (!running || paused) return;
    const now = performance.now();
    if (car.moveCooldown > now) return;
    const prevLane = car.lane;
    car.lane = clamp(car.lane + (dir>0?1:-1), 0, lanes-1);
    if (car.lane !== prevLane){
      car.targetX = laneCenters[car.lane] - car.width/2;
      car.moveCooldown = now + 140; // ms between lane changes
      if (vibrate) navigator.vibrate?.(10);
      sfx('tick');
    }
  }

  function resetToMenu(){
    running = false; paused = false; gameOver = false;
    distance = 0; coins = 0; hearts = 3; fuel = 100; nitro = 40; speed = baseSpeed; combo = 1; comboTimeLeft = 0;
    invulnUntil = shieldUntil = magnetUntil = jumpUntil = 0;
    obstacleTimer = 0; obstacleInterval = 1100; pickupTimer = 0; pickupInterval = 2300; time = 0; last = 0;
    obstacles.length = 0; pickups.length = 0; particles.length = 0; messages.length = 0; roadside.length = 0;
    car.lane = 1; car.x = car.targetX = laneCenters[1] - car.width/2; car.y = H - 130; car.moveCooldown = 0; car.slip = 0; car.tilt = 0;
    weather = 'clear'; weatherUntil = 0; weatherChip.style.display = 'none';
    updateHUD();
    drawFrame(0);
  }

  function startGame(){
    if (running) return;
    resetToMenu();
    running = true;
    paused = false;
    gameOver = false;
    last = performance.now();
    requestAnimationFrame(loop);
  }

  function togglePause(wantPause){
    if (!running || gameOver) return;
    paused = wantPause;
    if (paused){
      show(pauseOverlay);
    }else{
      hide(pauseOverlay);
      last = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function endGame(){
    running = false;
    gameOver = true;
    const distInt = Math.floor(distance);
    document.getElementById('finalDistance').textContent = `${distInt} m`;
    document.getElementById('finalCoins').textContent = coins;
    if (distInt > best){
      best = distInt;
      localStorage.setItem('neon_best', String(best));
    }
    document.getElementById('bestDistance').textContent = `${best} m`;
    show(gameOverOverlay);
    if (vibrate) navigator.vibrate?.([60,60,120]);
    sfx('boom');
  }

  function restartGame(){
    hide(pauseOverlay);
    hide(gameOverOverlay);
    startGame();
  }

  // Spawning helpers
  function spawnObstaclePattern(){
    const roll = Math.random();
    if (roll < 0.25){
      // wall pattern: two lanes blocked, one gap
      const gap = Math.floor(Math.random()*lanes);
      for (let i=0;i<lanes;i++){
        if (i === gap) continue;
        spawnObstacleAt(i, Math.random()<0.5?'truck':'car', 0);
      }
    } else if (roll < 0.5){
      // staggered cars
      const a = Math.floor(Math.random()*lanes);
      const b = clamp(a + (Math.random()<0.5?-1:1), 0, lanes-1);
      spawnObstacleAt(a, 'car', 0);
      spawnObstacleAt(b, 'car', -120);
    } else {
      spawnObstacleAt(Math.floor(Math.random()*lanes));
      if (Math.random() < 0.35) spawnObstacleAt(Math.floor(Math.random()*lanes));
    }
  }

  function spawnObstacleAt(lane, type, yOffset=0){
    const kindR = Math.random();
    let t = type;
    if (!t){
      if (kindR < 0.18){ t='truck'; }
      else if (kindR < 0.3){ t='cone'; }
      else if (kindR < 0.42){ t='oil'; }
      else { t='car'; }
    }
    let w = laneWidth*0.72, h = 96, extraSpeed = 0;
    if (t === 'truck'){ w = laneWidth*0.86; h = 150; extraSpeed = -35; }
    if (t === 'cone'){ w = laneWidth*0.35; h = 44; extraSpeed = 10; }
    if (t === 'oil'){ w = laneWidth*0.7; h = 26; extraSpeed = 18; }
    const x = laneCenters[lane] - w/2;
    obstacles.push({type:t, lane, x, y: -h-10 + yOffset, w, h, extraSpeed, passed:false});
  }

  function spawnPickup(){
    const lane = Math.floor(Math.random()*lanes);
    const roll = Math.random();
    let type;
    if (roll < 0.48) type = 'coin';
    else if (roll < 0.68) type = 'fuel';
    else if (roll < 0.84) type = 'nitro';
    else if (roll < 0.93) type = 'shield';
    else type = 'magnet';
    const x = laneCenters[lane];
    const y = -20;
    pickups.push({type, lane, x, y, r: type==='coin'?10:12});
  }

  function spawnRoadside(){
    const side = Math.random()<0.5 ? 'left' : 'right';
    const x = side==='left' ? roadMargin-16 : roadMargin+roadWidth+16;
    const w = 8;
    const h = 60 + Math.random()*50;
    const color = side==='left' ? '#0b1d44' : '#0e224f';
    roadside.push({x:x - (side==='left'?w:0), y:-h-10, w, h, color});
  }

  // Visual FX
  function addBurst(x,y,color,count=10){
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const s = 60 + Math.random()*160;
      particles.push({x,y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 0.35 + Math.random()*0.35, age:0, color});
    }
  }
  function addMessage(text,x,y,color='#fff'){
    messages.push({text,x,y,age:0,life:1.1,color});
  }

  // Collision
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // HUD
  function updateHUD(){
    distanceLabel.textContent = `${Math.floor(distance)} m`;
    coinsLabel.textContent = coins;
    comboLabel.textContent = `x${combo}`;
    fuelFill.style.width = `${clamp(fuel,0,100)}%`;
    nitroFill.style.width = `${clamp(nitro,0,100)}%`;
    nitroFill.classList.toggle('full', nitro >= 99);
    [...heartsEl.children].forEach((el,i) => el.classList.toggle('off', i > hearts-1));
    const kmh = Math.round(speed * 3.6 / 100); // tuned display
    speedLabel.textContent = `${kmh*10} km/h`;
    // power chips
    const now = performance.now();
    const showShield = now < shieldUntil;
    const showMagnet = now < magnetUntil;
    if (showShield){
      shieldChip.style.display = '';
      const left = (shieldUntil - now) / 6000;
      shieldFill.style.width = `${clamp(left*100,0,100)}%`;
    } else shieldChip.style.display = 'none';
    if (showMagnet){
      magnetChip.style.display = '';
      const left = (magnetUntil - now) / 6000;
      magnetFill.style.width = `${clamp(left*100,0,100)}%`;
    } else magnetChip.style.display = 'none';
  }

  // Loop
  let stripeOffset = 0;
  let cameraShake = 0;

  function loop(ts){
    if (!running || paused) return;
    const dt = Math.min(0.05, (ts - last) / 1000);
    last = ts; time += dt;

    // Steering hold repeat
    if (holdingPointer && (holdLeft || holdRight) && performance.now() >= nextHoldMoveAt){
      tryLane(holdLeft?-1:1);
      nextHoldMoveAt = performance.now()+180;
    }

    // Difficulty scaling (~14-15 mins to max)
    const t = Math.min(time / (60*13.5), 1); // 0..1 over ~13.5 minutes
    baseSpeed = 230 + t * 230; // 230 -> 460 px/s
    obstacleInterval = 1100 - t * 560; // 1100ms -> 540ms
    pickupInterval = 2300 - t * 650;   // 2300ms -> 1650ms

    // Day-night cycle (90s)
    dayCycleT = (Math.sin(time/90*2*Math.PI)+1)/2;

    // Weather toggle
    if (performance.now() > weatherUntil){
      if (Math.random() < 0.08){
        weather = 'rain';
        weatherUntil = performance.now() + (15000 + Math.random()*12000);
        weatherChip.style.display = '';
        weatherLabel.textContent = 'RAIN';
      } else {
        weather = 'clear';
        weatherUntil = performance.now() + (12000 + Math.random()*14000);
        weatherChip.style.display = 'none';
      }
    }

    // Nitro
    if (nitroDown && nitro > 0){
      speedBoost = 1.65;
      nitro = Math.max(0, nitro - 23*dt);
    }else{
      speedBoost = 1;
      nitro = Math.min(100, nitro + 6.5*dt); // recharge slowly
    }
    speed = baseSpeed * speedBoost;

    // Fuel drain
    const fuelDrainRate = (0.42 + 0.38*t) * (1 + (speedBoost-1)*0.7) * (weather==='rain'?1.05:1);
    fuel -= fuelDrainRate * dt;
    if (fuel <= 0){
      fuel = 0;
      hearts = 0;
      updateHUD();
      endGame();
      drawFrame(dt);
      return;
    }

    // Smooth lane movement with slip + tilt
    const grip = weather==='rain' ? 8 : 12;
    car.slip += (car.targetX - car.x - car.slip) * Math.min(1, dt*grip);
    car.x += car.slip * dt * (weather==='rain'?1.2:1);
    const targetTilt = clamp((car.targetX - car.x) * 0.003, -0.20, 0.20);
    car.tilt += (targetTilt - car.tilt) * Math.min(1, dt*8);

    // Roadside
    roadsideTimer += dt*1000;
    if (roadsideTimer > 280){
      roadsideTimer = 0;
      if (Math.random()<0.7) spawnRoadside();
    }
    for (let i=roadside.length-1;i>=0;i--){
      const s = roadside[i];
      s.y += speed * dt * 0.9;
      if (s.y > H+80) roadside.splice(i,1);
    }

    // Obstacles update
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.y += (speed + o.extraSpeed) * dt;
      // slight wobble for cars
      if (o.type==='car') o.x += Math.sin((o.y+time*120)*0.01) * 0.2;

      // near-miss check when passes player
      if (!o.passed && o.y + o.h >= car.y + car.height - 10){
        o.passed = true;
        if (!aabb(car.x+6,car.y+4,car.width-12,car.height-8, o.x,o.y,o.w,o.h)){
          const sameLane = o.lane === car.lane;
          const deltaY = Math.abs((car.y+car.height) - (o.y+o.h));
          if (sameLane && deltaY < 18){
            const bonus = 2 * combo;
            coins += bonus;
            combo = Math.min(combo+1, 10);
            comboTimeLeft = 2.8; // seconds to maintain combo
            addBurst(car.x+car.width/2, car.y+car.height/2, 'rgba(255,215,0,.75)', 16);
            addMessage(`NEAR MISS +${bonus}`, car.x+car.width/2, car.y-8, '#ffd166');
            if (vibrate) navigator.vibrate?.(20);
            sfx('coin2');
            nitro = clamp(nitro + 3, 0, 100);
          }
        }
      }
      if (o.y > H + 200) obstacles.splice(i,1);
    }

    // Drafting: stay close behind car/truck
    let drafting = false;
    for (const o of obstacles){
      if ((o.type==='car' || o.type==='truck') && o.lane === car.lane){
        const gap = (car.y) - (o.y + o.h);
        if (gap > 20 && gap < 140){
          drafting = true; break;
        }
      }
    }
    if (drafting){
      nitro = clamp(nitro + 9*dt, 0, 100);
      addSpeedLineSoft();
    }

    // Pickups update + magnet
    const magnetActive = performance.now() < magnetUntil;
    for (let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.y += speed * dt;
      if (magnetActive && p.type === 'coin'){
        const cx = car.x + car.width/2, cy = car.y + car.height/2;
        const dx = cx - p.x, dy = cy - p.y;
        const dist = Math.hypot(dx,dy);
        const pull = clamp(240 / Math.max(60, dist), 0, 3.4);
        p.x += dx * pull * dt;
        p.y += dy * pull * dt;
      }
      if (p.y > H + 50) pickups.splice(i,1);
    }

    // Camera shake decay
    cameraShake *= Math.pow(0.9, dt*60);

    // Collisions
    const now = performance.now();
    const invuln = now < invulnUntil || now < shieldUntil || now < jumpUntil;
    const hitRect = {x:car.x+6,y:car.y+4,w:car.width-12,h:car.height-8};
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      if (aabb(hitRect.x,hitRect.y,hitRect.w,hitRect.h, o.x,o.y,o.w,o.h)){
        obstacles.splice(i,1);
        if (!invuln){
          let dmg = 1;
          if (o.type === 'truck') dmg = 2;
          if (o.type === 'oil') dmg = 0.5;
          hearts -= dmg;
          invulnUntil = now + 900;
          combo = 1; comboTimeLeft = 0;
          cameraShake = 6;
          addBurst(car.x+car.width/2, car.y+car.height/2, 'rgba(255,59,59,.8)', 26);
          if (vibrate) navigator.vibrate?.(120);
          sfx('hit');
          if (hearts <= 0){
            hearts = 0; updateHUD(); endGame(); drawFrame(dt); return;
          }
        }else{
          addBurst(o.x+o.w/2, o.y+o.h/2, 'rgba(0,229,255,.7)', 14);
        }
      }
    }

    // Pickup collisions
    for (let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      if (aabb(hitRect.x,hitRect.y,hitRect.w,hitRect.h, p.x-12,p.y-12,24,24)){
        pickups.splice(i,1);
        switch (p.type){
          case 'coin':
            coins += 1 * combo;
            addBurst(p.x, p.y, 'rgba(255,215,0,.9)', 10);
            addMessage(combo>1?`+${1*combo}`:'+1', p.x, p.y-8, '#ffd166');
            if (vibrate) navigator.vibrate?.(10);
            sfx('coin');
            break;
          case 'fuel':
            fuel = clamp(fuel + 28, 0, 100);
            addBurst(p.x, p.y, 'rgba(35,209,139,.9)', 12);
            addMessage('FUEL +', p.x, p.y-8, '#23d18b');
            sfx('fuel');
            break;
          case 'nitro':
            nitro = clamp(nitro + 28, 0, 100);
            addBurst(p.x, p.y, 'rgba(0,229,255,.9)', 12);
            addMessage('NITRO +', p.x, p.y-8, '#00e5ff');
            sfx('nitro');
            break;
          case 'shield':
            shieldUntil = now + 6000;
            addBurst(p.x, p.y, 'rgba(0,229,255,.9)', 18);
            addMessage('SHIELD', p.x, p.y-8, '#00e5ff');
            sfx('power');
            break;
          case 'magnet':
            magnetUntil = now + 6000;
            addBurst(p.x, p.y, 'rgba(255,140,0,.9)', 18);
            addMessage('MAGNET', p.x, p.y-8, '#ffb703');
            sfx('power');
            break;
        }
        // boost combo time slightly on pickups
        comboTimeLeft = Math.min(comboTimeLeft + 0.3, 3.2);
      }
    }

    // Combo decay
    if (combo > 1){
      comboTimeLeft -= dt;
      if (comboTimeLeft <= 0){
        combo = 1;
        comboTimeLeft = 0;
      }
    }

    // Distance
    const metersPerPixel = 0.5;
    distance += speed * dt * metersPerPixel;

    // Spawning
    obstacleTimer += dt*1000;
    pickupTimer += dt*1000;
    if (obstacleTimer >= obstacleInterval){
      obstacleTimer = 0;
      spawnObstaclePattern();
    }
    if (pickupTimer >= pickupInterval){
      pickupTimer = 0;
      spawnPickup();
      if (Math.random() < 0.25) spawnPickup();
    }

    // Particles and messages
    for (let i=particles.length-1;i>=0;i--){
      const pa = particles[i];
      pa.age += dt;
      if (pa.age > pa.life){ particles.splice(i,1); continue; }
      pa.x += pa.vx * dt;
      pa.y += pa.vy * dt;
      pa.vy += 50 * dt;
    }
    for (let i=messages.length-1;i>=0;i--){
      const m = messages[i];
      m.age += dt;
      m.y -= 18*dt;
      if (m.age > m.life){ messages.splice(i,1); }
    }

    updateHUD();
    drawFrame(dt);

    if (running && !paused) requestAnimationFrame(loop);
  }

  function drawFrame(dt){
    // camera shake
    let cx = 0, cy = 0;
    if (cameraShake > 0){
      cx = (Math.random()*2-1)*cameraShake;
      cy = (Math.random()*2-1)*cameraShake;
    }
    ctx.setTransform(dpr, 0, 0, dpr, cx, cy);

    // clear
    ctx.clearRect(-10,-10,W+20,H+20);

    // Sky gradient day/night
    const sky = ctx.createLinearGradient(0,0,0,H*0.6);
    const nightTop = 'rgba(6,10,26,1)';
    const nightMid = 'rgba(10,16,35,1)';
    const dayTop = 'rgba(20,47,89,1)';
    const dayMid = 'rgba(8,18,36,1)';
    sky.addColorStop(0, mixColor(dayTop, nightTop, dayCycleT));
    sky.addColorStop(1, mixColor(dayMid, nightMid, dayCycleT));
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);

    // City silhouette
    drawCity();

    // Road and stripes
    drawRoad(dt);

    // Roadside scenery
    for (const s of roadside){
      ctx.fillStyle = s.color;
      ctx.shadowColor = 'rgba(0,0,0,.5)';
      ctx.shadowBlur = 4;
      roundRect(ctx, s.x, s.y, s.w, s.h, 3); ctx.fill();
      ctx.shadowBlur = 0;
      // neon sign head
      if (Math.random()<0.2){
        ctx.fillStyle = 'rgba(0,229,255,.25)';
        ctx.fillRect(s.x-2, s.y-6, s.w+4, 4);
      }
    }

    // Rain
    if (weather==='rain'){
      drawRain(dt);
    }

    // Pickups
    for (const p of pickups) drawPickup(p);

    // Obstacles
    for (const o of obstacles) drawObstacle(o);

    // Car
    drawCar();

    // Shield glow
    if (performance.now() < shieldUntil){
      const t = (performance.now()%600)/600;
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.25*Math.sin(t*2*Math.PI);
      ctx.strokeStyle = '#00e5ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#00e5ff';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.roundRect ? ctx.roundRect(car.x-6, car.y-10, car.width+12, car.height+18, 14) : roundRect(ctx, car.x-6, car.y-10, car.width+12, car.height+18, 14);
      ctx.stroke();
      ctx.restore();
    }

    // Particles
    for (const pa of particles){
      const k = 1 - (pa.age/pa.life);
      ctx.globalAlpha = k;
      ctx.fillStyle = pa.color;
      ctx.beginPath();
      ctx.arc(pa.x, pa.y, 2 + 2*k, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Floating messages in DOM for crisp text
    renderFloatMessages();

    // Speed lines on heavy nitro
    if (speedBoost > 1.2){
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#00e5ff';
      ctx.lineWidth = 2;
      for(let i=0;i<12;i++){
        const x = Math.random()*roadWidth + roadMargin;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      ctx.restore();
    }

    // reset transform for next frame HUD clarity
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function drawCity(){
    ctx.save();
    const baseY = 150;
    const layer1 = [
      {x:6,w:40,h:70},{x:50,w:28,h:120},{x:90,w:55,h:90},{x:152,w:36,h:110},
      {x:195,w:50,h:140},{x:260,w:38,h:95},{x:308,w:32,h:130},{x:352,w:38,h:80}
    ];
    const a = 0.22 + 0.1*(1-dayCycleT);
    ctx.globalAlpha = a;
    ctx.fillStyle = '#0b1730';
    for(const b of layer1){ ctx.fillRect(b.x, baseY-b.h, b.w, b.h); }
    ctx.globalAlpha = a*0.8;
    ctx.fillStyle = '#0b1d44';
    for(const b of layer1){ ctx.fillRect(b.x+8, baseY-b.h-10, b.w*0.8, b.h+14); }
    // window lights at night
    if (dayCycleT > 0.5){
      ctx.globalAlpha = (dayCycleT-0.5)*1.2 * 0.7;
      ctx.fillStyle = 'rgba(255,210,120,.7)';
      for(const b of layer1){
        for(let i=0;i<Math.floor(b.w/8);i++){
          if (Math.random()<0.2) continue;
          const wx = b.x + 2 + i*8;
          for(let j=0;j<Math.floor(b.h/14);j++){
            if (Math.random()<0.8) continue;
            const wy = baseY-b.h + 4 + j*14;
            ctx.fillRect(wx, wy, 3, 6);
          }
        }
      }
    }
    ctx.restore();
  }

  function drawRoad(dt){
    stripeOffset += (speed * (dt||0)) % 1000;

    // Asphalt base with subtle texture
    ctx.save();
    ctx.fillStyle = '#0a0f1e';
    ctx.fillRect(roadMargin, 0, roadWidth, H);

    // Texture noise stripes
    ctx.globalAlpha = 0.05;
    for(let i=0;i<6;i++){
      const y = ((i*120 + (stripeOffset*0.12)) % (H+120)) - 120;
      ctx.fillStyle = i%2 ? '#0c1426' : '#0b1220';
      ctx.fillRect(roadMargin, y, roadWidth, 60);
    }
    ctx.globalAlpha = 1;

    // Guard rails
    ctx.fillStyle = '#0f1a33';
    ctx.fillRect(roadMargin-8, 0, 8, H);
    ctx.fillRect(roadMargin+roadWidth, 0, 8, H);

    // Lane stripes (glow)
    ctx.save();
    ctx.strokeStyle = '#00f7ff';
    ctx.lineWidth = 4;
    ctx.setLineDash([18, 16]);
    ctx.lineDashOffset = stripeOffset * -0.06;
    ctx.shadowColor = '#00f7ff';
    ctx.shadowBlur = 6;
    for (let i=1;i<lanes;i++){
      const x = roadMargin + i*laneWidth;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.restore();

    // Soft glow gradient
    const glow = ctx.createLinearGradient(roadMargin,0, roadMargin+roadWidth,0);
    glow.addColorStop(0, 'rgba(0,229,255,.06)');
    glow.addColorStop(0.5, 'transparent');
    glow.addColorStop(1, 'rgba(10,103,255,.06)');
    ctx.fillStyle = glow;
    ctx.fillRect(roadMargin,0,roadWidth,H);

    ctx.restore();
  }

  function drawCar(){
    ctx.save();
    const x = car.x, y = car.y, w = car.width, h = car.height;
    const night = dayCycleT > 0.6;

    // Rotate around center for leaning effect
    ctx.translate(x + w/2, y + h/2);
    ctx.rotate(car.tilt);
    const rx = -w/2, ry = -h/2;

    // Body with shading
    const g = ctx.createLinearGradient(rx, ry, rx, ry+h);
    g.addColorStop(0, '#0ac3ff');
    g.addColorStop(0.45, '#0a67ff');
    g.addColorStop(1, '#05307a');
    ctx.fillStyle = g;
    ctx.shadowColor = 'rgba(0,229,255,.35)';
    ctx.shadowBlur = 14;
    roundRect(ctx, rx, ry, w, h, 10); ctx.fill();
    ctx.shadowBlur = 0;

    // Hood and roof reflections
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = 'white';
    roundRect(ctx, rx+6, ry+8, w-12, 16, 6); ctx.fill();
    ctx.globalAlpha = 0.18;
    roundRect(ctx, rx+6, ry+40, w-12, 20, 6); ctx.fill();
    ctx.globalAlpha = 1;

    // Windows darker
    ctx.fillStyle = '#6fbff7';
    roundRect(ctx, rx+8, ry+14, w-16, 14, 5); ctx.fill();
    roundRect(ctx, rx+8, ry+44, w-16, 16, 5); ctx.fill();

    // Wheels with rims
    drawWheel(rx-6, ry+16);
    drawWheel(rx+w-4, ry+16);
    drawWheel(rx-6, ry+h-30);
    drawWheel(rx+w-4, ry+h-30);

    // Headlights (at night stronger)
    ctx.save();
    ctx.globalAlpha = night?0.65:0.25;
    const hx1 = rx+6, hx2 = rx+w-6, hy = ry+6;
    ctx.fillStyle = night?'rgba(255,255,200,.9)':'rgba(180,220,255,.7)';
    ctx.beginPath(); ctx.ellipse(hx1, hy, 4, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(hx2, hy, 4, 3, 0, 0, Math.PI*2); ctx.fill();

    // Light cone
    const cone = ctx.createRadialGradient((rx+w/2), ry, 0, (rx+w/2), ry-10, 80);
    cone.addColorStop(0, night?'rgba(255,255,230,.2)':'rgba(200,230,255,.1)');
    cone.addColorStop(1, 'rgba(255,255,230,0)');
    ctx.fillStyle = cone;
    ctx.beginPath(); ctx.ellipse(rx+w/2, ry-6, 36, 80, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // Tail lights
    ctx.fillStyle = 'rgba(255,60,60,.9)';
    roundRect(ctx, rx+6, ry+h-10, 10, 6, 2); ctx.fill();
    roundRect(ctx, rx+w-16, ry+h-10, 10, 6, 2); ctx.fill();

    // Exhaust flames when nitro
    if (speedBoost > 1.2){
      ctx.globalCompositeOperation = 'screen';
      const fx = rx + w/2, fy = ry + h + 6;
      const flame = ctx.createRadialGradient(fx, fy, 0, fx, fy, 26);
      flame.addColorStop(0, 'rgba(0,229,255,.95)');
      flame.addColorStop(0.5, 'rgba(10,103,255,.6)');
      flame.addColorStop(1, 'rgba(10,103,255,0)');
      ctx.fillStyle = flame;
      ctx.beginPath(); ctx.arc(fx, fy, 26, 0, Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    ctx.restore();
  }

  function drawWheel(x,y){
    ctx.save();
    ctx.fillStyle = '#0b0e14';
    roundRect(ctx, x, y, 10, 22, 3); ctx.fill();
    ctx.fillStyle = '#1d2433';
    roundRect(ctx, x+2, y+4, 6, 14, 2); ctx.fill();
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawObstacle(o){
    ctx.save();
    if (o.type === 'car' || o.type === 'truck'){
      const g = ctx.createLinearGradient(o.x, o.y, o.x, o.y+o.h);
      const c1 = o.type==='truck' ? '#2b3552' : '#182141';
      const c2 = o.type==='truck' ? '#121a30' : '#0b1228';
      g.addColorStop(0, c1); g.addColorStop(1, c2);
      ctx.fillStyle = g;
      const r = o.type==='truck'?12:10;
      roundRect(ctx, o.x, o.y, o.w, o.h, r); ctx.fill();

      // cab/window
      ctx.fillStyle = 'rgba(143,211,255,.9)';
      roundRect(ctx, o.x+6, o.y+10, o.w-12, o.type==='truck'?24:18, 5); ctx.fill();

      // grill and lights
      ctx.fillStyle = '#0a0f1c';
      const gh = 6; ctx.fillRect(o.x+6, o.y+o.h-gh-6, o.w-12, gh);
      ctx.fillStyle = 'rgba(255,210,150,.8)';
      ctx.fillRect(o.x+8, o.y+6, 6, 4);
      ctx.fillRect(o.x+o.w-14, o.y+6, 6, 4);
      ctx.fillStyle = 'rgba(255,30,30,.8)';
      ctx.fillRect(o.x+8, o.y+o.h-10, 6, 4);
      ctx.fillRect(o.x+o.w-14, o.y+o.h-10, 6, 4);
    } else if (o.type === 'cone'){
      ctx.fillStyle = '#ff8c00';
      ctx.beginPath();
      ctx.moveTo(o.x+o.w/2, o.y);
      ctx.lineTo(o.x+o.w, o.y+o.h);
      ctx.lineTo(o.x, o.y+o.h);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.fillRect(o.x+5, o.y+o.h-16, o.w-10, 6);
    } else if (o.type === 'oil'){
      ctx.fillStyle = 'rgba(10,10,14,.85)';
      roundRect(ctx, o.x, o.y, o.w, o.h, 12); ctx.fill();
      // subtle shine
      ctx.globalAlpha = 0.15; ctx.fillStyle = '#9aa3b3'; roundRect(ctx, o.x+6, o.y+4, o.w-12, o.h-12, 10); ctx.fill(); ctx.globalAlpha = 1;
    }
    ctx.restore();
  }

  function drawPickup(p){
    ctx.save();
    if (p.type === 'coin'){
      const g = ctx.createRadialGradient(p.x, p.y, 3, p.x, p.y, 12);
      g.addColorStop(0, '#ffe782');
      g.addColorStop(1, '#ffb703');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.6)'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.stroke();
    } else if (p.type === 'fuel'){
      // gas can
      ctx.fillStyle = '#23d18b';
      roundRect(ctx, p.x-12, p.y-14, 24, 28, 5); ctx.fill();
      ctx.fillStyle = '#0b1220';
      ctx.fillRect(p.x-3, p.y-6, 6, 12);
      ctx.fillStyle = 'rgba(255,255,255,.4)'; ctx.fillRect(p.x-8, p.y-2, 16, 2);
    } else if (p.type === 'nitro'){
      const g = ctx.createLinearGradient(p.x-10, p.y-12, p.x+10, p.y+12);
      g.addColorStop(0, '#00e5ff'); g.addColorStop(1, '#0a67ff');
      ctx.fillStyle = g; roundRect(ctx, p.x-10, p.y-12, 20, 24, 4); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,.75)'; ctx.fillRect(p.x-5, p.y-8, 10, 16);
      ctx.fillStyle = 'rgba(0,0,0,.3)'; ctx.fillRect(p.x-8, p.y+8, 16, 2);
    } else if (p.type === 'shield'){
      ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 3; ctx.shadowColor='#00e5ff'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2); ctx.stroke();
    } else if (p.type === 'magnet'){
      ctx.strokeStyle='#ff8c00'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(p.x, p.y, 12, Math.PI*0.25, Math.PI*1.75); ctx.stroke();
      ctx.beginPath(); ctx.lineWidth=4; ctx.arc(p.x, p.y, 8, Math.PI*0.25, Math.PI*1.75); ctx.stroke();
    }
    ctx.restore();
  }

  function drawRain(dt){
    // simple rain streaks
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#9ec9ff';
    ctx.lineWidth = 1;
    for(let i=0;i<22;i++){
      const rx = Math.random()*W;
      const ry = Math.random()*H;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx-6, ry+24);
      ctx.stroke();
    }
    // windshield streak
    const cone = ctx.createLinearGradient(0,0,0,120);
    cone.addColorStop(0,'rgba(200,220,255,.06)');
    cone.addColorStop(1,'rgba(200,220,255,0)');
    ctx.fillStyle = cone;
    ctx.fillRect(roadMargin, 0, roadWidth, 120);
    ctx.restore();
  }

  function addSpeedLineSoft(){
    // subtle drafting line behind car
    particles.push({
      x: car.x+car.width/2 + (Math.random()*16-8),
      y: car.y+car.height+4,
      vx: 0,
      vy: 180 + Math.random()*60,
      life: 0.25,
      age: 0,
      color: 'rgba(0,229,255,.25)'
    });
  }

  function renderFloatMessages(){
    // Use simple DOM nodes for crisp text
    floatLayer.innerHTML = '';
    const frag = document.createDocumentFragment();
    for(const m of messages){
      const el = document.createElement('div');
      el.textContent = m.text;
      const k = 1 - (m.age/m.life);
      el.style.position = 'absolute';
      el.style.left = (m.x - 30) + 'px';
      el.style.top = (m.y - 10) + 'px';
      el.style.fontSize = '12px';
      el.style.fontWeight = '900';
      el.style.color = m.color;
      el.style.textShadow = '0 0 8px rgba(255,255,255,.25)';
      el.style.opacity = String(clamp(k,0,1));
      frag.appendChild(el);
    }
    floatLayer.appendChild(frag);
  }

  function mixColor(a,b,t){
    function hexToRgb(h){
      const m = h.match(/\d+,\s*\d+,\s*\d+/);
      if (m){ const [r,g,bl]=m[0].split(',').map(Number); return [r,g,bl]; }
      let c = h.replace('#','');
      if (c.length===3) c = c.split('').map(s=>s+s).join('');
      const n = parseInt(c,16);
      return [(n>>16)&255,(n>>8)&255,n&255];
    }
    const ra = hexToRgb(a), rb = hexToRgb(b);
    const r = Math.round(lerp(ra[0],rb[0],t));
    const g = Math.round(lerp(ra[1],rb[1],t));
    const bl = Math.round(lerp(ra[2],rb[2],t));
    return `rgb(${r},${g},${bl})`;
  }

  // Audio (minimal, no assets)
  let ac = null;
  function initAudio(){
    if (!ac){
      try{ ac = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ ac=null; }
    }
  }
  function sfx(type){
    if (muted || !ac) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = 'square';
    o.connect(g); g.connect(ac.destination);
    let f=440, t=0.1;
    if (type==='coin'){ f=880; t=0.07; }
    if (type==='coin2'){ f=1200; t=0.08; }
    if (type==='nitro'){ f=200; t=0.12; }
    if (type==='fuel'){ f=520; t=0.12; }
    if (type==='power'){ f=640; t=0.18; }
    if (type==='hit'){ f=120; t=0.2; }
    if (type==='boom'){ f=80; t=0.35; }
    if (type==='tick'){ f=500; t=0.06; }
    o.frequency.value = f;
    g.gain.setValueAtTime(0.0001, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.18, ac.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+t);
    o.start();
    o.stop(ac.currentTime + t+0.02);
  }

  // Initial render
  resetToMenu();

})();
</script>
</body>
</html>