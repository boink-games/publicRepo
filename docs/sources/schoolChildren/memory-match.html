<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Match</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#FFE6F3;
      --bg2:#E6F7FF;
      --bg3:#FFF9CC;
      --primary:#FF7AB6;
      --secondary:#6EE7F5;
      --accent:#FFCB57;
      --success:#6EE7A7;
      --text:#2b2b2b;
      --cardFrontFrom:#A78BFA;
      --cardFrontTo:#60A5FA;
      --cardBackFrom:#FF9A9E;
      --cardBackTo:#FAD0C4;
      --shadow: 0 10px 24px rgba(0,0,0,.14);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; background:
      radial-gradient(1200px 900px at -10% -10%, var(--bg3), transparent 60%),
      radial-gradient(1200px 900px at 110% 10%, var(--bg2), transparent 60%),
      radial-gradient(1200px 900px at 50% 120%, var(--bg1), transparent 60%),
      linear-gradient(135deg, #fff, #fdf6ff); color:var(--text);
      font-family: 'Fredoka', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body::before{
      content:"";
      position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(18px 18px at 10% 20%, rgba(255, 203, 87,.15) 0 60%, transparent 61%),
        radial-gradient(14px 14px at 80% 30%, rgba(110, 231, 245,.18) 0 60%, transparent 61%),
        radial-gradient(16px 16px at 30% 80%, rgba(255, 122, 182,.16) 0 60%, transparent 61%);
      animation: floatBubbles 10s ease-in-out infinite;
    }
    @keyframes floatBubbles{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-12px); }
    }
    .wrap{ min-height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:18px; padding:16px; }
    h1{ margin:6px 0 0; font-size: clamp(24px, 6vw, 40px); font-weight:700; letter-spacing:.5px; background: linear-gradient(90deg, #ff6aa2, #ffcb57, #7dd3fc); -webkit-background-clip:text; background-clip:text; color: transparent; text-shadow: 0 2px 0 rgba(255,255,255,.5); }
    .subtitle{ font-size: clamp(14px, 3.5vw, 18px); opacity:.85; }
    .topbar{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; width: min(96vw, 760px); }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      background: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); font-weight:600;
    }
    .badge strong{ font-size:clamp(16px,4.5vw,20px); color:#1a1a1a; }
    .btn{
      background: linear-gradient(135deg, #FF7AB6, #FFB37A);
      color:#fff; border:none; padding:12px 16px; border-radius: 999px; font-weight:700; font-size: clamp(16px, 4.2vw, 18px);
      box-shadow: 0 10px 18px rgba(255,122,182,.35); cursor:pointer;
      transition: transform .15s ease, box-shadow .2s ease; touch-action: manipulation;
    }
    .btn.secondary{
      background: linear-gradient(135deg, #6EE7F5, #60A5FA);
      box-shadow: 0 10px 18px rgba(96,165,250,.30);
    }
    .btn:active{ transform: translateY(1px) scale(.98); }
    .btn:focus-visible{ outline: 3px solid rgba(110,231,165,.8); outline-offset: 2px; }
    .iconbtn{
      height:44px; width:44px; min-width:44px; padding:0;
      display:inline-flex; align-items:center; justify-content:center;
      border-radius: 999px; border:none; cursor:pointer; background:#fff;
      box-shadow: var(--shadow); font-size:20px;
      transition: transform .12s ease;
    }
    .iconbtn[aria-pressed="true"]{ background: linear-gradient(135deg, #c7f9e5, #e8fff7); }
    .iconbtn:active{ transform: translateY(1px) scale(.98); }
    .grid{
      display:grid; gap: clamp(10px, 2.6vw, 18px);
      grid-template-columns: repeat(auto-fit, minmax(clamp(86px, 22vw, 140px), 1fr));
      width: min(94vw, 760px); margin: 6px auto 10px;
      touch-action: manipulation;
    }
    .tile{ position:relative; aspect-ratio: 3/4; perspective: 900px; }
    .card{
      position:relative; width:100%; height:100%;
      transform-style:preserve-3d; will-change: transform;
      transition: transform .5s cubic-bezier(.2,.8,.25,1.2), box-shadow .2s ease;
      border-radius: 18px; box-shadow: var(--shadow);
      cursor: pointer; isolation:isolate; overflow:hidden;
    }
    .card:focus-visible{ outline: 4px solid rgba(96,165,250,.75); outline-offset: 3px; }
    @media (hover:hover){
      .card:not(.flipped):hover{ transform: translateY(-4px) rotateX(4deg) rotateY(-4deg); }
    }
    .face{
      position:absolute; inset:0; backface-visibility:hidden; border-radius: 18px;
      display:flex; align-items:center; justify-content:center;
      font-size: clamp(34px, 10vw, 64px); user-select:none;
    }
    .front{
      background:
        radial-gradient(200px 160px at 20% 20%, rgba(255,255,255,.35) 0 40%, transparent 41%),
        linear-gradient(145deg, var(--cardFrontFrom), var(--cardFrontTo));
      color:#fff; border: 3px solid rgba(255,255,255,.5);
      position:relative; overflow:hidden;
    }
    .front::after{
      content:"";
      position:absolute; inset:-40% -40%;
      background: linear-gradient(120deg, transparent 45%, rgba(255,255,255,.55) 50%, transparent 55%);
      transform: translateX(-60%) rotate(12deg);
      animation: shine 2.4s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes shine{
      0%{ transform: translateX(-70%) rotate(12deg); }
      100%{ transform: translateX(70%) rotate(12deg); }
    }
    .front .gift{ filter: drop-shadow(0 8px 12px rgba(0,0,0,.18)); transform: translateZ(1px); }
    .back{
      background:
        radial-gradient(140px 120px at 80% 20%, rgba(255,255,255,.35) 0 40%, transparent 41%),
        linear-gradient(145deg, var(--cardBackFrom), var(--cardBackTo));
      color:#222; border: 3px solid rgba(255,255,255,.7);
      transform: rotateY(180deg);
    }
    .back::before{
      content:"";
      position:absolute; inset:-30% -30%;
      background:
        conic-gradient(from 0deg, rgba(255,255,255,.25), transparent 30%, rgba(255,255,255,.25) 60%, transparent 90%, rgba(255,255,255,.25));
      mix-blend-mode: overlay; opacity:.45; animation: spin 6s linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }
    .flipped{ transform: rotateY(180deg) scale(1.04); box-shadow: 0 12px 26px rgba(96,165,250,.35); }
    .matched{
      animation: pop .45s ease-out;
      box-shadow: 0 0 0 0 rgba(110,231,165,.0), 0 0 0 0 rgba(110,231,165,.0), var(--shadow);
    }
    .matched .back{ box-shadow: inset 0 0 0 3px rgba(110,231,165,.85), inset 0 0 18px rgba(110,231,165,.55); }
    @keyframes pop{
      0%{ transform: rotateY(180deg) scale(1); }
      50%{ transform: rotateY(180deg) scale(1.12); }
      100%{ transform: rotateY(180deg) scale(1.04); }
    }
    .shake{ animation: shake .28s ease-in-out; }
    @keyframes shake{
      0%,100%{ transform: rotateY(180deg) translateX(0); }
      25%{ transform: rotateY(180deg) translateX(-6px); }
      50%{ transform: rotateY(180deg) translateX(6px); }
      75%{ transform: rotateY(180deg) translateX(-4px); }
    }
    /* Particle burst */
    .burst{
      position: fixed; left:0; top:0; pointer-events:none; width:0; height:0; z-index: 5;
    }
    .burst i{
      position:absolute; font-size: clamp(16px, 4vw, 22px); will-change: transform, opacity;
      animation: burst-move .8s ease-out forwards;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,.2));
    }
    @keyframes burst-move{
      0%{ transform: translate(0,0) scale(1); opacity:1; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0.9); opacity:0; }
    }
    /* Win overlay */
    .overlay{
      position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.75); backdrop-filter: blur(6px);
      z-index: 10; visibility:hidden; opacity:0; transition: opacity .25s ease, visibility .25s ease;
    }
    .overlay.show{ visibility: visible; opacity:1; }
    .modal{
      background:#fff; border-radius: 22px; padding: 24px; width:min(92vw, 520px);
      box-shadow: 0 16px 40px rgba(0,0,0,.15); text-align:center;
    }
    .modal h2{ margin: 8px 0 4px; font-size: clamp(24px, 6vw, 36px); }
    .modal p{ margin: 6px 0 16px; font-size: clamp(16px, 4.5vw, 18px); }
    .trophy{ font-size: clamp(40px, 14vw, 72px); display:block; }
    .mini{ font-size: 14px; opacity:.7; }
    /* Confetti rain */
    .confetti{ position: fixed; inset:0; pointer-events:none; overflow:hidden; z-index:9; }
    .confetti span{
      position:absolute; top:-10vh; will-change: transform, opacity;
      animation: fall var(--dur) linear forwards, sway 2.2s ease-in-out infinite;
      font-size: clamp(16px, 3.8vw, 22px);
    }
    @keyframes fall{ to{ transform: translateY(110vh) rotate(360deg); opacity:1; } }
    @keyframes sway{
      0%,100%{ transform: translateX(0); }
      50%{ transform: translateX(var(--sx)); }
    }
    /* Accessibility */
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip: rect(0,0,0,0); border:0; }
    @media (prefers-reduced-motion: reduce){
      .card, .matched, .shake, .confetti span, .burst i{ animation: none !important; transition: none !important; }
      body::before{ animation: none; }
      .front::after{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Memory Match</h1>
    <div class="subtitle">Find all the happy pairs!</div>
    <div class="topbar">
      <div class="badge" aria-live="polite">Pairs found: <strong id="found">0</strong>/8</div>
      <button id="restart" class="btn" type="button" aria-label="Restart game">Restart 🔄</button>
      <button id="soundToggle" class="iconbtn" type="button" aria-label="Toggle sound" aria-pressed="true" title="Sound on">🔊</button>
      <button id="vibeToggle" class="iconbtn" type="button" aria-label="Toggle vibration" aria-pressed="true" title="Vibration on">📳</button>
    </div>
    <div class="grid" id="grid" role="grid" aria-label="Memory cards grid"></div>
  </div>

  <div id="win" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-labelledby="winTitle" aria-describedby="winDesc">
      <span class="trophy">🏆🎉</span>
      <h2 id="winTitle">Hooray! You did it!</h2>
      <p id="winDesc">You found all the pairs. Great memory!</p>
      <button class="btn secondary" id="playAgain" type="button">Play Again ▶️</button>
      <div class="mini">Tip: Try to beat your last run!</div>
    </div>
  </div>

  <div id="confetti" class="confetti" aria-hidden="true"></div>
  <div id="live" class="sr-only" aria-live="polite"></div>

  <script>
    (() => {
      // Game constants
      const EMOJIS = ['🐶','🐱','🦊','🐻','🐼','🐵','🦄','🐸'];
      const PAIR_COUNT = 8;

      // Elements
      const grid = document.getElementById('grid');
      const foundEl = document.getElementById('found');
      const restartBtn = document.getElementById('restart');
      const overlay = document.getElementById('win');
      const playAgainBtn = document.getElementById('playAgain');
      const confettiBox = document.getElementById('confetti');
      const live = document.getElementById('live');
      const soundToggle = document.getElementById('soundToggle');
      const vibeToggle = document.getElementById('vibeToggle');

      // State
      let tiles = [];
      let first = null;
      let second = null;
      let lock = false;
      let found = 0;

      // Settings
      const storage = {
        get(key, def){ try{ const v = localStorage.getItem(key); return v === null ? def : JSON.parse(v); }catch(_){ return def; } },
        set(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch(_){} }
      };
      let soundEnabled = storage.get('mm_sound', true);
      let vibesEnabled = storage.get('mm_vibes', true);
      soundToggle.setAttribute('aria-pressed', soundEnabled ? 'true' : 'false');
      soundToggle.textContent = soundEnabled ? '🔊' : '🔈';
      soundToggle.title = soundEnabled ? 'Sound on' : 'Sound off';
      vibeToggle.setAttribute('aria-pressed', vibesEnabled ? 'true' : 'false');
      vibeToggle.textContent = vibesEnabled ? '📳' : '🔕';
      vibeToggle.title = vibesEnabled ? 'Vibration on' : 'Vibration off';

      // Audio (WebAudio lightweight synth)
      const Sfx = (() => {
        let ctx = null, master = null;
        const ensure = async () => {
          if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            master = ctx.createGain();
            master.gain.value = 0.25;
            master.connect(ctx.destination);
          }
          if (ctx.state === 'suspended') {
            try { await ctx.resume(); } catch(_) {}
          }
        };
        const now = () => ctx ? ctx.currentTime : 0;
        const tone = (freq=440, dur=0.15, type='sine', volume=0.7, attack=0.01, release=0.08, pan=0) => {
          if(!soundEnabled) return;
          if(!ctx) return;
          const t0 = now()+0.001;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const p = ctx.createStereoPanner ? ctx.createStereoPanner() : null;
          osc.type = type;
          osc.frequency.setValueAtTime(freq, t0);
          gain.gain.setValueAtTime(0, t0);
          gain.gain.linearRampToValueAtTime(volume, t0 + attack);
          gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur + release);
          if(p){ p.pan.value = pan; osc.connect(gain); gain.connect(p); p.connect(master); }
          else { osc.connect(gain); gain.connect(master); }
          osc.start(t0);
          osc.stop(t0 + dur + release + 0.02);
        };
        const chord = (freqs=[], dur=0.25, type='sine') => {
          const spread = 0.5;
          freqs.forEach((f, i) => tone(f, dur, type, 0.5/freqs.length, 0.01, 0.12, (i - (freqs.length-1)/2) * spread));
        };
        const seq = async (notes=[]) => {
          if(!soundEnabled) return;
          if(!ctx) return;
          let t = now();
          for(const n of notes){
            const startAt = n.wait ? t + n.wait : t;
            const s = startAt - now();
            if(s > 0) await new Promise(r => setTimeout(r, s*1000));
            if(n.type === 'chord') chord(n.freqs, n.dur, n.wave || 'sine');
            else tone(n.freq || 440, n.dur || 0.1, n.wave || 'sine', n.vol || 0.6, 0.01, 0.1, n.pan || 0);
            t = startAt + (n.dur || 0.1);
          }
        };
        return {
          ensure,
          flip(){ tone(640, 0.06, 'triangle', 0.4); setTimeout(()=>tone(820, 0.05, 'triangle', 0.35), 40); },
          match(){ chord([660, 880, 1108], 0.22, 'sine'); setTimeout(()=> chord([880, 1108, 1320], 0.22, 'triangle'), 160); },
          mismatch(){
            tone(220, 0.12, 'sawtooth', 0.3);
            setTimeout(()=>tone(170, 0.14, 'sawtooth', 0.25), 80);
          },
          win(){
            seq([
              {type:'note', freq:740, dur:.12, wave:'triangle'},
              {wait:.05, type:'note', freq:880, dur:.12, wave:'triangle'},
              {wait:.05, type:'note', freq:988, dur:.15, wave:'triangle'},
              {wait:.05, type:'chord', freqs:[660,880,1108], dur:.28, wave:'sine'}
            ]);
          },
          start(){ tone(520, .08, 'sine', .35); setTimeout(()=>tone(640, .08, 'sine', .35), 60); }
        };
      })();

      // Helpers
      function shuffle(arr){
        for(let i = arr.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function createCard(sym, idx){
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('role', 'gridcell');

        const card = document.createElement('div');
        card.className = 'card';
        card.tabIndex = 0;
        card.setAttribute('role', 'button');
        card.setAttribute('aria-label', 'Hidden card');
        card.dataset.index = idx;

        const front = document.createElement('div');
        front.className = 'face front';
        const frontSpan = document.createElement('span');
        frontSpan.textContent = '🎁';
        frontSpan.className = 'gift';
        front.appendChild(frontSpan);

        const back = document.createElement('div');
        back.className = 'face back';
        back.textContent = sym;

        card.appendChild(front);
        card.appendChild(back);
        tile.appendChild(card);
        return tile;
      }

      function announce(msg){
        live.textContent = '';
        requestAnimationFrame(() => { live.textContent = msg; });
      }

      function burstAt(x, y){
        const emojis = ['✨','💖','🎉','⭐️','🎈','💫'];
        const count = 14;
        const box = document.createElement('div');
        box.className = 'burst';
        box.style.left = x + 'px';
        box.style.top = y + 'px';
        for(let i=0;i<count;i++){
          const p = document.createElement('i');
          p.textContent = emojis[Math.floor(Math.random()*emojis.length)];
          const a = (Math.random() * Math.PI * 2);
          const dist = 48 + Math.random()*58;
          const dx = Math.cos(a) * dist;
          const dy = Math.sin(a) * dist;
          p.style.setProperty('--dx', dx + 'px');
          p.style.setProperty('--dy', dy + 'px');
          p.style.transform = 'translate(0,0)';
          box.appendChild(p);
        }
        document.body.appendChild(box);
        setTimeout(()=> box.remove(), 900);
      }

      function rainConfetti(){
        confettiBox.innerHTML = '';
        const pieces = 60;
        const icons = ['🎉','✨','🎊','💫','🌟','🎈'];
        for(let i=0;i<pieces;i++){
          const s = document.createElement('span');
          s.textContent = icons[i % icons.length];
          s.style.left = Math.random()*100 + 'vw';
          s.style.setProperty('--dur', (6 + Math.random()*3.5) + 's');
          s.style.setProperty('--sx', (Math.random() < .5 ? '-' : '') + (5 + Math.random()*18) + 'vw');
          s.style.opacity = Math.random() * .6 + .4;
          confettiBox.appendChild(s);
        }
        setTimeout(() => { confettiBox.innerHTML = ''; }, 9500);
      }

      function vibrate(pattern){
        if(vibesEnabled && navigator.vibrate) navigator.vibrate(pattern);
      }

      function resetPick(){ first = null; second = null; lock = false; }

      function check(){
        lock = true;
        if(first.sym === second.sym){
          tiles[first.idx].matched = tiles[second.idx].matched = true;
          const c1 = first.el, c2 = second.el;
          c1.classList.add('matched');
          c2.classList.add('matched');
          found++;
          foundEl.textContent = found;
          announce('Match found!');
          Sfx.match();

          // Particle burst at midpoint between two cards
          const r1 = c1.getBoundingClientRect();
          const r2 = c2.getBoundingClientRect();
          const mx = (r1.left + r1.right + r2.left + r2.right)/4;
          const my = (r1.top + r1.bottom + r2.top + r2.bottom)/4;
          burstAt(mx, my);
          vibrate([20, 40, 20]);

          setTimeout(() => {
            resetPick();
            if(found === PAIR_COUNT){
              setTimeout(() => showWin(), 320);
            }
          }, 350);
        } else {
          // Wiggle animation for mismatch
          first.el.classList.add('shake');
          second.el.classList.add('shake');
          vibrate(60);
          Sfx.mismatch();
          setTimeout(() => {
            first.el.classList.remove('flipped','shake');
            second.el.classList.remove('flipped','shake');
            resetPick();
          }, 650);
        }
      }

      function flip(card){
        if(lock) return;
        const idx = +card.dataset.index;
        const t = tiles[idx];
        if(t.matched) return;
        if(card.classList.contains('flipped')) return;

        card.classList.add('flipped');
        Sfx.flip();

        if(!first){
          first = { idx, sym: t.sym, el: card };
          return;
        }
        if(first && first.idx === idx) return;

        second = { idx, sym: t.sym, el: card };
        check();
      }

      function onGridActivate(e){
        // Pointer/touch/click activation
        const target = e.target;
        const card = target && target.closest ? target.closest('.card') : null;
        if(!card || !grid.contains(card)) return;
        flip(card);
      }

      function onGridKey(e){
        const card = e.target.closest('.card');
        if(!card) return;
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          flip(card);
        }
      }

      function showWin(){
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
        rainConfetti();
        Sfx.win();
        announce('You win! All pairs matched.');
      }

      function hideWin(){
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
      }

      function init(){
        hideWin();
        found = 0;
        foundEl.textContent = found;
        grid.innerHTML = '';
        first = second = null; lock = false;

        const set = shuffle([...EMOJIS, ...EMOJIS]);
        tiles = set.map(sym => ({ sym, matched:false }));

        const frag = document.createDocumentFragment();
        tiles.forEach((t, idx) => {
          const el = createCard(t.sym, idx);
          frag.appendChild(el);
        });
        grid.appendChild(frag);
        announce('New game. Find all the pairs!');
        Sfx.start();
      }

      // Toggle handlers
      soundToggle.addEventListener('click', async () => {
        // Ensure audio context is created on first interaction
        await Sfx.ensure();
        soundEnabled = !soundEnabled;
        storage.set('mm_sound', soundEnabled);
        soundToggle.setAttribute('aria-pressed', soundEnabled ? 'true' : 'false');
        soundToggle.textContent = soundEnabled ? '🔊' : '🔈';
        soundToggle.title = soundEnabled ? 'Sound on' : 'Sound off';
        if(soundEnabled) Sfx.start();
      }, { passive: true });

      vibeToggle.addEventListener('click', () => {
        vibesEnabled = !vibesEnabled;
        storage.set('mm_vibes', vibesEnabled);
        vibeToggle.setAttribute('aria-pressed', vibesEnabled ? 'true' : 'false');
        vibeToggle.textContent = vibesEnabled ? '📳' : '🔕';
        vibeToggle.title = vibesEnabled ? 'Vibration on' : 'Vibration off';
        if(vibesEnabled) vibrate(30);
      }, { passive: true });

      // Ensure AudioContext resumes on first user interaction (mobile autoplay policy)
      const resumeAudioOnFirstInteract = async () => {
        document.removeEventListener('pointerdown', resumeAudioOnFirstInteract);
        document.removeEventListener('keydown', resumeAudioOnFirstInteract);
        await Sfx.ensure();
      };
      document.addEventListener('pointerdown', resumeAudioOnFirstInteract, { passive: true, once: true });
      document.addEventListener('keydown', resumeAudioOnFirstInteract, { once: true });

      // Events
      grid.addEventListener('pointerup', onGridActivate, { passive: true });
      grid.addEventListener('keydown', onGridKey);
      restartBtn.addEventListener('click', () => { vibrate(20); init(); });
      playAgainBtn.addEventListener('click', () => { vibrate(20); init(); });
      // Optional: close overlay on background tap
      overlay.addEventListener('click', (e) => {
        if(e.target === overlay) init();
      });

      // Start game
      init();
    })();
  </script>
</body>
</html>