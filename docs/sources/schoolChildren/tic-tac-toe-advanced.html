<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Ticâ€‘Tacâ€‘Toe Advanced</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
:root{
  --bg: #fffbeb; /* Sunny Yellow */
  --board-bg: #a7f3d0; /* Mint Green */
  --cell-bg: #f0fdf4; /* Lighter Mint */
  --text: #881337; /* Burgundy */
  --accent: #fb923c; /* Orange */
  --x: #f54291; /* Intense Pink */
  --o: #2563eb; /* Intense Blue */
  --win: #22c55e; /* Bright Green */
  --cell:clamp(72px, 22vw, 120px);
  --gap:clamp(8px, 2.2vw, 14px);
  --radius: 20px;
  --shadow:0 10px 25px rgba(0,0,0,.1);
}

*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{
  font-family: 'Fredoka One', cursive;
  color: var(--text);
  background-color: var(--bg);
  min-height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  -webkit-tap-highlight-color: transparent;
}

.container{
  width: min(100vw, 520px);
  padding: clamp(10px, 3vw, 20px);
}

.card{
  background: #ffffffd9;
  border:1px solid rgba(0,0,0,.05);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  backdrop-filter: blur(8px);
  padding: clamp(12px, 2.5vw, 18px);
}

.header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom: clamp(8px, 1.8vw, 14px);
}

.title{
  font-weight:400;
  letter-spacing:.5px;
  font-size: clamp(18px, 5vw, 22px);
  display:flex;
  align-items:center;
  gap:.6ch;
}
.title .badge{
  font-size:.85em;
  font-weight:400;
  color: white;
  background: var(--text); /* Burgundy */
  padding:.25rem .6rem;
  border-radius:999px;
}

.controls{
  display:flex;
  gap:8px;
}

.icon-btn{
  appearance:none;
  border:1px solid rgba(0,0,0,.1);
  background: white;
  color: var(--text);
  border-radius:12px;
  padding:.55rem .7rem;
  font-weight:400;
  cursor:pointer;
  transition: transform .12s ease, box-shadow .12s ease;
  box-shadow: 0 4px 14px rgba(0,0,0,.08);
}
.icon-btn:hover{ transform: translateY(-1px); }
.icon-btn:active{ transform: translateY(0); }
.icon-btn[aria-pressed="true"]{
  background-color: var(--text); /* Burgundy */
  color: white;
}

.board{
  display:grid;
  grid-template-columns: repeat(3, var(--cell));
  gap: var(--gap);
  background: var(--board-bg);
  border:1px solid rgba(0,0,0,.05);
  border-radius: clamp(12px, 3vw, 18px);
  padding: var(--gap);
  justify-content:center;
  align-content:center;
  box-shadow: var(--shadow);
  position:relative;
}

.cell{
  width: var(--cell);
  aspect-ratio: 1/1;
  border-radius: clamp(10px, 2.2vw, 14px);
  border: none;
  background: var(--cell-bg);
  color:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: clamp(42px, 12vw, 64px);
  font-weight: 400;
  cursor:pointer;
  user-select:none;
  position:relative;
  box-shadow: inset 0 4px 10px rgba(0,0,0,.1);
  transition: transform .12s ease;
  outline: none;
}
.cell:hover{ transform: scale(1.05); }
.cell:active{ transform: scale(0.98); }
.cell:focus-visible{
  box-shadow: 0 0 0 4px var(--bg), 0 0 0 8px var(--accent);
}

.cell.filled{
  cursor: default;
  transform: none;
}

.cell.mark-x{ color: var(--x); text-shadow: 2px 2px 0px #fff, 4px 4px 0px rgba(244, 114, 182, 0.3); }
.cell.mark-o{ color: var(--o); text-shadow: 2px 2px 0px #fff, 4px 4px 0px rgba(96, 165, 250, 0.3); }

.cell.pop{
  animation: pop .22s ease-out both;
}

.cell.shake{
  animation: shake .28s ease-in-out;
}

.cell.winning{
  background-color: var(--win);
  color: white !important;
  text-shadow: none !important;
}

.status{
  margin-top: clamp(10px, 2.2vw, 14px);
  text-align:center;
  font-weight:400;
  letter-spacing:.4px;
  font-size: clamp(16px, 4.4vw, 18px);
  min-height: 1.6em;
}

footer{
  margin-top: 8px;
  text-align:center;
  font-size: 12px;
  opacity:.8;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
}

/* Animations */
@keyframes pop{
  0%{ transform: scale(.6); opacity:.4; }
  100%{ transform: scale(1); opacity:1; }
}
@keyframes shake{
  0%,100%{ transform: translateX(0) }
  20%{ transform: translateX(-4px) }
  40%{ transform: translateX(4px) }
  60%{ transform: translateX(-3px) }
  80%{ transform: translateX(3px) }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  *{animation: none !important; transition: none !important}
}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="header">
      <div class="title">Ticâ€‘Tacâ€‘Toe <span class="badge">VS AI</span></div>
      <div class="controls">
        <button id="muteBtn" class="icon-btn" type="button" aria-pressed="false" title="Toggle sound">ðŸ”Š</button>
        <button id="resetBtn" class="icon-btn" type="button" title="Reset game">â†» Reset</button>
      </div>
    </div>

    <div id="board" class="board" role="grid" aria-label="Tic Tac Toe board"></div>
    <div id="status" class="status" role="status" aria-live="polite">Your turn</div>
  </div>
  <footer><strong>Tip:</strong> Tap a square. Green glow highlights the winning line.</footer>
</div>

<script>
(() => {
  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const resetBtn = document.getElementById('resetBtn');
  const muteBtn = document.getElementById('muteBtn');

  // Game state
  let board = Array(9).fill('');
  const HUMAN = 'X';
  const AI = 'O';
  let gameOver = false;
  let lastMoveIndex = -1;
  let winningLine = null;

  // Precompute winning lines
  const LINES = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];

  // Audio (WebAudio)
  let audioCtx = null;
  let muted = false;

  function ensureAudio() {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) audioCtx = new Ctx();
    }
  }

  function resumeAudioIfSuspended() {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone({freq=440, type='sine', duration=0.08, gain=0.08, when=0}) {
    if (muted || !audioCtx) return;
    const now = audioCtx.currentTime + when;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(gain, now + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + duration + 0.02);
  }

  function sfxPlace(isHuman) {
    if (!audioCtx) return;
    if (isHuman) {
      playTone({freq: 680, type:'triangle', duration: 0.07, gain: 0.08});
      playTone({freq: 980, type:'triangle', duration: 0.06, gain: 0.06, when: 0.02});
    } else {
      playTone({freq: 420, type:'sine', duration: 0.07, gain: 0.08});
      playTone({freq: 380, type:'sine', duration: 0.06, gain: 0.06, when: 0.02});
    }
  }

  function sfxWin() {
    if (!audioCtx) return;
    playTone({freq: 523.25, type:'square', duration: 0.09, gain: 0.09});
    playTone({freq: 659.25, type:'square', duration: 0.11, gain: 0.09, when: 0.06});
    playTone({freq: 783.99, type:'square', duration: 0.13, gain: 0.09, when: 0.14});
  }

  function sfxDraw() {
    if (!audioCtx) return;
    playTone({freq: 660, type:'sine', duration: 0.05, gain: 0.06});
    playTone({freq: 600, type:'sine', duration: 0.05, gain: 0.06, when: 0.05});
    playTone({freq: 540, type:'sine', duration: 0.05, gain: 0.06, when: 0.1});
  }

  function sfxError() {
    if (!audioCtx) return;
    playTone({freq: 180, type:'sawtooth', duration: 0.08, gain: 0.08});
    playTone({freq: 140, type:'sawtooth', duration: 0.08, gain: 0.08, when: 0.05});
  }

  function vibrate(pattern) {
    if (navigator.vibrate) {
      try { navigator.vibrate(pattern); } catch {}
    }
  }

  // Create cells once (for performance and better focus/ARIA)
  const cells = [];
  function initBoard() {
    boardEl.innerHTML = '';
    for (let i = 0; i < 9; i++) {
      const btn = document.createElement('button');
      btn.className = 'cell';
      btn.type = 'button';
      btn.setAttribute('role', 'gridcell');
      btn.setAttribute('aria-label', 'Empty');
      btn.dataset.index = i;
      btn.textContent = '';
      cells.push(btn);
      boardEl.appendChild(btn);
    }
  }

  function getWinner(b) {
    for (const [a, c, d] of LINES) {
      if (b[a] && b[a] === b[c] && b[c] === b[d]) {
        return { winner: b[a], line: [a,c,d] };
      }
    }
    if (b.every(Boolean)) return { winner: 'D', line: null };
    return { winner: null, line: null };
  }

  function renderCell(i, animate=false) {
    const c = cells[i];
    const v = board[i];
    c.classList.remove('mark-x','mark-o','filled','pop','winning');
    c.textContent = v || '';
    if (v) {
      c.classList.add('filled', v === 'X' ? 'mark-x' : 'mark-o');
      c.setAttribute('aria-label', v === 'X' ? 'X' : 'O');
      if (animate) {
        c.classList.add('pop');
      }
    } else {
      c.setAttribute('aria-label', 'Empty');
    }
  }

  function renderBoard(animateIndex=-1) {
    for (let i = 0; i < 9; i++) {
      renderCell(i, i === animateIndex);
    }
    // Highlight winning line if exists
    if (winningLine) {
      winningLine.forEach(idx => cells[idx].classList.add('winning'));
    }
  }

  function setStatus(text) {
    statusEl.textContent = text;
  }

  function isMoveAllowed(i) {
    return !gameOver && !board[i];
  }

  function handleHumanMove(i, targetEl) {
    if (!isMoveAllowed(i)) {
      if (targetEl) {
        targetEl.classList.remove('shake');
        // reflow trick to restart animation
        void targetEl.offsetWidth;
        targetEl.classList.add('shake');
      }
      sfxError();
      return;
    }
    board[i] = HUMAN;
    lastMoveIndex = i;
    sfxPlace(true);
    vibrate(10);

    const { winner, line } = getWinner(board);
    winningLine = line;
    renderBoard(i);

    if (winner) {
      finish(winner);
      return;
    }

    setStatus("AI is thinking...");
    // Slight delay for natural feel
    setTimeout(aiMove, 280);
  }

  function aiMove() {
    if (gameOver) return;
    const moveIndex = findBestMove(board);
    if (moveIndex != null) {
      board[moveIndex] = AI;
      lastMoveIndex = moveIndex;
      sfxPlace(false);
      const result = getWinner(board);
      winningLine = result.line;
      renderBoard(moveIndex);

      if (result.winner) {
        finish(result.winner);
      } else {
        setStatus("Your turn");
      }
    }
  }

  function finish(result) {
    gameOver = true;
    if (result === 'D') {
      setStatus("It's a draw");
      sfxDraw();
      vibrate([20,40,20]);
    } else {
      const winnerName = result === HUMAN ? 'You win!' : 'AI wins!';
      setStatus(winnerName);
      sfxWin();
      vibrate([30, 60, 30]);
    }
    // Keep the board for a moment, then reset automatically
    setTimeout(reset, 1400);
  }

  function reset() {
    board = Array(9).fill('');
    gameOver = false;
    lastMoveIndex = -1;
    winningLine = null;
    setStatus("Your turn");
    renderBoard();
  }

  // Minimax with alpha-beta pruning
  function findBestMove(b) {
    let bestScore = -Infinity;
    let bestIndex = null;
    for (let i = 0; i < 9; i++) {
      if (!b[i]) {
        b[i] = AI;
        const score = minimax(b, false, -Infinity, Infinity);
        b[i] = '';
        if (score > bestScore) {
          bestScore = score;
          bestIndex = i;
        }
      }
    }
    return bestIndex;
  }

  function minimax(boardState, isMaximizing, alpha, beta) {
    const { winner } = getWinner(boardState);
    if (winner) {
      if (winner === AI) return 1;
      if (winner === HUMAN) return -1;
      return 0;
    }

    if (isMaximizing) {
      let best = -Infinity;
      for (let i = 0; i < 9; i++) {
        if (!boardState[i]) {
          boardState[i] = AI;
          best = Math.max(best, minimax(boardState, false, alpha, beta));
          boardState[i] = '';
          alpha = Math.max(alpha, best);
          if (beta <= alpha) break;
        }
      }
      return best;
    } else {
      let best = Infinity;
      for (let i = 0; i < 9; i++) {
        if (!boardState[i]) {
          boardState[i] = HUMAN;
          best = Math.min(best, minimax(boardState, true, alpha, beta));
          boardState[i] = '';
          beta = Math.min(beta, best);
          if (beta <= alpha) break;
        }
      }
      return best;
    }
  }

  // Event listeners (pointer for touch + mouse)
  boardEl.addEventListener('pointerdown', (e) => {
    ensureAudio();
    resumeAudioIfSuspended();
    const target = e.target.closest('.cell');
    if (!target) return;
    const idx = Number(target.dataset.index);
    handleHumanMove(idx, target);
  }, { passive: true });

  // Keyboard support (optional)
  boardEl.addEventListener('keydown', (e) => {
    const target = e.target.closest('.cell');
    if (!target) return;
    const idx = Number(target.dataset.index);
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      ensureAudio();
      resumeAudioIfSuspended();
      handleHumanMove(idx, target);
    }
  });

  // Controls
  resetBtn.addEventListener('click', () => {
    ensureAudio();
    resumeAudioIfSuspended();
    reset();
  });

  muteBtn.addEventListener('click', () => {
    ensureAudio();
    resumeAudioIfSuspended();
    muted = !muted;
    muteBtn.setAttribute('aria-pressed', String(muted));
    muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
  });

  // Kickoff
  initBoard();
  renderBoard();
})();
</script>
</body>
</html>