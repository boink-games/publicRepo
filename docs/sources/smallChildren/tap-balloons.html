<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pop the Balloons</title>
  <style>
    :root{
      --bg1:#b8e8ff;
      --bg2:#e9f7ff;
      --fg:#09395b;
      --ui:#ffffffdd;
      --uiText:#08324d;
      --accent:#ff7ab6;
      --btn:#ffffffee;
      --shadow:0 10px 24px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color: transparent}
    html,body{height:100%;margin:0}
    body{
      font-family: ui-rounded, "SF Pro Rounded", system-ui, -apple-system, Segoe UI, Roboto, "Noto Color Emoji", emoji, sans-serif;
      color:var(--fg);
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      overflow:hidden;
    }
    .wrap{position:relative;height:100%;width:100%;overflow:hidden}
    header{
      position:absolute;inset:0 0 auto 0;display:flex;align-items:center;justify-content:space-between;
      padding:12px 14px;z-index:3;pointer-events:none;
    }
    .hud-left,.hud-right{display:flex;gap:10px;align-items:center;pointer-events:auto}
    .pill{
      display:flex;align-items:center;gap:8px;background:var(--ui);color:var(--uiText);
      padding:8px 12px;border-radius:999px;box-shadow:var(--shadow);font-weight:800;letter-spacing:.3px;
      user-select:none;touch-action:none
    }
    .pill svg{width:22px;height:22px;flex:0 0 auto}
    .icon-btn{
      background:var(--btn);border:none;border-radius:16px;padding:10px;box-shadow:var(--shadow);
      display:grid;place-items:center;color:var(--uiText)
    }
    .icon-btn svg{width:24px;height:24px;display:block}
    .icon-btn:active{transform:scale(.96)}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none}
    .toast{
      position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:#ffffffee;color:#0b466c;
      padding:10px 14px;border-radius:999px;font-weight:700;display:flex;gap:8px;align-items:center;
      box-shadow:var(--shadow);z-index:2;animation:popin .4s ease both, fadeout 1s ease 4s forwards
    }
    .toast svg{width:18px;height:18px}
    @keyframes popin{from{transform:translateX(-50%) scale(.8);opacity:0}to{transform:translateX(-50%) scale(1);opacity:1}}
    @keyframes fadeout{to{opacity:0;transform:translateX(-50%) translateY(6px)}}
    @media (min-width:768px){
      header{padding:14px 18px}
      .icon-btn svg{width:26px;height:26px}
      .pill{padding:10px 14px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="hud-left">
        <div class="pill" aria-live="polite" aria-atomic="true" role="status" id="scorePill" title="Score">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="#f6b100" d="M12 2.5l2.6 5.3 5.8.8-4.2 4.1 1 5.8L12 16.8l-5.2 2.7 1-5.8L3.6 8.6l5.8-.8L12 2.5z"/></svg>
          <span id="score">0</span>
        </div>
      </div>
      <div class="hud-right">
        <button class="icon-btn" id="sound" aria-label="Sound on">
          <svg id="icon-sound-on" viewBox="0 0 24 24" aria-hidden="true"><path fill="#0b466c" d="M4 9v6h3l4 3V6L7 9H4z"/><path fill="#0b466c" d="M16.5 12a3.5 3.5 0 0 0-2.1-3.2v6.4a3.5 3.5 0 0 0 2.1-3.2z"/><path fill="#0b466c" d="M18 4.6v2.1A7.3 7.3 0 0 1 20.9 12 7.3 7.3 0 0 1 18 17.3v2.1A9.4 9.4 0 0 0 23 12 9.4 9.4 0 0 0 18 4.6z"/></svg>
          <svg id="icon-sound-off" viewBox="0 0 24 24" aria-hidden="true" style="display:none"><path fill="#0b466c" d="M4 9v6h3l4 3V6L7 9H4z"/><path fill="#0b466c" d="M21 7.3 19.7 6 16 9.7 12.3 6 11 7.3 14.7 11 11 14.7 12.3 16 16 12.3 19.7 16 21 14.7 17.3 11 21 7.3z"/></svg>
        </button>
        <button class="icon-btn" id="restart" aria-label="Restart">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="#0b466c" d="M12 5a7 7 0 1 1-6.7 9H7l-3-4-3 4h1.8A9 9 0 1 0 12 3v2z"/></svg>
        </button>
      </div>
    </header>
    <canvas id="game"></canvas>
    <div class="toast" id="tip">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="#0b466c" d="M12 2a7 7 0 0 0-7 7c0 2.6 1.7 4.8 4 6v3a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3c2.3-1.2 4-3.4 4-6a7 7 0 0 0-7-7z"/></svg>
      Tap balloons! 🎈
    </div>
  </div>
  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      const scoreEl = document.getElementById('score');
      const restartBtn = document.getElementById('restart');
      const soundBtn = document.getElementById('sound');
      const iconSoundOn = document.getElementById('icon-sound-on');
      const iconSoundOff = document.getElementById('icon-sound-off');
      const tip = document.getElementById('tip');

      let DPR = Math.min(2, window.devicePixelRatio || 1);
      let W = 0, H = 0, running = true, lastTime = 0, score = 0;
      let balloons = [];
      let particles = [];
      let floaters = [];
      let clouds = [];
      let SOUND = true;

      // Color palette (soft, friendly)
      const COLORS = [
        { name:'RED', val:'#ff6b6b' },
        { name:'ORANGE', val:'#ff9f43' },
        { name:'YELLOW', val:'#ffd93d' },
        { name:'GREEN', val:'#2ecc71' },
        { name:'TEAL', val:'#1dd1a1' },
        { name:'BLUE', val:'#54a0ff' },
        { name:'INDIGO', val:'#5f77ff' },
        { name:'PURPLE', val:'#a66bff' },
        { name:'PINK', val:'#ff89c6' },
        { name:'MINT', val:'#7ef2c7' },
        { name:'CORAL', val:'#ff7f50' }
      ];

      // Audio (simple chime)
      let audioCtx = null;
      function ensureAudio() {
        if (!SOUND) return;
        try {
          if (!audioCtx) {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (Ctx) audioCtx = new Ctx();
          } else if (audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
        } catch(_) {}
      }
      function playPopChime() {
        if (!SOUND || !audioCtx) return;
        const now = audioCtx.currentTime;
        const o1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(660, now);
        g1.gain.setValueAtTime(0.001, now);
        g1.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
        o1.connect(g1).connect(audioCtx.destination);
        o1.start(now);
        o1.stop(now + 0.2);

        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = 'triangle';
        o2.frequency.setValueAtTime(990, now + 0.02);
        g2.gain.setValueAtTime(0.001, now + 0.02);
        g2.gain.exponentialRampToValueAtTime(0.12, now + 0.05);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
        o2.connect(g2).connect(audioCtx.destination);
        o2.start(now + 0.02);
        o2.stop(now + 0.24);
      }

      // Utils
      const rand = (a, b) => Math.random() * (b - a) + a;
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      // Canvas sizing with DPR
      function resize() {
        DPR = Math.min(2, window.devicePixelRatio || 1);
        const { clientWidth, clientHeight } = canvas;
        W = Math.floor(clientWidth);
        H = Math.floor(clientHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        // Adjust counts
        const targetCount = Math.round(clamp(W / 130, 6, 14));
        adjustBalloonCount(targetCount);
        if (clouds.length === 0) spawnClouds();
      }
      window.addEventListener('resize', resize, { passive: true });

      // Cloud generation
      function spawnClouds() {
        clouds = [];
        const n = Math.round(clamp(W / 220, 4, 10));
        for (let i = 0; i < n; i++) {
          clouds.push({
            x: rand(-100, W + 100),
            y: rand(20, H * 0.55),
            s: rand(0.6, 1.4),
            v: rand(0.02, 0.05)
          });
        }
      }
      function drawCloud(c) {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.scale(c.s, c.s);
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.beginPath();
        const blobs = [
          {x:0, y:0, r:22},
          {x:18, y:2, r:16},
          {x:-18, y:4, r:16},
          {x:8, y:12, r:18},
          {x:-12, y:12, r:20}
        ];
        blobs.forEach(b => { ctx.moveTo(b.x + b.r, b.y); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); });
        ctx.fill();
        ctx.restore();
      }

      // Balloon sprite cache
      const spriteCache = new Map(); // key: color+r
      function makeBalloonSprite(r, color) {
        const key = color + '|' + Math.round(r);
        if (spriteCache.has(key)) return spriteCache.get(key);
        const rx = r * 0.85, ry = r;
        const w = Math.ceil(rx * 2 + 8);
        const h = Math.ceil(ry * 2 + 14);
        const off = document.createElement('canvas');
        off.width = w * DPR;
        off.height = h * DPR;
        const c = off.getContext('2d');
        c.setTransform(DPR, 0, 0, DPR, 0, 0);
        // body
        const cx = w / 2, cy = ry + 2;
        const grad = c.createRadialGradient(cx - r * 0.35, cy - r * 0.35, r * 0.1, cx, cy, r);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.12, '#ffffff88');
        grad.addColorStop(0.13, color);
        grad.addColorStop(1, color);
        c.fillStyle = grad;
        c.beginPath();
        c.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        c.fill();
        // knot
        c.fillStyle = color;
        c.beginPath();
        c.moveTo(cx - 6, cy + ry * 0.2);
        c.lineTo(cx + 6, cy + ry * 0.2);
        c.lineTo(cx, cy + ry * 0.36);
        c.closePath();
        c.fill();
        // highlight shine
        c.globalAlpha = 0.25;
        c.fillStyle = '#fff';
        c.beginPath();
        c.ellipse(cx - r * 0.35, cy - r * 0.35, rx * 0.25, ry * 0.2, -0.3, 0, Math.PI * 2);
        c.fill();
        c.globalAlpha = 1;
        spriteCache.set(key, { canvas: off, w, h, cx, cy, rx, ry });
        return spriteCache.get(key);
      }

      function spawnBalloon() {
        const base = Math.min(W, H);
        const r = rand(base * 0.035, base * 0.07); // larger on big screens
        const color = COLORS[Math.floor(rand(0, COLORS.length))];
        const sprite = makeBalloonSprite(r, color.val);
        return {
          x: rand(r + 8, W - r - 8),
          y: H + r + rand(0, H * 0.25),
          r, color,
          vy: -rand(10, 24) / 100, // slower for kids
          swayPhase: rand(0, Math.PI * 2),
          swaySpeed: rand(0.6, 1.2),
          swayAmp: rand(6, 14),
          sprite
        };
      }

      function adjustBalloonCount(n) {
        while (balloons.length < n) balloons.push(spawnBalloon());
        while (balloons.length > n) balloons.pop();
      }

      function init() {
        score = 0;
        scoreEl.textContent = score;
        lastTime = performance.now();
        running = true;
        clouds = [];
        spawnClouds();
        balloons = [];
        const targetCount = Math.round(clamp(W / 130, 6, 14));
        for (let i = 0; i < targetCount; i++) balloons.push(spawnBalloon());
        particles = [];
        floaters = [];
        if (tip) {
          tip.style.opacity = '1';
          tip.style.animation = 'popin .4s ease both, fadeout 1s ease 4s forwards';
        }
        loop(lastTime);
      }

      function loop(t) {
        if (!running) return;
        const dt = Math.min(32, t - lastTime);
        lastTime = t;
        update(dt, t);
        draw(t);
        requestAnimationFrame(loop);
      }

      function update(dt, t) {
        // move clouds
        for (const c of clouds) {
          c.x += c.v * dt;
          if (c.x > W + 150) c.x = -150;
        }
        // balloons
        for (const b of balloons) {
          b.y += b.vy * dt;
          b.x += Math.sin((t / 1000) * b.swaySpeed + b.swayPhase) * (b.swayAmp * dt / 16);
          // wrap to bottom when off top (no penalty)
          if (b.y + b.r < -40) {
            const nb = spawnBalloon();
            b.x = nb.x; b.y = nb.y; b.r = nb.r; b.vy = nb.vy;
            b.swayPhase = nb.swayPhase; b.swaySpeed = nb.swaySpeed; b.swayAmp = nb.swayAmp;
            b.color = nb.color; b.sprite = nb.sprite;
          }
          // keep inside sides
          b.x = clamp(b.x, b.r * 0.9, W - b.r * 0.9);
        }
        // particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= dt;
          if (p.life <= 0) { particles.splice(i, 1); continue; }
          p.vy += 0.0004 * dt;
          p.x += p.vx * dt * 0.02;
          p.y += p.vy * dt * 0.02;
          p.rot += p.vr * dt * 0.01;
        }
        // floaters
        for (let i = floaters.length - 1; i >= 0; i--) {
          const f = floaters[i];
          f.life -= dt;
          if (f.life <= 0) { floaters.splice(i, 1); continue; }
          f.y -= 0.03 * dt;
          f.x += Math.sin((t + f.seed) / 200) * 0.05 * dt;
        }
      }

      function draw(t) {
        // Sky background
        const sky = ctx.createLinearGradient(0, 0, 0, H);
        sky.addColorStop(0, '#b8e8ff');
        sky.addColorStop(1, '#e9f7ff');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, W, H);

        // Sun
        const sunX = W * 0.12, sunY = H * 0.12, sunR = Math.min(W, H) * 0.08;
        const sunG = ctx.createRadialGradient(sunX, sunY, 1, sunX, sunY, sunR);
        sunG.addColorStop(0, '#fff7a3');
        sunG.addColorStop(1, 'rgba(255,247,163,0)');
        ctx.fillStyle = sunG;
        ctx.beginPath(); ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2); ctx.fill();

        // Clouds
        for (const c of clouds) drawCloud(c);

        // Balloon strings and sprites
        for (const b of balloons) {
          // string
          ctx.strokeStyle = 'rgba(8,50,77,.35)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(b.x, b.y + b.r * 0.22);
          ctx.lineTo(b.x + Math.sin(t/600 + b.swayPhase) * 8, b.y + b.r + 26);
          ctx.stroke();
          // sprite
          const sp = b.sprite;
          ctx.drawImage(sp.canvas, Math.round(b.x - sp.cx), Math.round(b.y - sp.cy));
        }

        // Particles
        for (const p of particles) {
          const k = p.life / p.max;
          ctx.save();
          ctx.globalAlpha = clamp(k, 0, 1);
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          if (p.shape === 0) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(0, 0, p.size, 0, Math.PI * 2);
            ctx.fill();
          } else if (p.shape === 1) {
            ctx.fillStyle = p.color;
            const s = p.size * 1.2;
            ctx.fillRect(-s/2, -s/2, s, s);
          } else {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            const s = p.size * 1.4;
            ctx.moveTo(-s/2, s/2);
            ctx.lineTo(0, -s/2);
            ctx.lineTo(s/2, s/2);
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }

        // Floaters (emoji/stars)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (const f of floaters) {
          const k = clamp(f.life / f.max, 0, 1);
          ctx.globalAlpha = k;
          ctx.font = `bold ${Math.round(f.size)}px ui-rounded, system-ui, sans-serif`;
          ctx.fillStyle = f.color;
          ctx.fillText(f.text, f.x, f.y);
          ctx.globalAlpha = 1;
        }
      }

      function handleTap(px, py) {
        // Check balloons from top-most -> bottom for natural feel
        for (let i = balloons.length - 1; i >= 0; i--) {
          const b = balloons[i];
          // ellipse hit test
          const dx = px - b.x;
          const dy = py - b.y;
          const ex = b.r * 0.85, ey = b.r;
          if ((dx*dx)/(ex*ex) + (dy*dy)/(ey*ey) <= 1) {
            popAt(i, px, py);
            return;
          }
        }
        // gentle ripple feedback
        addFloater(px, py, '👆', '#0b466c', 800, 22);
      }

      function addFloater(x, y, text, color, life = 800, size = 28) {
        floaters.push({ x, y, text, color, life, max: life, size, seed: Math.random()*999 });
      }

      function popAt(i, px, py) {
        const b = balloons[i];
        score++;
        scoreEl.textContent = score;
        if (navigator.vibrate) { try { navigator.vibrate(10); } catch(_){} }
        // Particles burst
        const parts = Math.floor(rand(14, 20));
        for (let p = 0; p < parts; p++) {
          particles.push({
            x: b.x, y: b.y,
            vx: Math.cos((Math.PI * 2 * p) / parts) * rand(40, 150),
            vy: Math.sin((Math.PI * 2 * p) / parts) * rand(40, 150) - rand(10, 40),
            rot: rand(0, Math.PI*2),
            vr: rand(-0.5, 0.5),
            color: b.color.val,
            life: rand(380, 560),
            max: 560,
            size: rand(2, 4) + b.r * 0.06,
            shape: Math.floor(rand(0, 3))
          });
        }
        // Floater star
        addFloater(b.x, b.y - b.r * 0.3, '⭐️', '#f6b100', 900, clamp(b.r * 0.9, 26, 42));

        ensureAudio();
        playPopChime();

        // Respawn
        balloons[i] = spawnBalloon();
      }

      // Input handling
      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        return { x, y };
      }
      canvas.addEventListener('pointerdown', (e) => {
        ensureAudio();
        const p = getPos(e);
        handleTap(p.x, p.y);
      }, { passive: true });

      // Buttons
      restartBtn.addEventListener('click', () => { init(); }, { passive: true });
      soundBtn.addEventListener('click', () => {
        SOUND = !SOUND;
        soundBtn.setAttribute('aria-label', SOUND ? 'Sound on' : 'Sound off');
        iconSoundOn.style.display = SOUND ? 'block' : 'none';
        iconSoundOff.style.display = SOUND ? 'none' : 'block';
        ensureAudio();
      }, { passive: true });

      // Start
      resize();
      init();
    })();
  </script>
</body>
</html>