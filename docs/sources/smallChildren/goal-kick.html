<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Goal Kick - Kid Friendly</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
  <style>
    :root{
      --sky:#8fd3ff;
      --sky2:#dff5ff;
      --grass:#2ecc71;
      --grass2:#2abf64;
      --field:#1f9e55;
      --net:#ffffffa8;
      --ui:#0b1b2a;
      --ui2:#12314d;
      --pill:#0d253a;
      --pillBorder:#1a4266;
      --glow1:#ffe66d;
      --glow2:#ff9de2;
      --text:#ffffff;
      --shadow:0 6px 24px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--sky);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body{touch-action:none;overscroll-behavior:none}
    canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
    .game-title{
      position:fixed;top:10px;left:50%;
      transform:translateX(-50%) scale(0); /* Initial state for animation */
      z-index:6;
      margin:0;
      font-family: 'Anton', sans-serif;
      font-size: 44px;
      letter-spacing: 1.5px;
      /* Color from the reset button */
      color: #ffb84d;
      /* Cleaner shadow for readability */
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
      animation: title-pop-in 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s forwards; /* Animation */
    }
    @keyframes title-pop-in {
      to {
        transform: translateX(-50%) scale(1);
      }
    }
    .hud{
      position:fixed;top:120px;left:12px;right:12px;display:flex;gap:8px;justify-content:space-between;align-items:center;pointer-events:none;z-index:5
    }
    .instructions{
      position:fixed;top:62px;left:50%;transform:translateX(-50%);z-index:5;
      font-weight: normal; /* Removed bold */
      color: #0b1b2a; /* Dark UI color for high contrast */
      text-shadow: 1px 1px 2px rgba(255,255,255,0.2); /* Subtle light shadow for depth */
      transition: opacity .3s ease;
    }
    .pill{
      pointer-events:auto;
      background: linear-gradient(180deg, #1f9e55, #167a42); /* Dark green gradient */
      border: 1px solid rgba(255, 255, 255, 0.3); /* Lighter green border */
      border-radius:999px;padding:8px 16px;
      font-weight:900;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.5); /* Stronger shadow for contrast */
      box-shadow:var(--shadow);
      display:flex;
      align-items:center;
      justify-content: center; /* Center content horizontally */
      gap:8px;white-space:nowrap;
      font-size:16px;line-height:1;
      color: #fff;
    }
    .pill .emoji{font-size:22px}
    .msg{max-width:70vw;overflow:hidden;text-overflow:ellipsis;font-size:15px}
    .controls{
      position:fixed;left:0;right:0;bottom:15px;padding:12px 16px 10px;
      display:flex;gap:12px;justify-content:center;align-items:center;
      background:linear-gradient(180deg, rgba(0,0,0,0), rgba(10,20,30,.45));
      backdrop-filter:saturate(1.2);z-index:6
    }
    .btn{
      pointer-events:auto;user-select:none;-webkit-tap-highlight-color:transparent;
      width:80px;height:80px;border-radius:999px;border:none;outline:none;cursor:pointer;
      display:grid;place-items:center;font-size:34px;
      background:radial-gradient(120% 120% at 30% 30%, #3fb9ff, #005b9e);
      color:#fff;box-shadow:var(--shadow);transition:transform .08s ease, filter .2s ease
    }
    .btn:active{transform:scale(.96)}
    .btn.alt{background:#ffb84d}
    .btn.good{background:radial-gradient(120% 120% at 30% 30%, #86efac, #16a34a)}
    .btn.small{width:56px;height:56px;font-size:26px}
    .overlay{
      position:fixed;left:0;right:0;top:0;bottom:0;display:none;align-items:center;justify-content:center;
      background:linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.35));z-index:7
    }
    .num{
      font-size:80px;font-weight:900;text-shadow:0 10px 24px rgba(0,0,0,.35);letter-spacing:2px
    }
    .toast{
      position:fixed;left:50%;top:56px;transform:translate(-50%,0);
      background:rgba(0,0,0,.35);backdrop-filter:saturate(1.1) blur(2px);
      padding:8px 14px;border-radius:999px;font-weight:800;box-shadow:var(--shadow);display:none;z-index:8
    }
    .hint{
      position:fixed;left:50%;bottom:110px;transform:translateX(-50%);z-index:4;
      font-weight:900;color:#fff;filter:drop-shadow(0 6px 16px rgba(0,0,0,.4));opacity:.9
    }
    .hint .finger{display:inline-block;animation:finger 1.4s ease-in-out infinite}
    @keyframes finger{
      0%{transform:translate(0,0) rotate(0deg)}
      50%{transform:translate(12px,-10px) rotate(-10deg)}
      100%{transform:translate(0,0) rotate(0deg)}
    }
    @keyframes pulse{
      0%{transform:scale(1);box-shadow:var(--shadow)}
      50%{transform:scale(1.05);box-shadow:0 8px 30px rgba(0,0,0,.3)}
      100%{transform:scale(1);box-shadow:var(--shadow)}
    }
    .pulsing{animation:pulse 1.5s ease-in-out infinite}
    .flash{
      position:fixed;
      inset:0;
      background:rgba(255,255,255,0);
      pointer-events:none;
      z-index:10;
      transition: background .1s ease;
    }
    .flash.active{
      background:rgba(255,255,255,0.7);
    }
    .shaking {
      animation: screen-shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
    }
    @keyframes screen-shake {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }
    @media (max-width:640px){
      .pill{font-size:14px}
      .msg{max-width:65vw;font-size:13px}
      .btn{width:76px;height:76px}
      .btn.alt{width:76px;height:76px}
      .num{font-size:64px}
    }
    @media (prefers-reduced-motion: reduce){
      .btn,.hint .finger{animation:none;transition:none}
    }
  </style>
</head>
<body>
  <h1 class="game-title">Goal Kick</h1>
  <div class="instructions" id="instructions">🎯 Hit the shiny window!</div>
  <div class="hud">
    <div class="pill" aria-live="polite" aria-atomic="true"><span class="emoji">⚽</span><span id="g">0</span></div>
    <div class="pill msg" id="msg" role="status"><span class="emoji">👆</span><span id="msgText">Draw a line, then lift to kick</span></div>
    <button class="pill small" id="mute" aria-label="Toggle sound" title="Sound"><span id="muteIcon">🔊</span></button>
  </div>

  <div class="controls" aria-label="Game controls">
    <button class="btn good" id="auto" aria-label="Auto kick" title="Auto Kick">👟</button>
    <button class="btn alt" id="restart" aria-label="Restart ball" title="Restart">🔄</button>
  </div>

  <div class="overlay" id="ov" aria-hidden="true"><div class="num" id="num">3</div></div>
  <div class="toast" id="toast">Nice shot!</div>
  <div class="hint" id="hint"><span class="finger">👉</span> Draw toward the shiny goal</div>

  <canvas id="c" aria-label="Goal Kick game" role="img"></canvas>
  <div class="flash" id="flash"></div>

  <script>
  (function(){
    'use strict';

    // Canvas setup with high-DPI support
    const c = document.getElementById('c');
    const ctx = c.getContext('2d', { alpha: false, desynchronized: true });
    let W = 0, H = 0, DPR = 1;

    function resize(){
      const cssW = c.clientWidth;
      const cssH = c.clientHeight;
      DPR = Math.min(2, window.devicePixelRatio || 1);
      c.width = Math.floor(cssW * DPR);
      c.height = Math.floor(cssH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      W = cssW; H = cssH;
      // keep elements sized based on new W/H if needed
      ballR = Math.max(16, Math.min(28, Math.floor(Math.min(W,H)/22)));
      arrowMax = Math.max(60, Math.min(220, Math.floor(Math.min(W,H)/3)));
      if (!running) draw(); // draw static when paused
    }
    addEventListener('resize', resize, { passive: true });

    // UI elements
    const gEl = document.getElementById('g');
    const msg = document.getElementById('msgText');
    const ov = document.getElementById('ov');
    const num = document.getElementById('num');
    const toast = document.getElementById('toast');
    const hint = document.getElementById('hint');
    const btnAuto = document.getElementById('auto');
    const btnRestart = document.getElementById('restart');
    const btnMute = document.getElementById('mute');
    const muteIcon = document.getElementById('muteIcon');
    const flashEl = document.getElementById('flash');

    // Audio (simple beeps) + speech, togglable
    let soundOn = true;
    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(_) { audioCtx = null; }
      }
    }
    function beep(type='goal'){
      if (!soundOn || !audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle';
      const t = audioCtx.currentTime;
      if (type === 'goal'){ o.frequency.setValueAtTime(880, t); o.frequency.exponentialRampToValueAtTime(1760, t + 0.12); g.gain.value = 0.08; }
      else if (type === 'miss'){ o.frequency.setValueAtTime(220, t); o.frequency.exponentialRampToValueAtTime(110, t + 0.2); g.gain.value = 0.06; }
      else { o.frequency.setValueAtTime(660, t); g.gain.value = 0.05; }
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(t + 0.26);
    }
    function speak(t){
      if (!soundOn) return;
      try{
        if(!('speechSynthesis' in window)) return;
        const u = new SpeechSynthesisUtterance(String(t));
        u.lang = 'en-US';
        u.rate = 1;
        speechSynthesis.cancel();
        speechSynthesis.speak(u);
      }catch(_){}
    }

    // Game state
    let running = true;
    let goals = 0;

    let ball, target, shot=false, start=false, resolved=false;
    let isAiming=false, sX=0, sY=0, aimX=0, aimY=0;
    let ballR = 16;
    let arrowMax = 200;

    // Particles (sparkles/confetti)
    const particles = [];
    function addSparkles(x, y, good=true){
      const n = good ? 60 : 12; // More particles for a goal
      const colors = good
        ? ['#f1c40f', '#e67e22', '#e74c3c', '#3498db', '#9b59b6', '#ffffff'] // Vibrant colors
        : ['#ffffff'];

      for (let i=0;i<n;i++){
        const a = Math.random()*Math.PI*2;
        const sp = good ? (3 + Math.random()*5) : (1 + Math.random()*2);
        const life = good ? 80 : 40;
        particles.push({
          x, y,
          vx: Math.cos(a)*sp, vy: Math.sin(a)*sp - (good?2.5:0.5),
          startLife: life,
          life: life,
          size: good ? (2 + Math.random() * 4) : 3,
          color: colors[Math.floor(Math.random() * colors.length)],
          shape: Math.random()<0.3 ? 'star' : 'dot'
        });
      }
    }

    function reset(){
      const rx = W * (0.12 + Math.random() * 0.22);
      const ry = H * (0.62 + Math.random() * 0.22);
      ball = { x: rx, y: ry, vx: 0, vy: 0, angle: 0, trail: [] };
      const baseH = Math.max(80, H * 0.22);
      const speed = (1.2 + Math.random()*1.2) * Math.max(1, H/640);
      target = { y: H * 0.5, h: baseH, dir: (Math.random()<0.5?-1:1) * speed };
      shot=false; start=true; resolved=false; isAiming=false;
      msg.textContent = 'Draw a line, then lift to kick';
      showHintSoon();
    }

    function restartCountdown(){
      start=false; shot=false; isAiming=false; resolved=true;
      btnAuto.classList.remove('pulsing');
      let k = 3; num.textContent = '3';
      ov.style.display = 'flex';
      const iv = setInterval(()=>{
        k--;
        if (k <= 0){
          clearInterval(iv);
          ov.style.display='none';
          reset();
        } else {
          num.textContent = String(k);
        }
      }, 1000);
    }

    // Controls
    btnAuto.addEventListener('click', ()=>{
      ensureAudio();
      if (!start || shot) return;
      // Aim for the center of the shiny window slightly forward
      const gx = goalPlaneX() - 10;
      const gy = target.y;
      fire(gx, gy);
    });
    btnRestart.addEventListener('click', ()=>{
      ensureAudio(); beep('tap');
      reset();
    });
    btnMute.addEventListener('click', ()=>{
      soundOn = !soundOn;
      muteIcon.textContent = soundOn ? '🔊' : '🔇';
      if (soundOn) { ensureAudio(); beep('tap'); }
    });

    function showToast(text){
      toast.textContent = text;
      toast.style.display = 'block';
      toast.style.opacity = '1';
      setTimeout(()=>{ toast.style.transition='opacity .35s'; toast.style.opacity='0'; }, 650);
      setTimeout(()=>{ toast.style.display='none'; toast.style.transition=''; }, 1100);
    }

    let hintTimer = null, hintShown = false;
    function showHintSoon(){
      clearTimeout(hintTimer);
      if (hintShown) return;
      hint.style.display = 'block';
      hint.style.opacity = '0';
      hintTimer = setTimeout(()=>{
        hint.style.transition = 'opacity .4s';
        hint.style.opacity = '.95';
        setTimeout(()=>{
          hint.style.opacity = '0';
          setTimeout(()=>{ hint.style.display='none'; }, 400);
        }, 1800);
        hintShown = true;
      }, 700);
    }

    function goalPlaneX(){ return W * 0.9; } // virtual goal line

    // Input helpers
    function toCanvas(e){
      const r = c.getBoundingClientRect();
      return { tx: (e.clientX - r.left), ty: (e.clientY - r.top) };
    }

    c.addEventListener('pointerdown', e=>{
      ensureAudio();
      if(!start || shot) return;
      c.setPointerCapture(e.pointerId);
      const {tx,ty} = toCanvas(e);
      sX = tx; sY = ty; isAiming = true;
      aimX = tx; aimY = ty;
    });
    c.addEventListener('pointermove', e=>{
      if(!isAiming || !start || shot) return;
      const {tx,ty} = toCanvas(e);
      // clamp arrow length for little hands
      const dx = tx - sX, dy = ty - sY;
      const d = Math.hypot(dx, dy);
      const k = d > arrowMax ? (arrowMax / d) : 1;
      aimX = sX + dx * k; aimY = sY + dy * k;
    }, {passive:true});
    function endAim(e){
      if(!isAiming || !start || shot) return;
      const {tx,ty} = toCanvas(e);
      // use clamped aim
      const dx = tx - sX, dy = ty - sY;
      const d = Math.hypot(dx, dy);
      const k = d > arrowMax ? (arrowMax / d) : 1;
      aimX = sX + dx * k; aimY = sY + dy * k;
      isAiming=false;
      fire(aimX, aimY);
    }
    c.addEventListener('pointerup', endAim);
    c.addEventListener('pointercancel', ()=>{ isAiming=false; });

    c.addEventListener('dblclick', e=>{
      if(!start || shot) return;
      const {tx,ty} = toCanvas(e);
      fire(tx, ty);
    });

    function fire(tx, ty){
      if(!start || shot) return;
      const dx = tx - ball.x;
      const dy = ty - ball.y;
      const dist = Math.hypot(dx, dy) || 1;
      if (dist < 8) return;
      // speed scaled gently (always strong enough to reach goal)
      const minSpeed = 8, maxSpeed = 16;
      let s = Math.min(maxSpeed, Math.max(minSpeed, dist / 18));
      const k = s / dist;
      ball.vx = dx * k;
      ball.vy = dy * k;
      shot = true;
      msg.textContent = 'Shoooot!';
      hint.style.display = 'none';
      instructionsEl.style.opacity = '0';
      beep('tap');
    }

    function scored(){
      msg.textContent = 'Goal! 🎉';
      goals++; gEl.textContent = goals;
      speak('Goal');
      beep('goal');
      addSparkles(ball.x, ball.y, true);
      showToast('Great job! 🏆');

      // Flash effect
      flashEl.classList.add('active');
      setTimeout(()=> flashEl.classList.remove('active'), 120);

      // Screen shake
      c.classList.add('shaking');
      setTimeout(()=> c.classList.remove('shaking'), 400);

      restartCountdown();
    }
    function missed(){
      msg.textContent = 'Oops! Try again 🙂';
      speak('Miss');
      beep('miss');
      addSparkles(ball.x, ball.y, false);
      restartCountdown();
    }

    // Update + Draw loop
    function update(){
      // move target (shiny window)
      if (start){
        target.y += target.dir;
        const topLimit = H*0.22 + target.h/2;
        const botLimit = H*0.78 - target.h/2;
        if(target.y < topLimit || target.y > botLimit) target.dir *= -1;
      }

      // Ball movement
      if (shot){
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.angle += Math.hypot(ball.vx, ball.vy) * 0.05;

        // trail
        ball.trail.push({x:ball.x, y:ball.y, a:0.8});
        if (ball.trail.length > 14) ball.trail.shift();
      } else {
        // idle wobble tiny
        ball.angle += 0.02;
      }

      // Particles
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.06; // gravity
        p.life--;
        if (p.life <= 0) particles.splice(i,1);
      }

      // Check result
      if (shot && !resolved){
        const gx = goalPlaneX();
        if (ball.x >= gx){
          if (ball.y > target.y - target.h/2 && ball.y < target.y + target.h/2){
            resolved = true; scored();
          } else {
            resolved = true; missed();
          }
        } else if(ball.x>W+30 || ball.y<-30 || ball.y>H+30){
          resolved = true; missed();
        }
      }
    }

    function drawBackground(){
      // Sky
      const sky = ctx.createLinearGradient(0,0,0,H*0.6);
      sky.addColorStop(0, '#87CEEB'); // Brighter sky blue
      sky.addColorStop(1, '#E0F6FF'); // Lighter blue towards horizon
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);

      // Sun
      const sunX = W*0.12, sunY = H*0.08, sunR = Math.min(W,H)*0.06;
      const sunG = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR*1.8);
      sunG.addColorStop(0, 'rgba(255,235,130,0.9)');
      sunG.addColorStop(1, 'rgba(255,235,130,0)');
      ctx.fillStyle = sunG; ctx.beginPath(); ctx.arc(sunX, sunY, sunR*1.8, 0, Math.PI*2); ctx.fill();

      // Grass
      ctx.fillStyle = '#3dbd76'; // A single, uniform green
      ctx.fillRect(0,H*0.45,W,H*0.55);

      // Field lines
      ctx.strokeStyle = '#ffffffaa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W*0.1, H*0.55); ctx.lineTo(W*0.88, H*0.55);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(W*0.12, H*0.75); ctx.lineTo(W*0.9, H*0.75);
      ctx.stroke();
    }

    function drawGoal(){
      const gx = W*0.9;
      const postW = 8;
      const goalH = Math.min(H*0.55, 320);
      const top = (H - goalH)/2;
      const depth = Math.max(30, Math.min(60, W*0.06));

      // Add shadow for depth
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 12;
      ctx.shadowOffsetX = -4;
      ctx.shadowOffsetY = 4;

      // Posts
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(gx, top, postW, goalH); // right post
      ctx.fillRect(gx - 160, top, postW, goalH); // left post
      ctx.fillRect(gx - 160, top, 160+postW, postW); // crossbar

      // Restore context to remove shadow for the stroke
      ctx.restore();

      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 3;
      ctx.strokeRect(gx, top, postW, goalH);
      ctx.strokeRect(gx - 160, top, postW, goalH);
      ctx.strokeRect(gx - 160, top, 160+postW, postW);

      // Net
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1.2;
      for (let i=0;i<=8;i++){
        const nx = gx - 160 + i*20;
        ctx.beginPath(); ctx.moveTo(nx, top); ctx.lineTo(nx + depth*0.25, top + depth); ctx.stroke();
      }
      for (let j=0;j<=8;j++){
        const ny = top + j*(goalH/8);
        ctx.beginPath(); ctx.moveTo(gx - 160, ny); ctx.lineTo(gx - 160 + depth*0.4, ny + depth); ctx.stroke();
      }

      // Shiny target window (moving vertical band)
      const th = target.h;
      const ty = target.y;
      const bandX = gx - 6; // just inside goal
      const bandW = 14;

      const g = ctx.createLinearGradient(bandX, ty-th/2, bandX, ty+th/2);
      g.addColorStop(0, 'rgba(255, 230, 109, 0.85)');
      g.addColorStop(1, 'rgba(255, 157, 226, 0.85)');
      ctx.save();
      // glow
      ctx.shadowColor = '#ffd966';
      ctx.shadowBlur = 14;
      ctx.fillStyle = g;
      ctx.fillRect(bandX, ty - th/2, bandW, th);
      ctx.restore();

      // Cute star markers
      const starY1 = ty - th/3, starY2 = ty + th/3;
      drawStar(bandX + bandW/2, starY1, 7, 12, '#fff6a9');
      drawStar(bandX + bandW/2, starY2, 7, 12, '#ffd0f3');
    }

    function drawStar(cx, cy, spikes, outerR, color){
      const innerR = outerR*0.5;
      let rot = Math.PI/2 * 3;
      let x=cx,y=cy;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerR);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerR;
        y = cy + Math.sin(rot) * outerR;
        ctx.lineTo(x, y);
        rot += Math.PI / spikes;
        x = cx + Math.cos(rot) * innerR;
        y = cy + Math.sin(rot) * innerR;
        ctx.lineTo(x, y);
        rot += Math.PI / spikes;
      }
      ctx.lineTo(cx, cy - outerR);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawBall(){
      // Shadow
      ctx.save();
      ctx.translate(ball.x, ball.y);
      const shadowY = ballR * 1.2;
      const shadowGrad = ctx.createRadialGradient(0, shadowY, 0, 0, shadowY, ballR * 1.4);
      shadowGrad.addColorStop(0, 'rgba(0,0,0,0.25)');
      shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shadowGrad;
      ctx.beginPath();
      ctx.ellipse(0, shadowY, ballR * 1.1, ballR * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Trail
      for (let i=0;i<ball.trail.length;i++){
        const t = ball.trail[i];
        const a = (i+1)/ball.trail.length;
        ctx.globalAlpha = 0.12 * a;
        ctx.beginPath(); ctx.arc(t.x, t.y, ballR + (1-a)*3, 0, Math.PI*2); ctx.fillStyle = '#ffffff'; ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Ball body
      const r = ballR;
      const grad = ctx.createRadialGradient(ball.x - r*0.4, ball.y - r*0.5, r*0.1, ball.x, ball.y, r);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.7, '#f0f2f5');
      grad.addColorStop(1, '#d8dde2');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(ball.x, ball.y, r, 0, Math.PI*2); ctx.fill();

      // Discreet lines
      ctx.save();
      ctx.translate(ball.x, ball.y);
      ctx.rotate(ball.angle);

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.lineWidth = 1;

      // Draw two curved lines to suggest panels
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.8, Math.PI * 0.2, Math.PI * 0.8);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, r * 0.6, Math.PI * 1.3, Math.PI * 1.9);
      ctx.stroke();

      ctx.restore();

      // Outline
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(ball.x, ball.y, r, 0, Math.PI*2); ctx.stroke();
    }

    function drawAim(){
      if (isAiming && !shot && start){
        const sx = ball.x, sy = ball.y;
        const ex = aimX, ey = aimY;
        const dx = ex - sx, dy = ey - sy;
        const dist = Math.hypot(dx, dy);
        // Line
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 8]);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrow head
        const ang = Math.atan2(dy, dx);
        const ah = 14;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - Math.cos(ang - 0.4)*ah, ey - Math.sin(ang - 0.4)*ah);
        ctx.lineTo(ex - Math.cos(ang + 0.4)*ah, ey - Math.sin(ang + 0.4)*ah);
        ctx.closePath(); ctx.fill();

        // Power bubble
        const p = Math.min(1, dist / arrowMax);
        ctx.fillStyle = 'rgba(255,255,255,'+(0.25 + 0.45*p)+')';
        ctx.beginPath(); ctx.arc(sx, sy, 10 + 14*p, 0, Math.PI*2); ctx.fill();
      }
    }

    function drawParticles(){
      for (let i=0;i<particles.length;i++){
        const p = particles[i];
        const lifeRatio = Math.max(0, p.life / p.startLife);
        ctx.globalAlpha = lifeRatio;
        const currentSize = p.size * lifeRatio;

        if (p.shape === 'star'){
          drawStar(p.x, p.y, 5, currentSize * 1.2, p.color);
        }
        else {
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, currentSize, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    function draw(){
      drawBackground();
      drawGoal();
      drawAim();
      drawBall();
      drawParticles();
    }

    function loop(){
      if (!running) return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // Start game
    resize();
    reset();
    loop();

  })();
  </script>
</body>
</html> </script>
</body>
</html>