<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Pocket Golf</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Chewy&display=swap" rel="stylesheet">
<style>
  :root{
    --sky1:#b6e3ff;
    --sky2:#e7f5ff;
    --grass1:#87d37c;
    --grass2:#7bcf70;
    --ui:#0f172a;
    --ui2:#1e293b;
    --accent:#ff6b6b;
    --accent2:#ffd166;
    --text:#0b1324;
    --white:#ffffff;
  }
  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(to bottom,var(--sky2),var(--sky1));
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    color:var(--text);
    overflow:hidden;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;
    touch-action:none;
  }
  #topbar{
    position:fixed;
    inset:0 0 auto 0;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:.8rem;
    padding:.6rem .8rem;
    background:linear-gradient(to right, rgba(255,255,255,.85), rgba(255,255,255,.65));
    backdrop-filter: blur(6px);
    border-bottom:1px solid rgba(0,0,0,.06);
    z-index:10;
  }
  .topbar-left, .topbar-right{
    display:flex;
    align-items:center;
    gap: .5rem;
    flex: 1;
  }
  .topbar-right{
    justify-content:flex-end;
  }
  .topbar-center{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap: .4rem;
  }
  #brand{
    display:flex;
    align-items:center;
    gap:.6rem;
    font-family: 'Chewy', cursive;
    font-size: 1.5rem;
    color: #d9534f;
    letter-spacing:.2px;
  }
  #brand .dot{
    width:10px;height:10px;border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #fff, #ddd);
    box-shadow:0 1px 0 rgba(0,0,0,.08), 0 0 0 3px rgba(255,255,255,.7) inset;
  }
  #stats{
    font-weight:600;
    font-size:.95rem;
    display:flex;
    justify-content:center;
    gap: 1rem;
    width: 320px;
    margin: 0 auto;
  }
  .pill{
    background:rgba(255,255,255,.85);
    border:1px solid rgba(0,0,0,.08);
    padding:.3rem .6rem;
    border-radius:999px;
    box-shadow:0 2px 4px rgba(0,0,0,.06);
  }
      button.ui{
    padding:.3rem .6rem;
    border-radius:12px; /* More rounded */
    border:1px solid rgba(0,0,0,.12); /* Clearer border */
    background:linear-gradient(to bottom, #ffffff, #f0f0f0); /* Subtle gradient */
    box-shadow:0 3px 8px rgba(0,0,0,.1); /* Clearer shadow */
    font-weight:600;
    cursor:pointer;
    transition:.15s ease transform, .15s ease background;
    touch-action:manipulation;
  }
  button.ui:active{ transform:scale(0.98) }
  button.primary{
    background:linear-gradient(to bottom, #3b82f6, #2563eb);
    border-color:#1e40af;
    color:white;
    box-shadow:0 4px 10px rgba(37,99,235,.35);
  }
  #canvasWrap{
    position:fixed;
    inset:48px 0 0 0;
  }
  @media (max-width:640px){
    #topbar{
      flex-wrap: wrap;
      justify-content: center;
      padding-bottom: .8rem;
    }
    .topbar-center{
      order: -1;
      flex-basis: 100%;
      margin-bottom: .5rem;
    }
    .topbar-left{
      justify-content: flex-start;
    }
    .topbar-right{
      justify-content: flex-end;
    }
    #canvasWrap{ inset:150px 0 0 0; }
    #stats{ font-size:.9rem; gap: .5rem; }
    .pill{ padding: .2rem .5rem; }
    button.ui{ padding:.5rem .6rem }
  }
  canvas{ width:100%; height:100%; display:block; }
  #helpModal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20;
    background:rgba(0,0,0,.45);
    backdrop-filter: blur(4px);
  }
  #helpModal .card{
    background:linear-gradient(to bottom, #ffffff, #f0f9ff);
    border:1px solid rgba(0,0,0,.08);
    border-radius:1.2rem;
    padding:1.2rem 1.5rem;
    width:min(420px, 92vw);
    box-shadow:0 25px 50px rgba(0,0,0,.3);
    text-align:left;
    position: relative;
  }
  #helpModal h3{
    font-family: 'Chewy', cursive;
    font-size: 2rem;
    color: #2563eb;
    margin: 0 0 1rem 0;
    text-align: center;
  }
  #helpModal .instructions {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  #helpModal .instructions li {
    margin-bottom: 1rem;
  }
  #helpModal .instructions li:last-child {
    margin-bottom: 0;
  }
  #helpModal .instructions h4 {
    font-size: 1.1rem;
    color: var(--ui);
    margin: 0 0 0.4rem 0;
    padding-bottom: .2rem;
    border-bottom: 1px solid #e0e0e0;
  }
  #helpModal .instructions p {
    margin: .4rem 0;
  }
  #helpModal p{ margin:.5rem 0; line-height:1.4; color: var(--ui2); }
  #helpModal .kbd{
    display:inline-block; padding:.05rem .35rem; border-radius:.35rem;
    background:#0f172a; color:white; font-weight:700; font-size:.85em;
    box-shadow:inset 0 -2px 0 rgba(255,255,255,.15);
  }
  #modal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20;
    background:rgba(0,0,0,.45);
    backdrop-filter: blur(4px);
  }
  #modal .card{
    background:linear-gradient(to bottom, #ffffff, #f0f9ff);
    border:1px solid rgba(0,0,0,.08);
    border-radius:1.2rem;
    padding:1.2rem 1.5rem;
    width:min(420px, 92vw);
    box-shadow:0 25px 50px rgba(0,0,0,.3);
    text-align:center;
  }
  #modal h2{
    font-family: 'Chewy', cursive;
    font-size: 2rem;
    color: #2563eb;
    margin: 0 0 1rem 0;
  }
  #modal p{ margin:.5rem 0; line-height:1.4; color: var(--ui2); }
  #modal .row{ display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap }
  .badge{
    display:inline-flex; align-items:center; gap:.35rem;
    background:rgba(255,255,255,.85); border:1px solid rgba(0,0,0,.08);
    border-radius:999px; padding:.25rem .5rem; font-weight:700;
  }
  #toast{
    position:fixed; top:60px; left:50%; transform:translateX(-50%);
    background:rgba(15,23,42,.9); color:white; padding:.45rem .75rem;
    border-radius:.6rem; box-shadow:0 10px 30px rgba(0,0,0,.25);
    font-weight:600; display:none; z-index:30;
  }
</style>
</head>
<body>
  <div id="topbar">
    <div class="topbar-left">
      <button class="ui" id="toggleTTS" aria-label="Toggle voice">üîä On</button>
      <button class="ui" id="helpBtn" aria-label="Show help">? Help</button>
    </div>
    <div class="topbar-center">
      <div id="brand">
        <div class="dot"></div>
        Pocket Golf
      </div>
      <div id="stats">
        <span class="pill">Hole <span id="holeNum">1</span></span>
        <span class="pill">Strokes <span id="strokes">0</span></span>
        <span class="pill">Total <span id="total">0</span></span>
      </div>
    </div>
    <div class="topbar-right">
      <button class="ui" id="resetHole" aria-label="Reset hole">‚Üª Reset</button>
      <button class="ui primary" id="newHole" aria-label="New hole">Next ‚ñ∂</button>
    </div>
  </div>
  <div id="canvasWrap">
    <canvas id="game"></canvas>
  </div>
  <div id="helpModal">
    <div class="card">
      <button id="closeHelpBtn" aria-label="Close help" style="position: absolute; top: 0.5rem; right: 0.5rem; width: 32px; height: 32px; border-radius: 50%; background: #e9ecef; border: none; font-size: 24px; color: #495057; cursor: pointer; display: flex; justify-content: center; align-items: center; padding-bottom: 4px;">&times;</button>
      <h3>How to play</h3>
      <ul class="instructions">
        <li>
          <h4>Mouse & Touch</h4>
          <p>Click (or tap) and drag away from the ball to aim and set power. Release to shoot!</p>
        </li>
        <li>
          <h4>Keyboard</h4>
          <p>
            <strong>Aim:</strong> <span class="kbd">‚Üê</span> / <span class="kbd">‚Üí</span> |
            <strong>Power:</strong> <span class="kbd">‚Üë</span> / <span class="kbd">‚Üì</span>
          </p>
          <p>
            <strong>Shoot:</strong> <span class="kbd">Spacebar</span> |
            <strong>Reset:</strong> <span class="kbd">R</span>
          </p>
        </li>
      </ul>
    </div>
  </div>
  <div id="modal">
    <div class="card">
      <h2 id="modalTitle">Hole Complete!</h2>
      <p id="modalDesc"></p>
      <div class="row" style="margin:.3rem 0 .9rem 0;">
        <span class="badge">Hole <span id="mHoleNum">1</span></span>
        <span class="badge">Strokes <span id="mStrokes">0</span></span>
        <span class="badge">Total <span id="mTotal">0</span></span>
      </div>
      <div class="row">
        <button class="ui" id="playAgain">Replay Hole</button>
        <button class="ui primary" id="nextHole">Next Hole ‚ñ∂</button>
      </div>
    </div>
  </div>
  <div id="toast"></div>
<script>
(() => {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioContext ? new AudioContext() : null;
  let hitSoundBuffer;
  let sinkSoundBuffer;

  async function loadSound(url) {
    if (!audioCtx) return null;
    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      return await audioCtx.decodeAudioData(arrayBuffer);
    } catch (e) {
      console.error(`Failed to load sound: ${url}`, e);
      return null;
    }
  }

  function playSound(buffer) {
    if (!audioCtx || !buffer || buffer.duration === 0) return;
    try {
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start(0);
    } catch (e) {
      console.error('Error playing sound:', e);
    }
  }

  loadSound('../../assets/hit.mp3').then(buffer => { hitSoundBuffer = buffer; });
  loadSound('../../assets/sink.mp3').then(buffer => { sinkSoundBuffer = buffer; });

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const holeNumEl = document.getElementById('holeNum');
  const strokesEl = document.getElementById('strokes');
  const totalEl = document.getElementById('total');
  const toggleTTSEl = document.getElementById('toggleTTS');
  const resetHoleEl = document.getElementById('resetHole');
  const newHoleEl = document.getElementById('newHole');

  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalDesc = document.getElementById('modalDesc');
  const mHoleNum = document.getElementById('mHoleNum');
  const mStrokes = document.getElementById('mStrokes');
  const mTotal = document.getElementById('mTotal');
  const playAgainBtn = document.getElementById('playAgain');
  const nextHoleBtn = document.getElementById('nextHole');
  const toast = document.getElementById('toast');

  let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let groundY = 0;

  const world = {
    hole: 1,
    strokes: 0,
    total: 0,
    cupX: 0,
    cupY: 0,
    cupR: 14,
    flagH: 80,
    aiming: false,
    aimFromKeyboard: true,
    aimAngle: 45 * Math.PI/180,
    aimPower: 0.5, // 0..1
    maxPower: 1200, // px/s
    wind: 0, // not used, reserved
    sunk: false,
    sinkingT: 0,
    hasLaunchedOnce: false,
  };

  const ball = {
    x: 0, y: 0, r: 10*DPR,
    vx: 0, vy: 0,
    moving: false,
  };

  const input = {
    pointerId: null,
    dragging: false,
    dragStart: {x:0,y:0},
    dragNow: {x:0,y:0},
  };

  let lastT = 0;
  let cloudOffset = 0;

  function resize() {
    const rect = document.getElementById('canvasWrap').getBoundingClientRect();
    W = Math.floor(rect.width * DPR);
    H = Math.floor(rect.height * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    groundY = Math.floor(H*0.8);
    world.flagH = clamp(H*0.12, 60, 120);
    world.cupR = clamp(Math.round(H*0.018), 10, 18);
    ball.r = clamp(Math.round(H*0.018), 8, 14);

    world.maxPower = clamp(W*1.1, 900, 1800);

    if (!world.initialized) {
      // place first time
      placeBall();
      placeCup();
      world.initialized = true;
    } else {
      // keep relative positions anchored to ground
      const groundPrev = groundY; // already updated
      ball.y = groundY - ball.r;
      world.cupY = groundY;
    }
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function placeBall() {
    ball.x = Math.round(W * 0.12);
    ball.y = groundY - ball.r;
    ball.vx = ball.vy = 0;
    ball.moving = false;
  }

  function placeCup() {
    const minX = W * 0.55;
    const maxX = W * 0.86;
    world.cupX = Math.round(rand(minX, maxX));
    world.cupY = groundY;
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  function resetHole(keepTotals=true){
    ball.vx = ball.vy = 0;
    ball.moving = false;
    world.aiming = false;
    world.sunk = false;
    world.sinkingT = 0;
    world.aimAngle = 45*Math.PI/180;
    world.aimPower = 0.5;
    world.wind = 0;
    if (!keepTotals) {
      world.total = 0;
      world.hole = 1;
    }
    world.strokes = 0;
    placeBall();
    placeCup();
    updateHUD();
    hideModal();
  }

  function nextHole(){
    world.total += world.strokes;
    world.hole++;
    world.strokes = 0;
    world.sunk = false;
    world.sinkingT = 0;
    placeBall();
    placeCup();
    updateHUD();
    hideModal();
  }

  function updateHUD(){
    holeNumEl.textContent = world.hole;
    strokesEl.textContent = world.strokes;
    totalEl.textContent = world.total;
  }

  function draw() {
    ctx.save();
    ctx.clearRect(0,0,W,H);

    // Sky gradient (more natural)
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#87CEEB'); // Light Sky Blue
    sky.addColorStop(0.5,'#B0E0E6'); // Powder Blue
    sky.addColorStop(1,'#ADD8E6'); // Light Blue
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);

    // Sun (subtle glow)
    const sunX = W*0.1, sunY = H*0.18, sunR = H*0.12;
    const sunG = ctx.createRadialGradient(sunX,sunY,sunR*0.2, sunX,sunY,sunR);
    sunG.addColorStop(0,'rgba(255,255,200,0.8)'); // Brighter yellow center
    sunG.addColorStop(0.5,'rgba(255,255,150,0.4)'); // Fading yellow
    sunG.addColorStop(1,'rgba(255,255,100,0)'); // Transparent
    ctx.fillStyle = sunG;
    ctx.beginPath(); ctx.arc(sunX,sunY,sunR,0,Math.PI*2); ctx.fill();

    // Clouds
    drawCloud((W*0.25 + cloudOffset) % (W + 400), H*0.18, H*0.035);
    drawCloud((W*0.55 + cloudOffset) % (W + 400), H*0.12, H*0.03);
    drawCloud((W*0.8 + cloudOffset) % (W + 400), H*0.2, H*0.04);

    // Hills
    drawHill(W * 0.7, groundY, W * 0.6, H * 0.2, '#70b866');
    drawHill(W * 0.3, groundY, W * 0.5, H * 0.15, '#75c26b');
    drawHill(W * 0.9, groundY, W * 0.4, H * 0.1, '#7acb70');
    drawHill(W * 0.1, groundY, W * 0.3, H * 0.08, '#7acb70');
    drawHill(W * 0.5, groundY, W * 0.45, H * 0.18, '#70b866');

    // Trees
    drawTree(W * 0.6, groundY - H * 0.05, H * 0.1, '#4CAF50');
    drawTree(W * 0.2, groundY - H * 0.03, H * 0.08, '#66BB6A');
    drawTree(W * 0.85, groundY - H * 0.02, H * 0.07, '#8BC34A');
    drawTree(W * 0.4, groundY - H * 0.06, H * 0.11, '#4CAF50');
    drawTree(W * 0.95, groundY - H * 0.04, H * 0.09, '#66BB6A');
    drawTree(W * 0.05, groundY - H * 0.01, H * 0.06, '#8BC34A');

    // Grass (Fairway and Rough)
    const fairwayColor = '#6B8E23'; // Olive green
    const roughColor = '#556B2F';   // Dark olive green

    // Draw rough (entire ground area)
    ctx.fillStyle = roughColor;
    ctx.fillRect(0, groundY, W, H - groundY);

    // Draw fairway (a path from ball towards cup)
    ctx.fillStyle = fairwayColor;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(W, groundY);
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();

    // Create a more defined fairway shape
    ctx.beginPath();
    ctx.moveTo(ball.x - 50, groundY); // Start near the ball
    ctx.bezierCurveTo(
      ball.x + 100, groundY - 50, // Control point 1
      world.cupX - 100, groundY - 50, // Control point 2
      world.cupX + 50, groundY // End near the cup
    );
    ctx.lineTo(world.cupX + 50, H);
    ctx.lineTo(ball.x - 50, H);
    ctx.closePath();
    ctx.fill();

    // Fairway horizon line
    ctx.strokeStyle = 'rgba(0,0,0,.08)';
    ctx.lineWidth = Math.max(1, 1*DPR);
    ctx.beginPath();
    ctx.moveTo(0, groundY+.5);
    ctx.lineTo(W, groundY+.5);
    ctx.stroke();

    // Cup (hole shadow - improved)
    const cupShadowR = world.cupR * 1.8; // Slightly larger shadow
    const holeGrad = ctx.createRadialGradient(world.cupX, world.cupY, world.cupR * .3, world.cupX, world.cupY, cupShadowR);
    holeGrad.addColorStop(0, 'rgba(0,0,0,.35)'); // Darker center
    holeGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = holeGrad;
    ctx.beginPath(); ctx.arc(world.cupX, world.cupY, cupShadowR, 0, Math.PI*2); ctx.fill();

    // Cup lip (more defined)
    ctx.fillStyle = '#2f2f2f';
    ctx.beginPath(); ctx.ellipse(world.cupX, world.cupY, world.cupR, world.cupR*.55, 0, 0, Math.PI*2); ctx.fill();

    // Inner hole (for depth)
    ctx.fillStyle = '#1a1a1a'; // Even darker for inside
    ctx.beginPath(); ctx.ellipse(world.cupX, world.cupY + world.cupR * 0.1, world.cupR * 0.8, world.cupR * 0.4, 0, 0, Math.PI*2); ctx.fill();

    // Flag pole (proportional)
    const poleH = world.flagH * 1.1; // Slightly taller
    const poleTopY = groundY - poleH;
    ctx.strokeStyle = '#b9c4cc';
    ctx.lineWidth = Math.max(2, 2*DPR); // Consistent thickness
    ctx.beginPath();
    ctx.moveTo(world.cupX, groundY);
    ctx.lineTo(world.cupX, poleTopY);
    ctx.stroke();

    // Flag (more dynamic)
    const flagW = Math.max(22*DPR, world.cupR*2.5); // Slightly larger
    const flagH = Math.max(15*DPR, world.cupR*1.8);
    ctx.fillStyle = '#ff4d4d';
    ctx.beginPath();
    ctx.moveTo(world.cupX, poleTopY+flagH*0.2);
    ctx.lineTo(world.cupX + flagW, poleTopY+flagH*0.2);
    ctx.lineTo(world.cupX + flagW * 0.9, poleTopY + flagH * 0.7); // Slight wave
    ctx.lineTo(world.cupX, poleTopY + flagH*1.2);
    ctx.closePath();
    ctx.fill();

    // Aim guide if not moving and not sunk
    if(!ball.moving && !world.sunk){
      drawAimGuide();
    }

    // Ball shadow (more realistic)
    const shadowR = ball.r * 1.4; // Larger shadow
    const shGrad = ctx.createRadialGradient(ball.x, groundY, shadowR*0.1, ball.x, groundY, shadowR);
    shGrad.addColorStop(0,'rgba(0,0,0,.3)'); // Darker center
    shGrad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = shGrad;
    ctx.beginPath(); ctx.ellipse(ball.x, groundY-1*DPR, shadowR, shadowR*0.45, 0, 0, Math.PI*2); ctx.fill();

    // Ball
    let br = ball.r;
    if (world.sunk) {
      br = ball.r * (1 - world.sinkingT);
    }
    const ballG = ctx.createRadialGradient(ball.x - br*0.35, ball.y - br*0.35, br*0.1, ball.x, ball.y, br*1.15);
    ballG.addColorStop(0, '#ffffff');
    ballG.addColorStop(1, '#d9d9d9');
    ctx.fillStyle = ballG;
    ctx.beginPath(); ctx.arc(ball.x, ball.y, Math.max(0, br), 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,.12)';
    ctx.lineWidth = Math.max(1, .8*DPR);
    ctx.stroke();

    ctx.restore();
  }

  function drawCloud(x, y, r){
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.arc(x + r*1.1, y + r*0.2, r*0.8, 0, Math.PI*2);
    ctx.arc(x - r*1.0, y + r*0.2, r*0.9, 0, Math.PI*2);
    ctx.arc(x + r*0.2, y - r*0.4, r*0.7, 0, Math.PI*2);
    ctx.fill();
  }

  function drawTree(x, y, h, color) {
    // Trunk
    ctx.fillStyle = '#4e342e'; // Dark brown
    ctx.fillRect(x - h * 0.05, y - h * 0.5, h * 0.1, h * 0.5);

    // Branches
    ctx.strokeStyle = '#4e342e';
    ctx.lineWidth = h * 0.04;
    ctx.beginPath();
    // Branch 1
    ctx.moveTo(x, y - h * 0.4);
    ctx.lineTo(x - h * 0.2, y - h * 0.6);
    // Branch 2
    ctx.moveTo(x, y - h * 0.3);
    ctx.lineTo(x + h * 0.15, y - h * 0.5);
    ctx.stroke();

    // Crown (a single, large, rounded shape)
    ctx.fillStyle = color; // e.g., '#2e7d32' (intense green)
    ctx.beginPath();
    ctx.ellipse(x, y - h * 0.7, h * 0.4, h * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawHill(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x - w / 2, y);
    ctx.quadraticCurveTo(x, y - h, x + w / 2, y);
    ctx.closePath();
    ctx.fill();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawAimGuide() {
    let angle = world.aimAngle;
    let power = world.aimPower;
    // If dragging, compute from drag
    if (input.dragging) {
      const dx = input.dragNow.x - input.dragStart.x;
      const dy = input.dragNow.y - input.dragStart.y;
      const dragAngle = Math.atan2(dy, dx);
      // Shot direction is opposite of drag vector
      angle = Math.atan2(-Math.sin(dragAngle), -Math.cos(dragAngle));
      // Clamped to 10..80 degrees
      let deg = clamp(angle*180/Math.PI, 10, 80);
      angle = deg*Math.PI/180;
      const dragLen = Math.hypot(dx, dy);
      const maxDrag = Math.min(W,H) * 0.25;
      power = clamp(dragLen / maxDrag, 0.05, 1);
    }

    // arrow
    const L = power * Math.min(W,H) * 0.26;
    const ex = ball.x + Math.cos(angle) * L;
    const ey = ball.y - Math.sin(angle) * L;

    // dashed guideline
    ctx.strokeStyle = 'rgba(34,197,94,.9)';
    ctx.lineWidth = Math.max(2, 2*DPR);
    ctx.setLineDash([10*DPR, 8*DPR]);
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(ex, ey);
    ctx.stroke();
    ctx.setLineDash([]);

    // arrowhead
    const ah = Math.max(10*DPR, 10*DPR + power*8*DPR);
    const aw = ah*0.7;
    const ang = Math.atan2(ey - ball.y, ex - ball.x);
    ctx.fillStyle = 'rgba(16,185,129,1)';
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex - Math.cos(ang - Math.PI/8)*ah, ey - Math.sin(ang - Math.PI/8)*ah);
    ctx.lineTo(ex - Math.cos(ang + Math.PI/8)*ah, ey - Math.sin(ang + Math.PI/8)*ah);
    ctx.closePath();
    ctx.fill();

    // power bar ring
    ctx.strokeStyle = 'rgba(0,0,0,.1)';
    ctx.lineWidth = Math.max(2,2*DPR);
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r*2.2, 0, Math.PI*2); ctx.stroke();
    ctx.strokeStyle = 'rgba(16,185,129,1)';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r*2.2, -Math.PI/2, -Math.PI/2 + Math.PI*2*power); ctx.stroke();

    // update displayed aim if dragging
    if (input.dragging) {
      world.aimAngle = angle;
      world.aimPower = power;
      world.aimFromKeyboard = false;
    }
  }

  function physics(dt){
    if (world.sunk) {
      // Sinking animation
      world.sinkingT = Math.min(1, world.sinkingT + dt*1.6);
      return;
    }
    if (!ball.moving) return;

    // Integrate
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Gravity
    ball.vy += 1400 * dt; // px/s^2

    // Ground collision
    if (ball.y + ball.r > groundY) {
      ball.y = groundY - ball.r;
      if (Math.abs(ball.vy) > 60) {
        ball.vy = -ball.vy * 0.35; // bounce restitution
        ball.vx *= 0.92;
      } else {
        ball.vy = 0;
      }
      // Rolling friction
      const friction = 0.985;
      ball.vx *= friction;
      if (Math.abs(ball.vx) < 8) ball.vx = 0;
    }

    // Walls
    const margin = 4*DPR;
    if (ball.x - ball.r < margin) {
      ball.x = ball.r + margin;
      ball.vx = -ball.vx * 0.5;
    } else if (ball.x + ball.r > W - margin) {
      ball.x = W - margin - ball.r;
      ball.vx = -ball.vx * 0.5;
    }

    // Stop condition
    if (ball.vx === 0 && ball.vy === 0 && Math.abs(ball.y - (groundY - ball.r)) < 0.5) {
      ball.moving = false;
    }

    // Cup capture: if ball is near ground and near cup
    const dx = ball.x - world.cupX;
    const dy = ball.y - world.cupY + ball.r*0.35; // slight bias
    const dist = Math.hypot(dx, dy);
    const speed = Math.hypot(ball.vx, ball.vy);
    const captureR = world.cupR + ball.r*0.35;

    if (!world.sunk && dist < captureR) {
      // More permissive if slow
      if (speed < 320 || dist < world.cupR) {
        sinkBall();
      }
    }
  }

  function sinkBall() {
    world.sunk = true;
    ball.moving = false;
    // Animate move to cup center
    const sx = ball.x, sy = ball.y;
    const ex = world.cupX, ey = world.cupY - ball.r*0.25;
    const start = performance.now();
    const duration = 650;

    function step(t){
      const k = clamp((t - start)/duration, 0, 1);
      const e = easeOutCubic(k);
      ball.x = sx + (ex - sx)*e;
      ball.y = sy + (ey - sy)*e;
      if (k < 1 && world.sunk) {
        requestAnimationFrame(step);
      } else {
        ball.x = ex; ball.y = ey;
        // Speak and show modal
        const isHoleInOne = (world.strokes === 1);
        if (isHoleInOne) {
          speak('Perfect!');
          showToast('Perfect! Hole-in-one!');
        } else {
          speak('In the hole!');
          showToast('In the hole!');
        }
        playSound(sinkSoundBuffer);
        setTimeout(()=> showCompletion(isHoleInOne), 350);
      }
    }
    requestAnimationFrame(step);
  }

  function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }

  function update(t){
    if (!lastT) lastT = t;
    const dt = Math.min(1/30, (t - lastT)/1000);
    lastT = t;

    cloudOffset = (cloudOffset + dt * 15) % (W + 400);

    physics(dt);
    draw();
    requestAnimationFrame(update);
  }

  // Input handling
  canvas.addEventListener('pointerdown', (e) => {
    const p = getCanvasPos(e);
    const d = Math.hypot(p.x - ball.x, p.y - ball.y);
    if (!ball.moving && !world.sunk && d < ball.r*3.5) {
      input.pointerId = e.pointerId;
      input.dragging = true;
      input.dragStart.x = ball.x;
      input.dragStart.y = ball.y;
      input.dragNow.x = p.x;
      input.dragNow.y = p.y;
      canvas.setPointerCapture(e.pointerId);
    }
  });
  canvas.addEventListener('pointermove', (e) => {
    if (input.dragging && e.pointerId === input.pointerId) {
      const p = getCanvasPos(e);
      input.dragNow.x = p.x;
      input.dragNow.y = p.y;
    }
  });
  canvas.addEventListener('pointerup', (e) => {
    if (input.dragging && e.pointerId === input.pointerId) {
      const p = getCanvasPos(e);
      input.dragNow.x = p.x;
      input.dragNow.y = p.y;
      input.dragging = false;
      canvas.releasePointerCapture(e.pointerId);
      if (!ball.moving && !world.sunk) {
        shootWithCurrentAim();
      }
    }
  });
  canvas.addEventListener('pointercancel', (e) => {
    if (input.dragging && e.pointerId === input.pointerId) {
      input.dragging = false;
      canvas.releasePointerCapture(e.pointerId);
    }
  });

  function getCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * DPR,
      y: (e.clientY - rect.top) * DPR
    };
  }

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    if (modal.style.display === 'flex') {
      if (e.key.toLowerCase() === 'n' || e.key === 'Enter' || e.key === ' ') {
        nextHole();
      } else if (e.key.toLowerCase() === 'r') {
        resetHole();
      }
      return;
    }
    if (e.key === 'ArrowLeft') {
      world.aimFromKeyboard = true;
      world.aimAngle = clamp(world.aimAngle + 1*Math.PI/180, 10*Math.PI/180, 80*Math.PI/180);
      e.preventDefault();
    } else if (e.key === 'ArrowRight') {
      world.aimFromKeyboard = true;
      world.aimAngle = clamp(world.aimAngle - 1*Math.PI/180, 10*Math.PI/180, 80*Math.PI/180);
      e.preventDefault();
    } else if (e.key === 'ArrowUp') {
      world.aimFromKeyboard = true;
      world.aimPower = clamp(world.aimPower + 0.02, 0.05, 1);
      e.preventDefault();
    } else if (e.key === 'ArrowDown') {
      world.aimFromKeyboard = true;
      world.aimPower = clamp(world.aimPower - 0.02, 0.05, 1);
      e.preventDefault();
    } else if (e.key === ' ' || e.code === 'Space') {
      if (!ball.moving && !world.sunk) {
        shootWithCurrentAim();
      }
      e.preventDefault();
    } else if (e.key.toLowerCase() === 'r') {
      resetHole();
    } else if (e.key.toLowerCase() === 'n') {
      nextHole();
    }
  }, {passive:false});

  // Buttons
  toggleTTSEl.addEventListener('click', () => {
    ttsEnabled = !ttsEnabled;
    toggleTTSEl.textContent = ttsEnabled ? 'üîä On' : 'üîá Off';
    showToast(ttsEnabled ? 'Voice on' : 'Voice off');
  });
  resetHoleEl.addEventListener('click', () => resetHole());
  newHoleEl.addEventListener('click', () => nextHole());
  playAgainBtn.addEventListener('click', () => { resetHole(); });
  nextHoleBtn.addEventListener('click', () => { nextHole(); });

  const helpModal = document.getElementById('helpModal');
  const helpBtn = document.getElementById('helpBtn');

  helpBtn.addEventListener('click', () => {
    helpModal.style.display = 'flex';
  });

  document.getElementById('closeHelpBtn').addEventListener('click', () => {
    helpModal.style.display = 'none';
  });

  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.style.display = 'none';
    }
  });

  document.getElementById('closeHelpBtn').addEventListener('click', () => {
    document.getElementById('help').style.display = 'none';
  });

  function shootWithCurrentAim(){
    world.hasLaunchedOnce = true;
    const v = world.maxPower * world.aimPower;
    const ang = world.aimAngle;
    ball.vx = Math.cos(ang) * v;
    ball.vy = -Math.sin(ang) * v;
    ball.moving = true;
    world.strokes++;
    updateHUD();
    playSound(hitSoundBuffer);
  }

  // Modal
  function showCompletion(isPerfect){
    modalTitle.textContent = isPerfect ? 'Perfect! Hole-in-one!' : 'In the hole!';
    modalDesc.textContent = `You completed Hole ${world.hole} in ${world.strokes} stroke${world.strokes!==1?'s':''}.`;
    mHoleNum.textContent = world.hole;
    mStrokes.textContent = world.strokes;
    mTotal.textContent = world.total + world.strokes;
    modal.style.display = 'flex';
  }
  function hideModal(){ modal.style.display = 'none'; }

  // Toast
  let toastTimer = null;
  function showToast(msg, time=1200){
    toast.textContent = msg;
    toast.style.display = 'block';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> toast.style.display='none', time);
  }

  // TTS
  let ttsEnabled = true;
  function speak(text){
    if (!ttsEnabled) return;
    try{
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'en-US';
      u.rate = 1.0;
      u.pitch = 1.05;
      window.speechSynthesis.speak(u);
    }catch(err){}
  }

  // Start
  window.addEventListener('resize', resize);
  resize();
  updateHUD();
  requestAnimationFrame(update);

  // Helper: ensure initial user gesture enables audio on mobile
  window.addEventListener('pointerdown', () => {
    if (world.hasLaunchedOnce) return;
    // prime speechSynthesis on iOS
    try{
      const u = new SpeechSynthesisUtterance('');
      window.speechSynthesis.speak(u);
      window.speechSynthesis.cancel();
    }catch(err){}
  }, {once:true});

})();
</script>
</body>
</html>