<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Basket Bounce</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Saira+Stencil+One&display=swap" rel="stylesheet">
<style>
    :root {
        --bg-dark-blue: #1a2a6c;
        --bg-dark-purple: #2e1a47;
        --text-light: #f0f0f0;
        --accent-orange: #ff8c00;
        --rim-red: #e53935;
        --board-glass: rgba(255, 255, 255, 0.15);
        --shadow: rgba(0, 0, 0, 0.5);
    }
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
        background: var(--bg-dark-blue); /* Fallback color */
    }
    canvas {
        display: block;
        background: transparent;
        touch-action: none;
    }
    #ui-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        font-family: 'Arial', sans-serif;
        font-weight: bold;
        color: var(--text-light);
        text-shadow: 2px 2px 4px var(--shadow);
        z-index: 10;
    }
    #game-title {
        font-family: 'Saira Stencil One', sans-serif;
        font-size: 2.8em;
        margin: 0;
        padding: 0;
        line-height: 1;
        color: var(--accent-orange);
    }
    .separator {
        width: 80%;
        height: 1px;
        background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
        position: relative;
        overflow: hidden;
    }
    .separator::after {
        content: '';
        position: absolute;
        top: 0;
        left: -10%;
        width: 10%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        filter: blur(2px);
        animation: shooting-star 15s linear infinite;
    }
    @keyframes shooting-star {
        0% {
            left: -10%;
        }
        100% {
            left: 100%;
        }
    }
    .ui-row {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
    }
    .scoreboard {
        display: flex;
        gap: 15px;
    }
    .score-item, .controls button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 8px 12px;
        text-align: center;
        backdrop-filter: blur(5px);
    }
    .score-item div:first-child {
        font-size: 0.8em;
        opacity: 0.8;
    }
    .score-item div:last-child {
        font-size: 1.2em;
        line-height: 1;
    }
    .controls {
        display: flex;
        gap: 10px;
    }
    .controls button {
        font-size: 1.2em;
        color: var(--text-light);
        cursor: pointer;
        transition: background 0.2s;
    }
    .controls button:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    .controls button.muted {
        opacity: 0.5;
    }
    .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        display: none; /* Hidden by default */
        align-items: center;
        justify-content: center;
        z-index: 100;
    }
    .modal-content {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 20px 30px;
        width: min(400px, 90vw);
        position: relative;
        color: var(--text-light);
    }
    .modal-content h2 {
        font-family: 'Saira Stencil One', sans-serif;
        color: var(--accent-orange);
        margin-top: 0;
        text-align: center;
    }
    .modal-content p {
        text-align: justify;
    }
</style>
</head>
<body>

<div id="ui-container">
    <h1 id="game-title">Basket Bounce</h1>
    <div class="separator"></div>
    <div class="ui-row">
        <div class="controls">
            <button id="voiceBtn">ðŸ”Š</button>
            <button id="resetBtn">Reset</button>
            <button id="helpBtn">?</button>
        </div>
        <div class="scoreboard">
            <div class="score-item">
                <div>Score</div>
                <div id="score">0</div>
            </div>
            <div class="score-item">
                <div>Best</div>
                <div id="highScore">0</div>
            </div>
        </div>
    </div>
</div>
<canvas id="gameCanvas"></canvas>

<div id="helpModal" class="modal-overlay">
    <div class="modal-content">
        <h2>How to Play</h2>
        <p>Click or tap on the basketball and drag to aim. The line shows your shot's trajectory.</p>
        <p>Release to shoot the ball. Try to get it in the hoop!</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const voiceBtn = document.getElementById('voiceBtn');
    const resetBtn = document.getElementById('resetBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');

    // --- Modal Logic ---
    function showHelp() {
        helpModal.style.display = 'flex';
    }
    function hideHelp() {
        helpModal.style.display = 'none';
    }
    helpBtn.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
            hideHelp();
        }
    });

    // --- Sound Engine ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let soundEnabled = true;
    function playSound(type) {
        if (!soundEnabled || !audioCtx) return;
        if (type === 'swish') {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }
    }
    voiceBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        voiceBtn.classList.toggle('muted', !soundEnabled);
        voiceBtn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    });

    // --- Game State and Configuration ---
    let score = 0;
    let highScore = localStorage.getItem('basketBounceBest') || 0;
    let ball, hoop, net;
    const gravity = 0.5;
    const bounceFactor = 0.7;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragEnd = { x: 0, y: 0 };
    let canShoot = true;
    let scoredThisShot = false;

    // --- Background Elements ---
    let stars = [];
    function createStars() {
        stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.7,
                radius: Math.random() * 1.5,
                alpha: Math.random() * 0.5 + 0.5,
                twinkleSpeed: Math.random() * 0.01 + 0.005
            });
        }
    }

    let lensFlare = {
        x: 100,
        y: 100,
        alpha: 0.1,
        speedX: 0.05,
        speedY: 0.03
    };

    // --- Game Objects ---
    function createBall() {
        return {
            x: canvas.width / 2,
            y: canvas.height - 60,
            radius: 25,
            vx: 0,
            vy: 0,
            color: '#ff8c00'
        };
    }

    function createHoop() {
        const hoopWidth = 120;
        const rimHeight = 280;
        return {
            x: canvas.width / 2,
            y: rimHeight,
            width: hoopWidth,
            thickness: 10,
            rimY: rimHeight + 10,
            backboard: {
                width: 150,
                height: 100,
                x: (canvas.width / 2) - 75,
                y: rimHeight - 90,
                color: 'rgba(255, 255, 255, 0.15)'
            },
            rimColor: '#e53935'
        };
    }

    function createNet() {
        const netPoints = [];
        const segments = 10;
        for (let i = 0; i <= segments; i++) {
            netPoints.push({
                x: hoop.x - hoop.width / 2 + (hoop.width / segments) * i,
                y: hoop.rimY,
                oldX: hoop.x - hoop.width / 2 + (hoop.width / segments) * i,
                oldY: hoop.rimY,
                pinned: true
            });
        }
        for (let i = 0; i <= segments; i++) {
            netPoints.push({
                x: hoop.x - hoop.width / 2 + (hoop.width / segments) * i,
                y: hoop.rimY + 40,
                oldX: hoop.x - hoop.width / 2 + (hoop.width / segments) * i,
                oldY: hoop.rimY + 40
            });
        }
        return netPoints;
    }

    // --- Game Lifecycle ---
    function init() {
        resizeCanvas();
        highScoreEl.textContent = highScore;
        resetGame();
        gameLoop();
    }

    function resetGame() {
        score = 0;
        scoreEl.textContent = score;
        ball = createBall();
        hoop = createHoop();
        net = createNet();
        canShoot = true;
        scoredThisShot = false;
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update and Physics ---
    function update() {
        if (!ball) return;

        if (!isDragging) {
            ball.vy += gravity;
            ball.x += ball.vx;
            ball.y += ball.vy;
            handleCollisions();
            checkScoring();
        }
        updateNet();
    }

    function updateNet() {
        for (let i = 0; i < net.length; i++) {
            const p = net[i];
            if (p.pinned) continue;
            const vx = (p.x - p.oldX) * 0.99;
            const vy = (p.y - p.oldY) * 0.99;
            p.oldX = p.x;
            p.oldY = p.y;
            p.x += vx;
            p.y += vy + gravity;
        }

        for (let iter = 0; iter < 5; iter++) {
            for (let i = 0; i < net.length; i++) {
                const p = net[i];
                if (p.pinned) continue;
                const targetY = hoop.rimY + 40;
                if (p.y > targetY) {
                    p.y = p.y + (targetY - p.y) * 0.1;
                }
            }
        }
    }

    function handleCollisions() {
        if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -bounceFactor;
            ball.vx *= 0.9;
            if (!canShoot && Math.abs(ball.vy) < 1) {
                resetBall();
            }
        }

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
            ball.vx *= -0.9;
            ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
        }

        if (ball.x + ball.radius > hoop.backboard.x && ball.x - ball.radius < hoop.backboard.x + hoop.backboard.width &&
            ball.y > hoop.backboard.y && ball.y < hoop.backboard.y + hoop.backboard.height) {
            ball.vx *= -bounceFactor;
            ball.x = (ball.vx > 0) ? hoop.backboard.x - ball.radius : hoop.backboard.x + hoop.backboard.width + ball.radius;
        }
    }

    function checkScoring() {
        const isMovingDown = ball.vy > 0;
        const wasAbove = (ball.y - ball.vy) - ball.radius < hoop.y;
        const isNowBelow = ball.y + ball.radius > hoop.y;
        const withinHoopX = ball.x > hoop.x - hoop.width / 2 && ball.x < hoop.x + hoop.width / 2;

        if (!scoredThisShot && isMovingDown && wasAbove && isNowBelow && withinHoopX) {
            score++;
            scoredThisShot = true;
            if (score > highScore) {
                highScore = score;
                highScoreEl.textContent = highScore;
                localStorage.setItem('basketBounceBest', highScore);
            }
            scoreEl.textContent = score;
            playSound('swish');
            net.forEach(p => { if (!p.pinned) p.y += 15; });
            setTimeout(resetBall, 300);
        } else if (!scoredThisShot) {
            const leftRim = { x: hoop.x - hoop.width / 2, y: hoop.y };
            const rightRim = { x: hoop.x + hoop.width / 2, y: hoop.y };
            const distToLeft = Math.hypot(ball.x - leftRim.x, ball.y - leftRim.y);
            const distToRight = Math.hypot(ball.x - rightRim.x, ball.y - rightRim.y);

            if (distToLeft < ball.radius || distToRight < ball.radius) {
                if (ball.vy > 0) {
                    ball.vy *= -bounceFactor;
                }
            }
        }
    }

    function resetBall() {
        canShoot = true;
        scoredThisShot = false;
        ball.x = canvas.width / 2;
        ball.y = canvas.height - 60;
        ball.vx = 0;
        ball.vy = 0;
    }

    // --- Drawing ---
    function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a2a6c');
        gradient.addColorStop(1, '#2e1a47');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        stars.forEach(star => {
            star.alpha += star.twinkleSpeed;
            if (star.alpha > 1) {
                star.alpha = 1;
                star.twinkleSpeed *= -1;
            } else if (star.alpha < 0.2) {
                star.alpha = 0.2;
                star.twinkleSpeed *= -1;
            }
            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        lensFlare.x += lensFlare.speedX;
        lensFlare.y += lensFlare.speedY;
        if (lensFlare.x < 0 || lensFlare.x > canvas.width) lensFlare.speedX *= -1;
        if (lensFlare.y < 0 || lensFlare.y > canvas.height * 0.5) lensFlare.speedY *= -1;
        
        const flareGradient = ctx.createRadialGradient(lensFlare.x, lensFlare.y, 0, lensFlare.x, lensFlare.y, 100);
        flareGradient.addColorStop(0, `rgba(255, 255, 255, ${lensFlare.alpha})`);
        flareGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = flareGradient;
        ctx.beginPath();
        ctx.arc(lensFlare.x, lensFlare.y, 100, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height * 0.8);
        ctx.lineTo(canvas.width, canvas.height * 0.8);
        ctx.moveTo(0, canvas.height);
        ctx.quadraticCurveTo(canvas.width / 2, canvas.height * 0.5, canvas.width, canvas.height);
        ctx.stroke();
    }

    function draw() {
        drawBackground();
        drawHoop();
        drawNet();
        if (isDragging) {
            drawAimingIndicator();
        }
        drawBall();
    }

    function drawHoop() {
        ctx.save();
        ctx.fillStyle = hoop.backboard.color;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.fillRect(hoop.backboard.x, hoop.backboard.y, hoop.backboard.width, hoop.backboard.height);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 3;
        ctx.strokeRect(hoop.backboard.x, hoop.backboard.y, hoop.backboard.width, hoop.backboard.height);
        ctx.strokeRect(hoop.backboard.x + 20, hoop.backboard.y + 20, hoop.backboard.width - 40, hoop.backboard.height - 30);
        ctx.restore();

        ctx.fillStyle = '#c4332a';
        ctx.beginPath();
        ctx.ellipse(hoop.x, hoop.y + 4, hoop.width / 2, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = hoop.rimColor;
        ctx.beginPath();
        ctx.ellipse(hoop.x, hoop.y, hoop.width / 2, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.ellipse(hoop.x, hoop.y - 2, hoop.width / 2 * 0.9, 3, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawNet() {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.moveTo(net[i].x, net[i].y);
            ctx.lineTo(net[i + 1].x, net[i + 1].y);
            ctx.lineTo(net[i + 11].x, net[i + 11].y);
            ctx.lineTo(net[i + 10].x, net[i + 10].y);
            ctx.closePath();
            ctx.stroke();
        }
    }

    function drawBall() {
        if (!ball) return;
        ctx.save();

        const gradient = ctx.createRadialGradient(
            ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.1,
            ball.x, ball.y, ball.radius * 1.2
        );
        gradient.addColorStop(0, '#ffae73');
        gradient.addColorStop(0.7, '#ff8c00');
        gradient.addColorStop(1, '#d97500');

        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.closePath();

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.ellipse(ball.x, ball.y, ball.radius * 0.5, ball.radius, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(ball.x - ball.radius, ball.y);
        ctx.lineTo(ball.x + ball.radius, ball.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y - ball.radius);
        ctx.bezierCurveTo(
            ball.x + ball.radius * 0.8, ball.y - ball.radius * 0.5,
            ball.x + ball.radius * 0.8, ball.y + ball.radius * 0.5,
            ball.x, ball.y + ball.radius
        );
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y - ball.radius);
        ctx.bezierCurveTo(
            ball.x - ball.radius * 0.8, ball.y - ball.radius * 0.5,
            ball.x - ball.radius * 0.8, ball.y + ball.radius * 0.5,
            ball.x, ball.y + ball.radius
        );
        ctx.stroke();

        const highlight = ctx.createRadialGradient(
            ball.x - ball.radius * 0.4, ball.y - ball.radius * 0.4, 0,
            ball.x - ball.radius * 0.4, ball.y - ball.radius * 0.4, ball.radius * 0.5
        );
        highlight.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
        highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();

        ctx.restore();
    }

    function drawAimingIndicator() {
        const dx = dragEnd.x - dragStart.x;
        const dy = dragEnd.y - dragStart.y;
        const launchVx = -dx / 12;
        const launchVy = -dy / 12;

        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.arc(ball.x, ball.y, ball.radius + 10, 0, Math.PI * 2);
        ctx.stroke();

        const power = Math.hypot(dx, dy);
        const maxPower = Math.min(canvas.width, canvas.height) * 0.4;
        const powerRatio = Math.min(1, power / maxPower);
        const angle = Math.atan2(launchVy, launchVx);

        const arrowLength = 20 + powerRatio * 50;
        const arrowEndX = ball.x + Math.cos(angle) * arrowLength;
        const arrowEndY = ball.y + Math.sin(angle) * arrowLength;

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(arrowEndX, arrowEndY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = 5;
        ctx.stroke();

        ctx.save();
        ctx.translate(arrowEndX, arrowEndY);
        ctx.rotate(angle);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-15, -7);
        ctx.lineTo(-15, 7);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        let simBall = { x: ball.x, y: ball.y };
        let simVx = launchVx;
        let simVy = launchVy;

        ctx.beginPath();
        ctx.setLineDash([3, 6]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.moveTo(simBall.x, simBall.y);

        for (let i = 0; i < 80; i++) {
            simVy += gravity * 0.1;
            simBall.x += simVx;
            simBall.y += simVy;
            ctx.lineTo(simBall.x, simBall.y);
            if (simBall.y > canvas.height || simBall.x < 0 || simBall.x > canvas.width) {
                break;
            }
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // --- Event Handlers ---
    function handlePointerDown(e) {
        if (!canShoot) return;
        const pos = getPointerPos(e);
        const dist = Math.hypot(pos.x - ball.x, pos.y - ball.y);
        if (dist < ball.radius + 20) {
            isDragging = true;
            dragStart = pos;
            dragEnd = pos;
        }
    }

    function handlePointerMove(e) {
        if (isDragging) {
            dragEnd = getPointerPos(e);
        }
    }

    function handlePointerUp(e) {
        if (isDragging) {
            isDragging = false;
            canShoot = false;
            const dx = dragEnd.x - dragStart.x;
            const dy = dragEnd.y - dragStart.y;
            ball.vx = -dx / 12;
            ball.vy = -dy / 12;
        }
    }

    function getPointerPos(evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        createStars(); // Re-create stars on resize
        if (hoop) {
            hoop.x = canvas.width / 2;
            hoop.backboard.x = canvas.width / 2 - hoop.backboard.width / 2;
        }
        if (ball && canShoot) {
            resetBall();
        }
    }

    // --- Setup ---
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointercancel', handlePointerUp);

    resetBtn.addEventListener('click', resetGame);
    window.addEventListener('resize', resizeCanvas);

    init();
</script>

</body>
</html>