<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Name the Object</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    :root{
      --fg:#17324d;
      --glass: rgba(255,255,255,.7);
      --glass-border: rgba(79,157,253,.35);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Helvetica, Arial, sans-serif;
      color: var(--fg);
      background:#dff3ff;
      overflow:hidden;
      -webkit-text-size-adjust: 100%;
    }
    *{ -webkit-tap-highlight-color: transparent; }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: manipulation;
      user-select: none;
    }
    .header{
      position:fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 12px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      text-align: center;
      font-size: clamp(18px, 4vw, 26px);
      font-weight: 800;
      color: #04182B;
      text-shadow: 0 1px 1px rgba(255,255,255,0.6);
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .header .icon {
      font-size: 1.3em;
    }
    .header h1 {
      font-family: 'Fredoka One', cursive; /* Apply playful font */
      font-size: clamp(36px, 7vw, 60px); /* Make it larger */
      margin: 0;
      color: #3498db; /* A single, vibrant color */
      text-shadow: 3px 3px 6px rgba(0,0,0,0.2); /* Stronger shadow */
      line-height: 1; /* Adjust line height */
    }
    .header .subtitle {
      font-size: clamp(16px, 3vw, 22px);
      margin: 0;
      color: #333;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center; /* Added to center content */
      gap: 8px;
    }
    .header {
      flex-direction: column; /* Change to column to stack title and subtitle */
      gap: 5px; /* Adjust gap between title and subtitle */
    }
  </style>
</head>
<body>
  <div class="header">
    <h1 class="game-title-colorful">Name the Object</h1>
    <p class="subtitle"><span class="icon">🔊</span> Tap a picture</p>
  </div>
  <canvas id="c" aria-label="Name the Object game"></canvas>
  <script>
    "use strict";
    (()=>{
      const c = document.getElementById('c');
      const x = c.getContext('2d');
      let W=0,H=0,dpr=1,lastTime=0;

      const BASE = [
        {name:'APPLE',emoji:'🍎'},{name:'STAR',emoji:'⭐'},{name:'CAR',emoji:'🚗'},{name:'HOUSE',emoji:'🏠'},
        {name:'TREE',emoji:'🌳'},{name:'SUN',emoji:'☀️'},{name:'BALL',emoji:'⚽'},{name:'BOAT',emoji:'⛵'},
        {name:'PLANE',emoji:'✈️'},{name:'CAT',emoji:'🐱'},{name:'DOG',emoji:'🐶'},{name:'BIRD',emoji:'🐦'},
        {name:'CHAIR',emoji:'🪑'},{name:'TABLE',emoji:'🛋️'},{name:'BOOK',emoji:'📚'},{name:'PENCIL',emoji:'✏️'},
        {name:'SHOE',emoji:'👟'},{name:'HAT',emoji:'🎩'},{name:'BAG',emoji:'🎒'},{name:'CLOCK',emoji:'🕒'},
        {name:'PHONE',emoji:'📱'},{name:'LAMP',emoji:'💡'},{name:'FLOWER',emoji:'🌸'},{name:'CAKE',emoji:'🎂'},
        {name:'CUP',emoji:'☕'},{name:'FISH',emoji:'🐟'},{name:'HORSE',emoji:'🐴'},{name:'SHEEP',emoji:'🐑'},
        {name:'TRAIN',emoji:'🚂'},{name:'BUS',emoji:'🚌'},{name:'BIKE',emoji:'🚲'},{name:'TRUCK',emoji:'🚚'},
        {name:'KEY',emoji:'🔑'},{name:'RING',emoji:'💍'},{name:'BRUSH',emoji:'🖌️'},{name:'BOTTLE',emoji:'🍼'},
        {name:'SPOON',emoji:'🥄'},{name:'FORK',emoji:'🍴'},{name:'PLATE',emoji:'🍽️'},{name:'COOKIE',emoji:'🍪'},
        {name:'BREAD',emoji:'🍞'},{name:'CHEESE',emoji:'🧀'},{name:'MILK',emoji:'🥛'},{name:'JUICE',emoji:'🧃'},
        {name:'WATER',emoji:'💧'},{name:'ORANGE',emoji:'🍊'},{name:'BANANA',emoji:'🍌'},{name:'GRAPE',emoji:'🍇'},
        {name:'PEAR',emoji:'🍐'}
      ];

      // shuffle-bag for non-repeating sets
      let bag=[];
      function refillBag(){
        bag = BASE.map((_,i)=>i);
        for(let i=bag.length-1;i>0;i--){
          const j=(Math.random()*(i+1))|0; [bag[i],bag[j]]=[bag[j],bag[i]];
        }
      }
      function nextSet(n=5){
        if(bag.length < n) refillBag();
        const ids = bag.splice(0,n);
        return ids.map(i => ({ ...BASE[i] }));
      }

      // gentle colors and visuals
      const COLORS = {
        ring: '#4f9dfd',
        ring2: '#9cd1ff',
        token1: '#ffffff',
        text: '#17324d',
        shadow: 'rgba(0,0,0,0.25)'
      };
      const confettiColors = ['#ff6b6b','#ffd166','#06d6a0','#4ecdc4','#9c6bff'];

      // tokens state
      let items=[];
      let removingCount=0;
      let tokenR=56;

      function toNice(s){ return s.charAt(0) + s.slice(1).toLowerCase(); }

      let vibrationUnlocked = false;
      function unlockVibration() {
        if (!vibrationUnlocked) {
          navigator.vibrate(1);
          vibrationUnlocked = true;
        }
      }

      // speech
      function speak(word){
        try{
          if('speechSynthesis' in window){
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(word.toLowerCase());
            u.lang='en-US';
            u.rate=0.95; u.pitch=1.1;
            speechSynthesis.speak(u);
          } else {
            beep();
          }
        }catch(e){}
      }
      let ac;
      function beep(){
        try{
          ac = ac || new (window.AudioContext||window.webkitAudioContext)();
          const o=ac.createOscillator(), g=ac.createGain();
          o.type='sine'; o.frequency.value=660;
          g.gain.value=0.0001;
          o.connect(g); g.connect(ac.destination);
          const t=ac.currentTime;
          g.gain.setValueAtTime(0.0001,t);
          g.gain.exponentialRampToValueAtTime(0.05,t+0.01);
          g.gain.exponentialRampToValueAtTime(0.0001,t+0.15);
          o.start(t); o.stop(t+0.2);
        }catch(e){}
      }
      function vib(ms=18){ if(vibrationUnlocked && 'vibrate' in navigator) try{ navigator.vibrate(ms); }catch(e){} }

      // clouds
      const clouds=[];
      function makeClouds(){
        clouds.length=0;
        const count = Math.max(4, Math.floor(W/240));
        for(let i=0;i<count;i++){
          clouds.push({ x: Math.random()*W, y: Math.random()*H*0.35 + 10, s: 0.7+Math.random()*1, v: 0.15 + Math.random()*0.25, phase: Math.random()*1000 });
        }
      }

      // particles
      const parts=[];
      function burst(x0,y0,colors){
        const n=14;
        for(let i=0;i<n;i++){
          const a = Math.random()*Math.PI*2;
          const sp = 1+Math.random()*2.2;
          parts.push({ x:x0, y:y0, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-0.6, life:1, color:colors[i%colors.length], size:2+Math.random()*3 });
        }
      }
      function drawParticles(dt){
        for(let i=parts.length-1;i>=0;i--){
          const p=parts[i];
          p.life -= dt*1.7;
          p.x += p.vx*(60*dt*0.5);
          p.y += p.vy*(60*dt*0.5);
          p.vy += 0.02*(60*dt*0.5);
          if(p.life<=0){ parts.splice(i,1); continue; }
          x.globalAlpha = Math.max(0,p.life);
          x.fillStyle = p.color;
          x.beginPath();
          x.arc(p.x,p.y,p.size,0,Math.PI*2);
          x.fill();
          x.globalAlpha = 1;
        }
      }

      // rounded rect helper
      function roundRect(ctx, x0, y0, w, h, r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x0+rr,y0);
        ctx.arcTo(x0+w,y0,x0+w,y0+h,rr);
        ctx.arcTo(x0+w,y0+h,x0,y0+h,rr);
        ctx.arcTo(x0,y0+h,x0,y0,rr);
        ctx.arcTo(x0,y0,x0+w,y0,rr);
        ctx.closePath();
      }

      function layoutNewSet(){
        removingCount=0;
        const set = nextSet(9);
        computeLayout(set);
      }

      function computeLayout(set){
        items=[];
        const count = set.length;
        tokenR = Math.max(44, Math.min(72, Math.min(W,H)/8));
        const columns = Math.min(count, Math.max(2, Math.floor(W / (tokenR*2.4))));
        const rows = Math.ceil(count/columns);
        const gapX = tokenR*0.8, gapY = tokenR*1.3;
        const totalW = columns*tokenR*2 + (columns-1)*gapX;
        const totalH = rows*tokenR*2 + (rows-1)*gapY;
        const startX = Math.max(tokenR+12, (W-totalW)/2 + tokenR);
        const startY = Math.max(120 + tokenR*0.2, H*0.52 - totalH/2 + tokenR);
        for(let i=0;i<count;i++){
          const col = i % columns;
          const row = (i/columns)|0;
          const cx = startX + col*(tokenR*2+gapX);
          const cy = startY + row*(tokenR*2+gapY);
          items.push({
            name:set[i].name, emoji:set[i].emoji,
            x:cx, y:cy, r:tokenR,
            scale:0.001, targetScale:1, alpha:0,
            phase:Math.random()*Math.PI*2,
            removing:false, gone:false
          });
        }
      }

      function drawToken(it, t){
        if (it.scale < 0.01) return; // Prevent drawing when too small

        const bob = Math.sin(t*0.0015 + it.phase)*0.8;
        const scale = it.scale;
        const r = it.r * scale;
        const cx = it.x;
        const cy = it.y + bob;

        x.save();
        x.globalAlpha = scale;

        // Stronger shadow
        x.shadowColor = 'rgba(0,0,0,0.2)';
        x.shadowBlur = 8 * scale;
        x.shadowOffsetY = 3 * scale;
        
        // Solid, friendly base color
        x.fillStyle = '#FFFFF0'; // Ivory color
        x.beginPath(); 
        x.arc(cx, cy, r, 0, Math.PI*2); 
        x.fill();
        
        // Clear shadow for other elements
        x.shadowColor = 'transparent';

        // Bright, solid border
        const pulse = (Math.sin(t*0.003 + it.phase)+1)/2;
        x.lineWidth = Math.max(3, r*0.1);
        x.strokeStyle = `hsl(${200 + pulse*20}, 100%, 60%)`;
        x.beginPath(); 
        // Ensure radius is not negative before drawing the arc
        const arcRadius = r - x.lineWidth/2;
        if (arcRadius > 0) {
          x.arc(cx, cy, arcRadius, 0, Math.PI*2); 
          x.stroke();
        }

        x.restore();

        // emoji icon - drawn at full opacity
        x.font = `bold ${Math.floor(r*1.05)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif`;
        x.textAlign='center'; 
        x.textBaseline='middle';
        x.globalAlpha = scale;
        x.fillText(it.emoji, cx, cy);
        x.globalAlpha = 1;

        // label
        const label = toNice(it.name);
        x.save();
        x.globalAlpha = scale;
        const lh = Math.max(22, r*0.4);
        x.font = `800 ${Math.floor(lh*0.6)}px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif`;
        const lw = x.measureText(label).width + lh;
        const ly = cy + r + lh*0.7;
        const lx = cx - lw/2;
        
        // Label background
        roundRect(x, lx, ly-lh/2, lw, lh, lh/2);
        x.fillStyle = 'rgba(255,255,255,1)'; 
        x.shadowColor = 'rgba(0,0,0,0.15)';
        x.shadowBlur = 6;
        x.shadowOffsetY = 2;
        x.fill();
        x.shadowColor = 'transparent';

        // Label text
        x.fillStyle = '#04182B';
        x.fillText(label, cx, ly+1);
        x.restore();
      }

      function hit(mx,my){
        for(let i=items.length-1;i>=0;i--){
          const it=items[i];
          if(it.gone) continue;
          const r = it.r * it.scale;
          const dx = mx - it.x, dy = my - it.y;
          if(Math.hypot(dx,dy) <= r + 12) return it;
        }
        return null;
      }

      function handleTap(mx,my){
        const it = hit(mx,my);
        if(!it || it.removing) return;
        vib(18);
        speak(toNice(it.name));
        burst(it.x, it.y, confettiColors);
        it.removing = true;
        it.targetScale = 0.001;
        removingCount++;
        if(removingCount >= 9){
          celebrate();
          setTimeout(()=>layoutNewSet(), 1000);
        }
      }

      // celebration text
      let celebrateTime = 0;
      function celebrate(){ celebrateTime = performance.now();
        for(let i=0;i<60;i++){
          const a = Math.random()*Math.PI*2;
          const r = 40 + Math.random()*120;
          parts.push({ x:W/2, y:H*0.3, vx:Math.cos(a)*r*0.02, vy:Math.sin(a)*r*0.02 - 0.5, life:1, color:confettiColors[i%confettiColors.length], size:2+Math.random()*3 });
        }
      }
      function drawCelebrate(t){
        if(!celebrateTime) return;
        const age = (t - celebrateTime)/1000;
        if(age>1.2){ celebrateTime=0; return; }
        const alpha = Math.max(0, 1 - age/1.2);
        const y = H*0.24 - age*20;
        x.save();
        x.globalAlpha = alpha;
        x.font = `800 ${Math.floor(Math.min(W,H)*0.08)}px system-ui, sans-serif`;
        x.textAlign='center';
        x.fillStyle = '#1b4b7a';
        x.fillText('Great job! ⭐', W/2, y);
        x.restore();
      }

      function drawBackground(t){
        const hue1 = (t * 0.01) % 360;
        const hue2 = (hue1 + 40) % 360;
        const color1 = `hsl(${hue1}, 90%, 85%)`;
        const color2 = `hsl(${hue2}, 90%, 90%)`;

        const centerX = W / 2 + Math.sin(t * 0.0002) * W * 0.2;
        const centerY = H / 2 + Math.cos(t * 0.0002) * H * 0.2;
        const maxRadius = Math.hypot(W, H) * 0.8;

        const grad = x.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
        grad.addColorStop(0, color1);
        grad.addColorStop(1, color2);

        x.fillStyle = grad;
        x.fillRect(0,0,W,H);
      }

      function tick(t){
        if(!lastTime) lastTime = t;
        const dt = Math.min(0.05, (t-lastTime)/1000);
        lastTime = t;

        drawBackground(t);

        // update tokens animation
        for(let i=items.length-1;i>=0;i--){
          const it=items[i];
          const spd = it.removing ? 10 : 6;
          it.scale += (it.targetScale - it.scale) * Math.min(1, dt*spd);
          it.alpha = it.scale;
          if(it.removing && it.scale < 0.02){ it.gone = true; items.splice(i,1); }
        }

        // draw tokens
        for(const it of items){ drawToken(it, t); }

        drawParticles(dt);
        drawCelebrate(t);

        requestAnimationFrame(tick);
      }

      function resize(){
        const DPR_LIMIT = 2;
        dpr = Math.min(DPR_LIMIT, window.devicePixelRatio||1);
        const w = c.clientWidth, h = c.clientHeight;
        c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
        x.setTransform(1,0,0,1,0,0);
        x.scale(dpr,dpr);
        W=w; H=h;
        if(items.length){
          const set = items.map(it=>({name:it.name,emoji:it.emoji}));
          computeLayout(set);
        }
      }

      function getPos(e){
        const r = c.getBoundingClientRect();
        return { mx: e.clientX - r.left, my: e.clientY - r.top };
      }

      c.addEventListener('pointerdown', (e)=>{
        if(e.pointerType === 'mouse' && e.button !== 0) return;
        unlockVibration(); // Unlock vibration on the first interaction
        const {mx,my} = getPos(e);
        handleTap(mx,my);
      }, {passive:true});

      window.addEventListener('resize', resize, {passive:true});
      window.addEventListener('orientationchange', resize, {passive:true});
      window.addEventListener('contextmenu', e=>e.preventDefault());

      function init(){
        resize();
        layoutNewSet();
        requestAnimationFrame(tick);
      }
      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', init, {once:true});
      } else init();
    })();
  </script>
</body>
</html>