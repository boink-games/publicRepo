<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <title>Ping pong</title>
  <style>
    :root{
      --bar-height: 56px;
      --neon-cyan: #00eaff;
      --neon-pink: #ff2bd6;
      --neon-lime: #9cff00;
      --text: #cfe9ff;
      --bg-1: #0b0f16;
      --bg-2: #070a11;
      --bg-3: #04060c;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 10% 10%, var(--bg-1), var(--bg-2) 60%, var(--bg-3));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    header#topBar {
      position: fixed;
      top: env(safe-area-inset-top, 0);
      left: 0;
      right: 0;
      height: auto;
      display: flex;
      align-items: center;
      flex-direction: column;
      padding: 6px 16px 8px;
      z-index: 2;
      background: var(--bg-3);
      border-bottom: 2px solid #ff79d6;
      box-shadow: 0 2px 15px rgba(255, 121, 214, 0.2);
      user-select: none;
    }
    header#topBar .title {
      font-family: 'Audiowide', cursive;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      font-size: clamp(28px, 5vw, 36px);
      color: #b1d9ff;
      text-shadow:
        0 0 10px rgba(0,234,255,0.3),
        0 0 20px rgba(0,234,255,0.18);
    }
    .header-controls {
      display: flex;
      gap: 24px;
      margin-top: 4px;
    }
    .key-hint {
      font-size: 12px;
      color: #b1d9ff;
      display: flex;
      align-items: center;
      gap: 6px;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.3);
      cursor: pointer;
    }
    kbd {
      background-color: rgba(11, 15, 22, 0.7);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 11px;
      font-weight: 600;
      color: #e0e8ff;
    }
    canvas#game {
      position: absolute;
      top: calc(var(--bar-height) + env(safe-area-inset-top, 0));
      left: 0;
      width: 100vw;
      height: calc(100vh - var(--bar-height) - env(safe-area-inset-top, 0));
      display: block;
      margin: 0;
      border: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      cursor: crosshair;
    }
    /* Subtle animated abstract grid overlay behind canvas content for extra depth */
    .bg-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 700px at 130% -20%, rgba(0,234,255,0.08), transparent 60%),
        radial-gradient(900px 600px at -20% 120%, rgba(255,43,214,0.07), transparent 60%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.03) 0 2px, transparent 2px 48px);
      mix-blend-mode: screen;
      opacity: 0.35;
      animation: floatGrid 16s linear infinite;
      z-index: 0;
    }
    @keyframes floatGrid {
      0% { transform: translate3d(0,0,0) }
      100% { transform: translate3d(-48px, -48px, 0) }
    }
    /* Hint bubble */
    .hint {
      position: fixed;
      bottom: calc(16px + env(safe-area-inset-bottom, 0));
      left: 50%;
      transform: translateX(-50%);
      background: rgba(8,12,20,0.6);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.03em;
      color: #cfe9ff;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 18px rgba(0,234,255,0.12);
      z-index: 3;
      user-select: none;
      pointer-events: none;
      opacity: 1;
      transition: opacity 400ms ease;
    }
    .hint.hidden { opacity: 0; }
    .point-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      font-family: 'Audiowide', cursive;
      font-size: clamp(32px, 6vw, 48px);
      font-weight: 700;
      color: #fff;
      text-shadow: 0 4px 12px rgba(0,0,0,0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
      z-index: 10;
    }
    .point-message.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    @media (min-width: 768px) {
      header#topBar .title { font-size: 15px; }
      .hint { font-size: 13px; }
    }
  </style>
</head>
<body>
  <header id="topBar">
    <div class="title">Ping pong</div>
    <div class="header-controls">
        <div class="key-hint" id="pauseBtn">‚è∏Ô∏è Pause</div>
        <div class="key-hint" id="restartBtn">üîÑ Restart</div>
        <div class="key-hint" id="volumeBtn"><span id="volumeIcon">üîä</span> Volum</div>
    </div>
  </header>
  <div class="bg-overlay"></div>
  <canvas id="game"></canvas>

  <div id="pointMessage" class="point-message"></div>
  <div id="touchHint" class="hint">Drag to move ‚Ä¢ Tap to start/pause</div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: false });
      const topBar = document.getElementById('topBar');
      const hint = document.getElementById('touchHint');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const volumeBtn = document.getElementById('volumeBtn');
      const volumeIcon = document.getElementById('volumeIcon');
      const pointMessage = document.getElementById('pointMessage');

      const COLORS = {
        left: '#00eaff',
        right: '#ff2bd6',
        ball: '#9cff00',
        net: '#a1bfff',
        text: '#d0f2ff'
      };

      const STATE = {
        w: 0, h: 0, dpr: 1,
        t: 0,
        running: false,
        showingWin: false,
        winner: null,
        scores: [0, 0],
        winScore: 7,
        resetCooldown: 0,
        lastTime: 0
      };

      const PADDLES = {
        margin: 0,
        width: 0,
        height: 0,
        shadow: 0,
        leftY: 0,
        rightY: 0,
        leftTargetY: 0, // for smoothing
        rightTargetY: 0,
        aiSpeed: 0
      };

      const BALL = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        r: 0,
        baseSpeed: 0,
        trail: [],
        trailLen: 14
      };

      let input = {
        active: false,
        y: null,
        keyDir: 0 // -1 up, 1 down
      };

      let audioCtx;
      const particles = [];
      let isMuted = false;

      // --- Audio Engine ---
      function initAudio() {
        if (audioCtx) return;
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.warn("Web Audio API is not supported in this browser");
        }
      }

      function toggleMute() {
        isMuted = !isMuted;
        volumeIcon.textContent = isMuted ? 'üîá' : 'üîä';
      }

      function playSound(type) {
        if (!audioCtx || isMuted) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

        if (type === 'hit') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
          oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1);
        } else if (type === 'score') {
          oscillator.type = 'triangle';
          oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
          setTimeout(() => {
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            gain2.gain.setValueAtTime(0.2, audioCtx.currentTime);
            osc2.type = 'triangle';
            osc2.frequency.setValueAtTime(659.25, audioCtx.currentTime); // E5
            gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
            osc2.start(audioCtx.currentTime);
            osc2.stop(audioCtx.currentTime + 0.4);
          }, 100);
        }

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.3);
      }

      // --- Particle Engine ---
      function createParticles(x, y, color) {
        const count = 10 + Math.floor(Math.random() * 10);
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 50 + Math.random() * 150;
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.4,
            maxLife: 0.8,
            size: 1 + Math.random() * 2,
            color: color
          });
        }
      }

      function updateAndDrawParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= dt;
          if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.98; // friction
          p.vy *= 0.98;

          const alpha = p.life / p.maxLife;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const cssWidth = window.innerWidth;
        const cssHeight = Math.max(160, window.innerHeight - (topBar?.getBoundingClientRect().height || 0));
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        STATE.w = cssWidth;
        STATE.h = cssHeight;
        STATE.dpr = dpr;

        recomputeSizes();
      }

      function recomputeSizes() {
        const w = STATE.w;
        const h = STATE.h;
        const s = Math.min(w, h);

        PADDLES.margin = Math.max(10, w * 0.02);
        PADDLES.width = Math.max(8, w * 0.015);
        PADDLES.height = Math.max(60, h * 0.18);
        PADDLES.shadow = Math.max(8, s * 0.025);
        PADDLES.aiSpeed = Math.max(220, h * 0.55);

        // Keep paddles centered proportionally on resize
        const leftRatio = (PADDLES.leftY + PADDLES.height / 2) / (STATE.h || 1);
        const rightRatio = (PADDLES.rightY + PADDLES.height / 2) / (STATE.h || 1);
        PADDLES.leftY = Math.max(0, (leftRatio || 0.5) * h - PADDLES.height / 2);
        PADDLES.rightY = Math.max(0, (rightRatio || 0.5) * h - PADDLES.height / 2);

        BALL.r = Math.max(6, Math.min(14, s * 0.012));
        BALL.baseSpeed = Math.max(250, s * 0.5);

        if (!STATE.running && !STATE.showingWin) {
          resetBall(Math.random() < 0.5 ? -1 : 1);
        }
      }

      function resetBall(direction) {
        BALL.x = STATE.w * 0.5;
        BALL.y = STATE.h * 0.5;
        const speed = BALL.baseSpeed * 0.9;
        const angle = (Math.random() * 0.6 - 0.3); // slight vertical angle
        BALL.vx = Math.cos(angle) * speed * direction;
        BALL.vy = Math.sin(angle) * speed;
        BALL.trail.length = 0;
        STATE.resetCooldown = 0.65;
      }

      function startGame() {
        if (STATE.showingWin) {
          STATE.showingWin = false;
          STATE.scores = [0, 0];
          STATE.winner = null;
        }
        initAudio(); // Initialize audio on first interaction
        STATE.running = true;
        hideHint();
      }

      function togglePause() {
        if (STATE.showingWin) return;
        STATE.running = !STATE.running;
        if (STATE.running) hideHint();
        else showHint("Paused ‚Ä¢ Tap to resume");
      }

      function showHint(text) {
        if (!hint) return;
        if (text) hint.textContent = text;
        hint.classList.remove('hidden');
      }
      function hideHint() {
        if (!hint) return;
        hint.classList.add('hidden');
      }

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      // Input handling
      canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        input.active = true;
        const pos = getPointerPos(e);
        input.y = pos.y;
        PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        PADDLES.leftY = clamp(PADDLES.leftTargetY, 0, STATE.h - PADDLES.height);

        // Start or toggle pause
        if (!STATE.running && !STATE.showingWin) {
          startGame();
        } else if (STATE.showingWin) {
          startGame();
        } else {
          // Short taps that aren't dragging can toggle pause; we'll only toggle on quick taps
          // Here we won't immediately toggle to avoid accidental pauses while dragging
        }
      }, { passive: false });

      canvas.addEventListener('pointermove', (e) => {
        if (!input.active && e.pointerType === 'mouse') {
          // Allow hovering with mouse to control too
          const pos = getPointerPos(e);
          input.y = pos.y;
          PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        } else if (input.active) {
          const pos = getPointerPos(e);
          input.y = pos.y;
          PADDLES.leftTargetY = pos.y - PADDLES.height / 2;
        }
        e.preventDefault();
      }, { passive: false });

      canvas.addEventListener('pointerup', (e) => {
        input.active = false;
      });

      function resetGame() {
        STATE.showingWin = false;
        STATE.scores = [0, 0];
        resetBall(Math.random() < 0.5 ? -1 : 1);
        STATE.running = false;
        showHint("Tap to start ‚Ä¢ Drag to move");
      }

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePause();
          return;
        }
        if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          resetGame();
          return;
        }
        if (e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          input.keyDir = -1;
        } else if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          input.keyDir = 1;
        }
      });

      window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          if (input.keyDir < 0) input.keyDir = 0;
        } else if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          if (input.keyDir > 0) input.keyDir = 0;
        }
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden && STATE.running) {
          STATE.running = false;
          showHint("Paused ‚Ä¢ Tap to resume");
        }
      });

      function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        return { x, y };
      }

      // Game update
      function update(dt) {
        STATE.t += dt;

        // Handle reset cooldown
        if (STATE.resetCooldown > 0) {
          STATE.resetCooldown -= dt;
          if (STATE.resetCooldown < 0) STATE.resetCooldown = 0;
        }

        // Player paddle control (smoothing for touch)
        if (input.keyDir !== 0) {
          const speed = Math.max(270, STATE.h * 0.7);
          PADDLES.leftTargetY = PADDLES.leftY + input.keyDir * speed * dt;
        }
        const smooth = 1 - Math.pow(0.001, dt); // time-based smoothing factor
        PADDLES.leftY += (clamp(PADDLES.leftTargetY, 0, STATE.h - PADDLES.height) - PADDLES.leftY) * smooth;

        // AI movement
        aiMovement(dt);

        // Ball physics
        if (STATE.resetCooldown <= 0) {
          BALL.x += BALL.vx * dt;
          BALL.y += BALL.vy * dt;
        }

        // Wall collisions
        if (BALL.y - BALL.r <= 0) {
          BALL.y = BALL.r;
          BALL.vy = Math.abs(BALL.vy);
        } else if (BALL.y + BALL.r >= STATE.h) {
          BALL.y = STATE.h - BALL.r;
          BALL.vy = -Math.abs(BALL.vy);
        }

        // Paddle collisions
        const leftX = PADDLES.margin;
        const rightX = STATE.w - PADDLES.margin - PADDLES.width;

        // Left
        if (BALL.x - BALL.r <= leftX + PADDLES.width) {
          if (BALL.y >= PADDLES.leftY && BALL.y <= PADDLES.leftY + PADDLES.height) {
            BALL.x = leftX + PADDLES.width + BALL.r;
            bounceOnPaddle(true, PADDLES.leftY);
          }
        }
        // Right
        if (BALL.x + BALL.r >= rightX) {
          if (BALL.y >= PADDLES.rightY && BALL.y <= PADDLES.rightY + PADDLES.height) {
            BALL.x = rightX - BALL.r;
            bounceOnPaddle(false, PADDLES.rightY);
          }
        }

        // Scoring
        if (BALL.x + BALL.r < 0) {
          STATE.scores[1] += 1;
          showPointMessage(false);
          if (STATE.scores[1] >= STATE.winScore) {
            STATE.showingWin = true;
            STATE.winner = 'Right';
            STATE.running = false;
            showHint("Right Player Won ‚Ä¢ Tap to play again");
            playSound('score');
          } else {
            resetBall(1);
          }
        } else if (BALL.x - BALL.r > STATE.w) {
          STATE.scores[0] += 1;
          showPointMessage(true);
          if (STATE.scores[0] >= STATE.winScore) {
            STATE.showingWin = true;
            STATE.winner = 'Left';
            STATE.running = false;
            showHint("Left Player Won ‚Ä¢ Tap to play again");
            playSound('score');
          } else {
            resetBall(-1);
          }
        }

        // Trail
        if (STATE.resetCooldown <= 0) {
          BALL.trail.push({ x: BALL.x, y: BALL.y });
          if (BALL.trail.length > BALL.trailLen) BALL.trail.shift();
        }
      }

      function aiMovement(dt) {
        const center = PADDLES.rightY + PADDLES.height / 2;
        // Predictive target with slight bias and adaptive difficulty
        const reaction = clamp(0.12 + Math.abs(BALL.vx) / 1400, 0.12, 0.45);
        const targetY = BALL.y + Math.sin(STATE.t * 2) * 10;
        const desired = clamp(targetY - PADDLES.height / 2, 0, STATE.h - PADDLES.height);

        // Follow target but not perfectly, scaled by aiSpeed
        const dy = desired - PADDLES.rightY;
        const step = Math.sign(dy) * Math.min(Math.abs(dy), PADDLES.aiSpeed * dt * (0.7 + reaction));
        PADDLES.rightY = clamp(PADDLES.rightY + step, 0, STATE.h - PADDLES.height);
      }

      function bounceOnPaddle(isLeft, paddleY) {
        const paddleCenterY = paddleY + PADDLES.height / 2;
        const relative = (BALL.y - paddleCenterY) / (PADDLES.height / 2); // [-1,1]
        const angle = clamp(relative, -0.9, 0.9) * (Math.PI / 3); // up to 60 deg
        let speed = Math.hypot(BALL.vx, BALL.vy) * 1.04;
        const maxSpeed = BALL.baseSpeed * 1.6;
        speed = Math.min(speed, maxSpeed);

        const dir = isLeft ? 1 : -1;
        BALL.vx = dir * Math.cos(angle) * speed;
        BALL.vy = Math.sin(angle) * speed;

        // Small extra kick if hit near paddle edge
        if (Math.abs(relative) > 0.75) BALL.vy *= 1.05;

        // Effects
        playSound('hit');
        createParticles(BALL.x, BALL.y, isLeft ? COLORS.left : COLORS.right);
      }

      function showPointMessage(playerScored) {
        const messages = playerScored 
          ? ["Well done!", "Great!", "Nice one!", "Awesome!"]
          : ["Try again!", "So close!", "You can do it!", "Keep trying!"];
        const message = messages[Math.floor(Math.random() * messages.length)];
        
        pointMessage.textContent = message;
        pointMessage.style.color = playerScored ? COLORS.left : COLORS.right;
        pointMessage.classList.add('show');

        setTimeout(() => {
          pointMessage.classList.remove('show');
        }, 1200);
      }

      // Render
      function draw(dt) {
        drawBackground();

        if (STATE.showingWin) {
          drawArena();
          drawUI();
          drawWinOverlay();
          updateAndDrawParticles(dt); // Pass dt here as well
          return;
        }

        drawArena();
        drawUI();
        updateAndDrawParticles(dt);
      }

      function drawBackground() {
        const w = STATE.w, h = STATE.h;
        // Base gradient
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#060814');
        grad.addColorStop(1, '#03040a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        // Animated neon rays
        const t = STATE.t * 0.15;
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.globalCompositeOperation = 'screen';
        ctx.lineWidth = 2;
        const step = Math.max(28, Math.min(44, Math.floor(Math.min(w, h) * 0.05)));
        const offset = (t * 120) % step;
        for (let i = -step; i < w + h; i += step) {
          ctx.strokeStyle = i % (step * 3) === 0 ? 'rgba(0,234,255,0.25)' : 'rgba(255,43,214,0.12)';
          ctx.beginPath();
          ctx.moveTo(i - offset, -10);
          ctx.lineTo(-10, i - offset);
          ctx.stroke();
        }
        ctx.restore();

        // Vignette
        const vg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.2, w/2, h/2, Math.max(w,h)*0.7);
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = vg;
        ctx.fillRect(0, 0, w, h);
      }

      function drawArena() {
        drawNet();

        // Paddles
        drawPaddle(PADDLES.margin, PADDLES.leftY, PADDLES.width, PADDLES.height, COLORS.left, PADDLES.shadow);
        drawPaddle(STATE.w - PADDLES.margin - PADDLES.width, PADDLES.rightY, PADDLES.width, PADDLES.height, COLORS.right, PADDLES.shadow);

        // Ball trail
        drawBallTrail();

        // Ball
        drawBall(BALL.x, BALL.y, BALL.r, COLORS.ball);
      }

      function drawNet() {
        const x = STATE.w / 2;
        const dash = Math.max(10, STATE.h * 0.02);
        ctx.save();
        ctx.lineWidth = Math.max(2, STATE.w * 0.003);
        ctx.setLineDash([dash, dash * 0.7]);
        ctx.strokeStyle = 'rgba(161,191,255,0.25)';
        ctx.shadowColor = 'rgba(161,191,255,0.4)';
        ctx.shadowBlur = Math.max(6, Math.min(18, Math.min(STATE.w, STATE.h) * 0.02));
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, STATE.h);
        ctx.stroke();
        ctx.restore();
      }

      function drawPaddle(x, y, w, h, color, glow) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = glow;
        const r = Math.min(w, h) * 0.25;
        roundRect(ctx, x, y, w, h, r);
        ctx.fill();

        // Inner glossy edge
        const inner = ctx.createLinearGradient(x, y, x + w, y);
        inner.addColorStop(0, 'rgba(255,255,255,0.18)');
        inner.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.shadowBlur = 0;
        ctx.fillStyle = inner;
        roundRect(ctx, x+1, y+1, w-2, h-2, r*0.8);
        ctx.fill();
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      function drawBall(x, y, r, color) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowColor = color;
        ctx.shadowBlur = Math.max(10, r * 3.2);

        // Core
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        // Soft aura
        const g = ctx.createRadialGradient(x, y, r * 0.2, x, y, r * 3.2);
        g.addColorStop(0, color + 'cc');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r * 3.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawBallTrail() {
        if (!BALL.trail.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < BALL.trail.length; i++) {
          const p = BALL.trail[i];
          const alpha = i / BALL.trail.length;
          const radius = BALL.r * (0.5 + alpha * 0.8);
          ctx.fillStyle = `rgba(156,255,0,${alpha * 0.3})`;
          ctx.shadowColor = 'rgba(156,255,0,0.8)';
          ctx.shadowBlur = Math.max(6, BALL.r * 2);
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawUI() {
        const w = STATE.w;
        const h = STATE.h;
        const s = Math.min(w, h);

        // Scores
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fontSize = Math.max(24, s * 0.06);
        const iconSize = fontSize * 0.9;
        const scoreXOffset = iconSize * 0.7;
        const iconShadowBlur = s * 0.03;
        const yPos = h * 0.08 + fontSize / 2;

        // Player Icon (Left)
        ctx.shadowColor = COLORS.left;
        ctx.shadowBlur = iconShadowBlur;
        ctx.fillStyle = '#e6fbff';
        ctx.font = `${iconSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText('üòä', w * 0.25 - scoreXOffset, yPos);

        // Left score
        ctx.font = `700 ${fontSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.shadowColor = COLORS.left;
        ctx.shadowBlur = iconShadowBlur;
        ctx.fillStyle = '#e6fbff';
        ctx.fillText(STATE.scores[0], w * 0.25 + scoreXOffset, yPos);

        // AI Icon (Right)
        ctx.shadowColor = COLORS.right;
        ctx.shadowBlur = iconShadowBlur;
        ctx.fillStyle = '#e6fbff';
        ctx.font = `${iconSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText('ü§ñ', w * 0.75 - scoreXOffset, yPos);

        // Right score
        ctx.font = `700 ${fontSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.shadowColor = COLORS.right;
        ctx.shadowBlur = iconShadowBlur;
        ctx.fillText(STATE.scores[1], w * 0.75 + scoreXOffset, yPos);
        ctx.restore();

        // Instructions overlay when not running
        if (!STATE.running && !STATE.showingWin) {
          ctx.save();
          const s = Math.min(w, h);
          const btnW = Math.max(150, s * 0.4);
          const btnH = Math.max(50, s * 0.15);
          const btnX = w / 2 - btnW / 2;
          const btnY = h / 2 - btnH / 2;
          const r = btnH * 0.3;

          // Button Shadow
          ctx.shadowColor = 'rgba(0, 234, 255, 0.5)';
          ctx.shadowBlur = s * 0.05;

          // Button Gradient
          const grad = ctx.createLinearGradient(btnX, btnY, btnX, btnY + btnH);
          grad.addColorStop(0, '#00eaff');
          grad.addColorStop(1, '#00a2ff');
          ctx.fillStyle = grad;
          
          // Draw button
          roundRect(ctx, btnX, btnY, btnW, btnH, r);
          ctx.fill();
          
          // Reset shadow for text
          ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
          ctx.shadowBlur = 5;

          // Button Text
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const fontSize = Math.max(24, btnH * 0.4);
          ctx.font = `800 ${fontSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          ctx.fillStyle = '#ffffff';
          ctx.fillText('START', w / 2, h / 2);
          
          ctx.restore();
        }

        // Cooldown indicator
        if (STATE.resetCooldown > 0) {
          const prog = 1 - (STATE.resetCooldown / 0.65);
          const radius = Math.max(20, s * 0.06);
          ctx.save();
          ctx.translate(w/2, h/2);
          ctx.strokeStyle = 'rgba(200,230,255,0.35)';
          ctx.lineWidth = Math.max(3, s * 0.006);
          ctx.beginPath();
          ctx.arc(0, 0, radius, -Math.PI/2, -Math.PI/2 + prog * Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawWinOverlay() {
        const w = STATE.w, h = STATE.h, s = Math.min(w, h);
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.fillStyle = '#e8faff';
        ctx.shadowColor = STATE.winner === 'Left' ? COLORS.left : COLORS.right;
        ctx.shadowBlur = s * 0.03;

        const titleSize = Math.max(28, s * 0.065);
        const subSize = Math.max(14, s * 0.028);
        const scoreSize = Math.max(18, s * 0.04);

        ctx.font = `800 ${titleSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(`${STATE.winner} Player Won!`, w/2, h*0.42);

        ctx.font = `700 ${scoreSize}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = STATE.winner === 'Left' ? COLORS.left : COLORS.right;
        ctx.shadowColor = STATE.winner === 'Left' ? COLORS.left : COLORS.right;
        ctx.shadowBlur = s * 0.025;
        ctx.fillText(`Final Score: ${STATE.scores[0]} - ${STATE.scores[1]}`, w/2, h*0.55);

        ctx.font = `600 ${subSize * 0.9}px UI-Sans, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = '#b1d9ff';
        ctx.shadowColor = 'rgba(0,234,255,0.3)';
        ctx.shadowBlur = s * 0.02;
        ctx.fillText('Tap to play again', w/2, h*0.68);
        ctx.restore();
      }

      // Main loop
      function loop(ts) {
        if (!STATE.lastTime) STATE.lastTime = ts;
        const dt = clamp((ts - STATE.lastTime) / 1000, 0, 0.05);
        STATE.lastTime = ts;

        if (STATE.running) {
          update(dt);
        }

        draw(dt);
        requestAnimationFrame(loop);
      }

      // Init
      function init() {
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);
        volumeBtn.addEventListener('click', toggleMute);

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Place paddles in center
        PADDLES.leftY = STATE.h / 2 - PADDLES.height / 2;
        PADDLES.rightY = STATE.h / 2 - PADDLES.height / 2;
        PADDLES.leftTargetY = PADDLES.leftY;
        PADDLES.rightTargetY = PADDLES.rightY;

        resetBall(Math.random() < 0.5 ? -1 : 1);

        // Initial hint timeout fade
        setTimeout(() => hideHint(), 4000);

        requestAnimationFrame(loop);
      }

      init();
    })();
  </script>
</body>
</html>