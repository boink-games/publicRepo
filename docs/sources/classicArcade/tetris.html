<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tetris - Modern Compact</title>
  <style>
    :root{
      --bg1:#0f1220;
      --bg2:#161b2f;
      --accent:#72f5f9;
      --text:#e9eef5;
      --muted:#9aa3af;
      --grid:#1e243b;
      --border:#2a3356;
      --btn:#1b2342;
      --btn-active:#2a3769;
      --glow:#75f5ff;
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 70% -10%, #1e2a55 0, transparent 40%),
        radial-gradient(800px 600px at 0% 100%, #1a274a 0, transparent 50%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      display:grid;
      grid-template-rows:min-content 1fr min-content;
      gap:8px;
      height:100dvh;
      overflow:hidden;
      overscroll-behavior:none;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 10px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
      backdrop-filter:saturate(120%) blur(4px);
    }
    .title{
      display:flex; gap:8px; align-items:center;
      font-weight:700; letter-spacing:.4px;
      text-transform:uppercase;
      font-size: clamp(.9rem, 1.8vw, 1.05rem);
    }
    .title .dot{
      width:10px; height:10px; border-radius:50%;
      background: linear-gradient(135deg, #61ffe2, #3bc8ff);
      box-shadow: 0 0 12px #61ffe2;
    }
    .hud{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      font-size: clamp(.8rem, 1.8vw, .95rem);
    }
    .stat{display:flex; gap:6px; align-items:center; color:var(--muted); white-space:nowrap}
    .stat b{color:var(--text)}
    .next-wrap{display:flex; gap:6px; align-items:center;}
    .next-label{color:var(--muted)}
    #next{
      width:56px; height:56px;
      border-radius:10px; background:#0f1328;
      border:1px solid var(--border);
      display:block;
    }

    .game-area{
      display:grid; place-items:center;
      padding:4px 10px 0 10px;
      min-height:0; /* allow shrinking */
    }
    .canvas-wrap{
      position:relative;
      width:100%;
      height:100%;
      max-width:100%;
      max-height:100%;
      border-radius:16px;
      border:1px solid var(--border);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.03),
        0 10px 25px rgba(0,0,0,.35),
        0 0 60px rgba(58, 168, 255, .08);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0)),
        radial-gradient(120% 100% at 50% 0%, rgba(138,192,255,0.08), transparent 60%),
        #0b0f22;
      overflow:hidden;
      isolation:isolate;
    }
    .canvas-wrap::after{
      content:"";
      position:absolute; inset:-2px;
      pointer-events:none;
      border-radius:18px;
      background: conic-gradient(from 0deg, rgba(99,212,255,.25), rgba(114,245,249,.2), rgba(99,212,255,.25));
      filter: blur(16px);
      opacity:.25;
      animation: glow 6s linear infinite;
      z-index:0;
    }
    @keyframes glow{ to{ transform:rotate(1turn); } }
    @media (prefers-reduced-motion: reduce){
      .canvas-wrap::after{animation:none; opacity:.15}
    }

    canvas#tetris{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }
    .overlay{
      position:absolute; inset:0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:space-between; padding:6px;
      z-index:1;
    }
    .score-badge{
      background: rgba(18, 24, 52, .65);
      border:1px solid var(--border);
      padding:5px 8px; border-radius:12px;
      font-size:.88rem;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
    }
    .score-badge b{color:var(--accent)}
    .high{
      opacity:.85; font-size:.84rem; margin-left:6px; color:var(--muted);
    }

    nav.controls{
      padding:6px 8px calc(8px + env(safe-area-inset-bottom));
      display:grid; gap:8px;
      background:linear-gradient(180deg, rgba(0,0,0,0), rgba(2,6,18,.65) 30%, rgba(2,6,18,.9) 60%);
      backdrop-filter: blur(4px);
    }
    .row{
      display:flex; gap:8px; justify-content:center; align-items:center;
    }
    .btn{
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      touch-action: manipulation;
      min-width: clamp(48px, 16vw, 72px);
      min-height: clamp(48px, 9vh, 64px);
      padding:10px 14px;
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
      border:1px solid var(--border);
      color:var(--text); font-weight:700;
      display:flex; align-items:center; justify-content:center;
      gap:8px;
      box-shadow: 0 6px 18px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.02);
      transition: transform .06s ease, background .12s ease, box-shadow .2s ease;
    }
    .btn:active{background:var(--btn-active); transform: translateY(1px) scale(.98)}
    .btn.wide{min-width: clamp(90px, 26vw, 140px)}
    .btn .ico{width:0;height:0;border-style:solid}
    .ico.left{border-width:10px 14px 10px 0;border-color: transparent var(--text) transparent transparent}
    .ico.right{border-width:10px 0 10px 14px;border-color: transparent transparent transparent var(--text)}
    .ico.down{border-width:14px 10px 0 10px;border-color: var(--text) transparent transparent transparent}
    .ico.rotate{width:22px;height:22px;border-radius:50%;border:3px solid var(--text); position:relative}
    .ico.rotate:after{content:''; position:absolute; top:-6px; right:-6px; width:0; height:0; border-style:solid; border-width:8px 6px 0 6px; border-color: var(--text) transparent transparent transparent; transform:rotate(45deg)}
    .ico.drop{width:20px;height:20px;border-radius:6px; background: linear-gradient(135deg, #61ffe2, #3bc8ff); box-shadow: 0 0 10px #3bc8ff}

    /* Landscape tweaks: tighter header and controls */
    @media (orientation: landscape){
      header{padding:4px 8px}
      .hud{gap:8px}
      nav.controls{padding:4px 6px calc(6px + env(safe-area-inset-bottom)); gap:6px}
      .row{gap:6px}
      .btn{min-height: clamp(44px, 16vh, 56px); min-width: clamp(44px, 12vw, 64px)}
      .btn.wide{min-width: clamp(80px, 20vw, 120px)}
      #next{width:48px; height:48px}
    }

    /* Larger screens: side panel layout available space, bigger next */
    @media (min-width: 860px){
      .game-area{padding:12px 20px 0}
      .title{font-size:1.05rem}
      #next{width:84px;height:84px}
    }
  </style>
</head>
<body>
  <header>
    <div class="title"><span class="dot"></span> Tetris</div>
    <div class="hud">
      <div class="stat">Score: <b id="score">0</b></div>
      <div class="stat">Lines: <b id="lines">0</b></div>
      <div class="stat">Level: <b id="level">0</b></div>
      <div class="next-wrap">
        <span class="next-label">Next</span>
        <canvas id="next" width="96" height="96"></canvas>
      </div>
    </div>
  </header>

  <main class="game-area">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="tetris"></canvas>
      <div class="overlay">
        <div class="score-badge">
          Score <b id="scoreBadge">0</b>
          <span class="high">Best <b id="best">0</b></span>
        </div>
      </div>
    </div>
  </main>

  <nav class="controls" aria-label="Game controls">
    <div class="row">
      <button class="btn" id="btnLeft" aria-label="Move left"><span class="ico left"></span></button>
      <button class="btn wide" id="btnRotate" aria-label="Rotate"><span class="ico rotate"></span></button>
      <button class="btn" id="btnRight" aria-label="Move right"><span class="ico right"></span></button>
    </div>
    <div class="row">
      <button class="btn wide" id="btnDown" aria-label="Soft drop"><span class="ico down"></span></button>
      <button class="btn wide" id="btnDrop" aria-label="Hard drop"><span class="ico drop"></span></button>
    </div>
  </nav>

  <script>
    (() => {
      const COLS = 12;
      const ROWS = 20;
      const RATIO = COLS / ROWS;

      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d', { alpha: true });
      const nextCanvas = document.getElementById('next');
      const nctx = nextCanvas.getContext('2d', { alpha: true });

      const scoreEl = document.getElementById('score');
      const linesEl = document.getElementById('lines');
      const levelEl = document.getElementById('level');
      const scoreBadge = document.getElementById('scoreBadge');
      const bestEl = document.getElementById('best');

      const headerEl = document.querySelector('header');
      const controlsEl = document.querySelector('.controls');
      const gameAreaEl = document.querySelector('.game-area');
      const wrap = document.getElementById('canvasWrap');

      // Controls
      const btnLeft = document.getElementById('btnLeft');
      const btnRight = document.getElementById('btnRight');
      const btnRotate = document.getElementById('btnRotate');
      const btnDown = document.getElementById('btnDown');
      const btnDrop = document.getElementById('btnDrop');

      const pieceTypes = 'TJLOSZI';

      const colors = [
        null,
        '#ff477e', // 1
        '#3bc9ff', // 2
        '#2ef7a0', // 3
        '#d26bff', // 4
        '#ff9f43', // 5
        '#ffd166', // 6
        '#5b7cfa', // 7
      ];

      // State
      const arena = createMatrix(COLS, ROWS);
      const player = {
        pos: { x: 0, y: 0 },
        matrix: null,
        score: 0,
        lines: 0,
        level: 0,
      };

      // Timing
      let dropCounter = 0;
      let dropInterval = 1000;
      let lastTime = 0;

      // Visual FX
      let flashAlpha = 0;
      let cellSize = 24; // computed on resize
      let dpr = window.devicePixelRatio || 1;

      // Next piece preview
      let nextPiece = createPiece(randomType());

      // Highscore
      const BEST_KEY = 'tetris_best_v3';
      let best = Number(localStorage.getItem(BEST_KEY) || 0);
      bestEl.textContent = best;

      // Resize and initialize
      resizeAll();
      window.addEventListener('resize', debounce(resizeAll, 100));
      window.addEventListener('orientationchange', () => setTimeout(resizeAll, 200));
      document.addEventListener('visibilitychange', () => {
        // redraw on return (address bar size may change)
        if (!document.hidden) setTimeout(resizeAll, 100);
      });

      // Input - Keyboard
      const keyMap = new Map([
        ['ArrowLeft', () => move(-1)],
        ['ArrowRight', () => move(1)],
        ['ArrowDown', softDrop],
        ['Space', hardDrop],
        ['KeyX', () => rotate(1)],
        ['KeyW', () => rotate(1)],
        ['ArrowUp', () => rotate(1)],
        ['KeyZ', () => rotate(-1)],
        ['KeyQ', () => rotate(-1)],
      ]);
      document.addEventListener('keydown', (e) => {
        if (keyMap.has(e.code)) {
          e.preventDefault();
          keyMap.get(e.code)();
        }
      }, { passive: false });

      // Input - Touch/Pointer buttons
      pressRepeat(btnLeft, () => move(-1), 140, 200);
      pressRepeat(btnRight, () => move(1), 140, 200);
      pressRepeat(btnDown, softDrop, 70, 120);
      btnRotate.addEventListener('pointerdown', (e) => { e.preventDefault(); rotate(1); });
      btnDrop.addEventListener('pointerdown', (e) => { e.preventDefault(); hardDrop(); });

      // Gestures on canvas (swipe/tap)
      setupGestures(canvas);

      // Start
      playerReset();
      updateScore();
      requestAnimationFrame(update);

      // Functions

      function createMatrix(w, h) {
        const m = [];
        while (h--) m.push(new Array(w).fill(0));
        return m;
      }

      function createPiece(type) {
        switch (type) {
          case 'I': return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
          case 'L': return [[0,2,0],[0,2,0],[0,2,2]];
          case 'J': return [[0,3,0],[0,3,0],[3,3,0]];
          case 'O': return [[4,4],[4,4]];
          case 'Z': return [[5,5,0],[0,5,5],[0,0,0]];
          case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
          case 'T': return [[0,7,0],[7,7,7],[0,0,0]];
        }
      }
      function randomType(){ return pieceTypes[(Math.random()*pieceTypes.length)|0]; }

      function collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; y++) {
          for (let x = 0; x < m[y].length; x++) {
            if (m[y][x] !== 0 &&
              ((arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0)) {
              return true;
            }
          }
        }
        return false;
      }

      function merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              arena[y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }

      function arenaSweep() {
        let rowCount = 1;
        let linesCleared = 0;
        outer: for (let y = arena.length - 1; y >= 0; y--) {
          for (let x = 0; x < arena[y].length; x++) {
            if (arena[y][x] === 0) continue outer;
          }
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          y++;
          linesCleared++;
          player.score += rowCount * 100;
          rowCount *= 2;
        }
        if (linesCleared > 0) {
          player.lines += linesCleared;
          player.level = Math.floor(player.lines / 10);
          dropInterval = Math.max(120, 1000 * Math.pow(0.9, player.level));
          flashAlpha = Math.min(0.65, flashAlpha + 0.45);
        }
      }

      function rotate(dir) {
        const m = player.matrix;
        for (let y = 0; y < m.length; y++) {
          for (let x = 0; x < y; x++) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
        if (dir > 0) m.forEach(row => row.reverse());
        else m.reverse();

        // Wall kick
        const pos = player.pos.x;
        let offset = 1;
        while (collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > m[0].length) {
            // Revert
            rotate(-dir);
            player.pos.x = pos;
            break;
          }
        }
      }

      function move(offset) {
        player.pos.x += offset;
        if (collide(arena, player)) {
          player.pos.x -= offset;
        }
      }

      function softDrop() {
        player.pos.y++;
        if (collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          playerReset();
          arenaSweep();
          updateScore();
          saveBest();
        }
        dropCounter = 0;
      }

      function hardDrop() {
        let dropDist = 0;
        while (!collide(arena, player)) {
          player.pos.y++;
          dropDist++;
        }
        player.pos.y--;
        dropDist--;
        if (dropDist > 0) {
          player.score += dropDist * 2;
        }
        merge(arena, player);
        playerReset();
        arenaSweep();
        updateScore();
        saveBest();
        dropCounter = 0;
      }

      function playerReset() {
        player.matrix = nextPiece;
        nextPiece = createPiece(randomType());
        drawNext();
        player.pos.y = 0;
        player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);

        if (collide(arena, player)) {
          arena.forEach(row => row.fill(0));
          player.score = 0;
          player.lines = 0;
          player.level = 0;
          dropInterval = 1000;
          flashAlpha = 0.75;
          updateScore();
        }
      }

      function getGhostPos() {
        const ghost = { pos: { x: player.pos.x, y: player.pos.y }, matrix: player.matrix };
        while (!collide(arena, ghost)) {
          ghost.pos.y++;
        }
        ghost.pos.y--;
        return ghost.pos.y;
      }

      function draw() {
        clearCanvas();

        // Draw grid
        drawGrid();

        // Draw arena
        drawMatrix(arena, { x: 0, y: 0 }, 1, false);

        // Ghost piece
        const gy = getGhostPos();
        drawMatrix(player.matrix, { x: player.pos.x, y: gy }, 0.18, true);

        // Active piece with glow
        ctx.save();
        ctx.shadowColor = hexWithAlpha(getColor(player.matrix), 0.6);
        ctx.shadowBlur = Math.max(6, cellSize * 0.7);
        drawMatrix(player.matrix, player.pos, 1, false, true);
        ctx.restore();

        // Line clear flash overlay
        if (flashAlpha > 0.02) {
          ctx.save();
          ctx.globalAlpha = flashAlpha;
          const grd = ctx.createLinearGradient(0, 0, COLS, ROWS);
          grd.addColorStop(0, '#ffffff');
          grd.addColorStop(1, '#b9e6ff');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, COLS, ROWS);
          ctx.restore();
          flashAlpha *= 0.88;
        }
      }

      function clearCanvas() {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = cellSize * dpr;
        ctx.setTransform(scale,0,0,scale,0,0);
      }

      function drawGrid() {
        ctx.save();
        ctx.lineWidth = 1 / (cellSize);
        ctx.strokeStyle = '#1b2240';
        ctx.globalAlpha = 0.5;
        for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, ROWS);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(COLS, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawMatrix(matrix, offset, alpha = 1, ghost = false, active = false) {
        ctx.save();
        ctx.globalAlpha = alpha;
        for (let y = 0; y < matrix.length; y++) {
          for (let x = 0; x < matrix[y].length; x++) {
            const v = matrix[y][x];
            if (v !== 0) {
              const px = x + offset.x;
              const py = y + offset.y;
              drawCell(px, py, colors[v], { ghost, active });
            }
          }
        }
        ctx.restore();
      }

      function drawCell(x, y, color, { ghost = false, active = false } = {}) {
        const r = Math.max(0.15, Math.min(0.3, 6 / cellSize));
        const base = ghost ? hexWithAlpha(color, 0.28) : color;

        const grad = ctx.createLinearGradient(x, y, x, y + 1);
        grad.addColorStop(0, lighten(base, 0.2));
        grad.addColorStop(1, darken(base, 0.2));

        roundRect(x + 0.06, y + 0.06, 0.88, 0.88, r, () => {
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.strokeStyle = hexWithAlpha('#ffffff', ghost ? 0.12 : 0.3);
          ctx.lineWidth = 0.04;
          ctx.stroke();
        });

        ctx.save();
        ctx.globalAlpha = ghost ? 0.1 : 0.22;
        roundRect(x + 0.1, y + 0.1, 0.86, 0.38, r, () => {
          const g2 = ctx.createLinearGradient(x, y, x, y + 0.5);
          g2.addColorStop(0, hexWithAlpha('#ffffff', ghost ? 0.08 : 0.25));
          g2.addColorStop(1, hexWithAlpha('#ffffff', 0));
          ctx.fillStyle = g2;
          ctx.fill();
        });
        ctx.restore();

        if (active && !ghost) {
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.strokeStyle = hexWithAlpha(color, 0.9);
          ctx.lineWidth = 0.06;
          roundRect(x + 0.03, y + 0.03, 0.94, 0.94, r, () => ctx.stroke());
          ctx.restore();
        }
      }

      function roundRect(x, y, w, h, r, drawCb) {
        const rr = Math.min(r, w * 0.5, h * 0.5);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
        drawCb();
      }

      function getColor(matrix){
        for(let y=0;y<matrix.length;y++){
          for(let x=0;x<matrix[y].length;x++){
            const v = matrix[y][x];
            if(v){ return colors[v]; }
          }
        }
        return '#6cf';
      }

      function updateScore() {
        scoreEl.textContent = player.score;
        linesEl.textContent = player.lines;
        levelEl.textContent = player.level;
        scoreBadge.textContent = player.score;
      }

      function saveBest() {
        if (player.score > best) {
          best = player.score;
          localStorage.setItem(BEST_KEY, best);
          bestEl.textContent = best;
        }
      }

      function update(time = 0) {
        const delta = time - lastTime;
        dropCounter += delta;
        if (dropCounter > dropInterval) {
          softDrop();
        }
        lastTime = time;

        draw();
        requestAnimationFrame(update);
      }

      function drawNext() {
        const rect = nextCanvas.getBoundingClientRect();
        const cssSize = Math.min(rect.width, rect.height);
        dpr = window.devicePixelRatio || 1;
        nextCanvas.width = Math.max(48, Math.floor(cssSize * dpr));
        nextCanvas.height = Math.max(48, Math.floor(cssSize * dpr));

        const size = Math.min(nextCanvas.width, nextCanvas.height);
        nctx.setTransform(1,0,0,1,0,0);
        nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);

        const m = nextPiece;
        const cols = m[0].length;
        const rows = m.length;
        const padding = 8 * dpr;
        const scale = Math.floor((size - padding * 2) / Math.max(cols, rows));
        if (scale <= 0) return;

        // Background rounded rect
        nctx.save();
        nctx.fillStyle = '#0b1130';
        nctx.strokeStyle = '#212a55';
        nctx.lineWidth = 2;
        roundRect2(1,1,nextCanvas.width-2,nextCanvas.height-2,12*dpr, nctx, () => {
          nctx.fill();
          nctx.stroke();
        });
        nctx.restore();

        nctx.setTransform(scale,0,0,scale, 0, 0);
        const offX = (((size/scale) - cols) / 2);
        const offY = (((size/scale) - rows) / 2);

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const v = m[y][x];
            if (v) drawMiniCell(nctx, x + offX, y + offY, colors[v]);
          }
        }
      }

      function drawMiniCell(c, x, y, color) {
        const r = 0.25;
        c.beginPath();
        c.moveTo(x + r, y);
        c.arcTo(x + 1, y, x + 1, y + 1, r);
        c.arcTo(x + 1, y + 1, x, y + 1, r);
        c.arcTo(x, y + 1, x, y, r);
        c.arcTo(x, y, x + 1, y, r);
        c.closePath();

        const grad = c.createLinearGradient(x, y, x, y + 1);
        grad.addColorStop(0, lighten(color, 0.18));
        grad.addColorStop(1, darken(color, 0.18));
        c.fillStyle = grad;
        c.fill();

        c.lineWidth = 0.06;
        c.strokeStyle = hexWithAlpha('#ffffff', 0.25);
        c.stroke();
      }

      function roundRect2(x,y,w,h,r, c, cb){
        const rr = Math.min(r, w*0.5, h*0.5);
        c.beginPath();
        c.moveTo(x + rr, y);
        c.arcTo(x + w, y, x + w, y + h, rr);
        c.arcTo(x + w, y + h, x, y + h, rr);
        c.arcTo(x, y + h, x, y, rr);
        c.arcTo(x, y, x + w, y, rr);
        c.closePath(); cb();
      }

      // Utilities: colors
      function lighten(hex, amt) {
        const {r,g,b,a} = parseHex(hex);
        return rgbaToHex(
          Math.min(255, Math.round(r + (255 - r) * amt)),
          Math.min(255, Math.round(g + (255 - g) * amt)),
          Math.min(255, Math.round(b + (255 - b) * amt)),
          a
        );
      }
      function darken(hex, amt) {
        const {r,g,b,a} = parseHex(hex);
        return rgbaToHex(
          Math.max(0, Math.round(r * (1 - amt))),
          Math.max(0, Math.round(g * (1 - amt))),
          Math.max(0, Math.round(b * (1 - amt))),
          a
        );
      }
      function hexWithAlpha(hex, alpha) {
        const {r,g,b} = parseHex(hex);
        return `rgba(${r},${g},${b},${alpha})`;
      }
      function parseHex(hex){
        const h = hex.replace('#','').trim();
        let r=0,g=0,b=0,a=1;
        if (h.length===3){
          r=parseInt(h[0]+h[0],16);
          g=parseInt(h[1]+h[1],16);
          b=parseInt(h[2]+h[2],16);
        } else if (h.length===6 || h.length===8){
          r=parseInt(h.slice(0,2),16);
          g=parseInt(h.slice(2,4),16);
          b=parseInt(h.slice(4,6),16);
          if (h.length===8) a = Math.round((parseInt(h.slice(6,8),16)/255)*100)/100;
        }
        return {r,g,b,a};
      }
      function rgbaToHex(r,g,b,a=1){
        if (a>=1) return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
        const ai = Math.round(a*255);
        return '#' + [r,g,b,ai].map(v => v.toString(16).padStart(2,'0')).join('');
      }

      // Layout and resize handling
      function resizeAll() {
        layoutWrap();
        resizeCanvas();
        drawNext();
      }

      function layoutWrap() {
        const gap = getBodyRowGap() * 2; // two gaps between header/main and main/controls
        const vpH = window.innerHeight;
        const headerH = Math.ceil(headerEl.getBoundingClientRect().height);
        const controlsH = Math.ceil(controlsEl.getBoundingClientRect().height);
        const availableH = Math.max(140, Math.floor(vpH - headerH - controlsH - gap));
        const areaRect = gameAreaEl.getBoundingClientRect();
        const availableW = Math.max(120, Math.floor(areaRect.width));

        // Fit 12:20 inside available box
        let widthByHeight = Math.floor(availableH * RATIO);
        let targetW, targetH;
        if (widthByHeight <= availableW) {
          targetW = widthByHeight;
          targetH = availableH;
        } else {
          targetW = availableW;
          targetH = Math.floor(availableW / RATIO);
        }

        wrap.style.width = targetW + 'px';
        wrap.style.height = targetH + 'px';
      }

      function resizeCanvas() {
        dpr = window.devicePixelRatio || 1;
        const rect = wrap.getBoundingClientRect();
        const w = Math.max(120, Math.floor(rect.width));
        const h = Math.max(200, Math.floor(rect.height));

        const scaleX = w / COLS;
        const scaleY = h / ROWS;
        cellSize = Math.max(1, Math.floor(Math.min(scaleX, scaleY)));

        canvas.width = Math.floor(COLS * cellSize * dpr);
        canvas.height = Math.floor(ROWS * cellSize * dpr);

        const scale = cellSize * dpr;
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
      }

      function getBodyRowGap() {
        const cs = getComputedStyle(document.body);
        const rg = parseFloat(cs.rowGap || cs.gap || '0');
        return isNaN(rg) ? 0 : rg;
      }

      // Button press handler with repeat
      function pressRepeat(el, action, initialDelay = 160, repeatEvery = 120) {
        let t1 = null, t2 = null;
        const clearTimers = () => { if (t1) { clearTimeout(t1); t1 = null; } if (t2) { clearInterval(t2); t2 = null; } };
        const start = (e) => {
          e.preventDefault();
          action();
          clearTimers();
          t1 = setTimeout(() => {
            action();
            t2 = setInterval(action, repeatEvery);
          }, initialDelay);
        };
        const stop = () => clearTimers();
        el.addEventListener('pointerdown', start);
        el.addEventListener('pointerup', stop);
        el.addEventListener('pointercancel', stop);
        el.addEventListener('pointerleave', stop);
      }

      // Simple gesture support on canvas
      function setupGestures(target) {
        let startX = 0, startY = 0, moved = false, t0 = 0;

        const onDown = (e) => {
          e.preventDefault();
          const t = getPoint(e);
          startX = t.x; startY = t.y; moved = false; t0 = performance.now();
          target.setPointerCapture?.(e.pointerId || 0);
        };
        const onMove = (e) => {
          const t = getPoint(e);
          const dx = t.x - startX;
          const dy = t.y - startY;
          const ax = Math.abs(dx), ay = Math.abs(dy);
          if (!moved && (ax > 22 || ay > 22)) moved = true;

          const step = 20;
          const count = (ax / step) | 0;
          if (count > 0 && ax > ay) {
            const dir = dx > 0 ? 1 : -1;
            for (let i = 0; i < count; i++) move(dir);
            startX = t.x;
          }
          if (ay > ax && dy > step) {
            softDrop();
            startY = t.y;
          }
        };
        const onUp = (e) => {
          const t1 = performance.now();
          const dt = t1 - t0;
          const t = getPoint(e);
          const dx = t.x - startX;
          const dy = t.y - startY;

          if (!moved && dt < 250) {
            rotate(1);
          } else {
            if (dy < -40 && Math.abs(dy) > Math.abs(dx)) {
              hardDrop();
            }
          }
        };

        target.addEventListener('pointerdown', onDown, { passive:false });
        target.addEventListener('pointermove', onMove, { passive:true });
        target.addEventListener('pointerup', onUp, { passive:true });
        target.addEventListener('pointercancel', onUp, { passive:true });

        function getPoint(e){
          const rect = target.getBoundingClientRect();
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
      }

      // Debounce utility
      function debounce(fn, ms){
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(null,args), ms);
        };
      }
    })();
  </script>
</body>
</html>