<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Breakout Game</title>
  <style>
    :root{
      --bg1:#0b0f17;
      --bg2:#0c1326;
      --bg3:#0a0f1f;
      --panel:#0f172a;
      --accent:#60a5fa;
      --accent2:#10b981;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --shadow: 0 10px 30px rgba(0,0,0,.4);
      --radius: 16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%;margin:0;background: radial-gradient(1200px 800px at 20% 20%, var(--bg2), transparent) no-repeat, radial-gradient(1000px 700px at 80% 0%, var(--bg3), transparent) no-repeat, linear-gradient(180deg, var(--bg1), #070a12); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    body::before{
      content:"";
      position:fixed;inset:0;pointer-events:none;
      background: radial-gradient(800px 500px at var(--x,60%) var(--y,40%), rgba(96,165,250,.08), transparent 60%);
      transition: background-position .2s ease;
      z-index:0;
    }
    .wrap{min-height:100%; display:flex; align-items:center; justify-content:center; padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left));}
    .panel{
      width: min(92vw, 980px);
      background: linear-gradient(180deg, rgba(15,23,42,.75), rgba(2,6,23,.75));
      border:1px solid rgba(148,163,184,.2);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      padding: 18px;
      position:relative;
      z-index:1;
    }
    .header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-bottom:12px;
    }
    .brand{
      display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.3px;
    }
    .brand .dot{
      width:12px; height:12px; border-radius:50%; background: radial-gradient(circle at 30% 30%, #fff, var(--accent) 30%, #1e40af 60%); box-shadow:0 0 14px var(--accent);
      animation: pulse 2.2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%,100%{ transform: scale(1); box-shadow:0 0 10px rgba(96,165,250,.8);}
      50%{ transform: scale(1.18); box-shadow:0 0 26px rgba(96,165,250,1);}
    }
    .stats{
      display:flex; gap:14px; align-items:center; flex-wrap:wrap;
      font-weight:700;
    }
    .stat{
      padding:8px 12px; border-radius:12px; background: rgba(30,41,59,.6); border:1px solid rgba(148,163,184,.2);
      display:flex; gap:8px; align-items:center;
    }
    .stat .val{ color: var(--accent); min-width:2ch; text-align:right;}
    .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .btn{
      appearance:none; border:none; outline:none; cursor:pointer;
      padding:10px 14px; border-radius:10px; font-weight:800; letter-spacing:.3px;
      background: linear-gradient(180deg, #2563eb, #1d4ed8);
      color:#fff;
      box-shadow: 0 10px 20px rgba(29,78,216,.35), inset 0 1px 0 rgba(255,255,255,.15);
      transition: transform .08s ease, filter .2s ease, background .2s ease;
    }
    .btn.secondary{ background: linear-gradient(180deg, #059669, #047857); box-shadow: 0 10px 20px rgba(4,120,87,.35), inset 0 1px 0 rgba(255,255,255,.12);}
    .btn.ghost{ background: rgba(30,41,59,.65); color:#cbd5e1; border:1px solid rgba(148,163,184,.25); box-shadow:none; }
    .btn:hover{ filter:brightness(1.05); }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .canvas-wrap{
      position:relative;
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(148,163,184,.2);
      background:
        radial-gradient(600px 300px at 20% 0%, rgba(96,165,250,.06), transparent 60%),
        radial-gradient(800px 400px at 80% 100%, rgba(16,185,129,.06), transparent 60%),
        #0b1220;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), 0 20px 40px rgba(0,0,0,.35);
    }
    canvas{
      display:block; width:100%; height:auto; background: transparent; touch-action:none;
    }
    .sub{
      margin-top:10px; color:var(--muted); font-size:14px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .game-over{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(2,6,23,.6); backdrop-filter: blur(3px);
    }
    .game-over .card{
      padding:18px 20px; border-radius:14px; background: rgba(15,23,42,.9); border:1px solid rgba(148,163,184,.25); text-align:center; box-shadow: var(--shadow);
    }
    .game-over .title{ font-size:22px; font-weight:900; margin-bottom:6px; }
    .game-over .desc{ font-size:14px; color:var(--muted); margin-bottom:12px; }
    .mobile-controls{
      margin-top:12px; display:none; gap:12px; width:100%;
    }
    .touch-row{
      display:flex; gap:12px; width:100%;
    }
    .touch-btn{
      flex:1; padding:16px; font-size:18px; font-weight:900; border:none; border-radius:12px; color:#fff; background: rgba(30,41,59,.8);
      border:1px solid rgba(148,163,184,.25);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      min-height:54px;
      touch-action:none;
    }
    .touch-btn:active{ filter: brightness(1.1); }
    .legend{ margin-left:auto; font-size:12px; color:#94a3b8; }
    @media (max-width: 860px){
      .mobile-controls{ display:flex; }
    }
    @media (max-width: 520px){
      .btn.ghost{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="header">
        <div class="brand"><span class="dot"></span> Breakout Neo</div>
        <div class="stats">
          <div class="stat">Score:<span id="score" class="val">0</span></div>
          <div class="stat">Lives:<span id="lives" class="val">3</span></div>
          <div class="stat">Level:<span id="level" class="val">1</span></div>
        </div>
        <div class="controls">
          <button class="btn" id="newGameBtn">New Game</button>
          <button class="btn secondary" id="pauseBtn">Pause</button>
          <button class="btn ghost" id="muteBtn">Mute</button>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap" aria-label="Breakout game area">
        <canvas id="game" width="480" height="320"></canvas>
        <div id="overlay" class="game-over">
          <div class="card">
            <div id="overlayTitle" class="title">Tap to Start</div>
            <div id="overlayDesc" class="desc">Move your finger or mouse to control the paddle</div>
            <button class="btn" id="overlayBtn">Start</button>
          </div>
        </div>
      </div>

      <div class="sub">
        • Drag your finger on the canvas or use buttons below on mobile
        <span class="legend">←/→ or A/D on keyboard</span>
      </div>

      <div class="mobile-controls" id="mobileControls">
        <div class="touch-row">
          <button class="touch-btn" id="leftBtn">◀ Hold</button>
          <button class="touch-btn" id="rightBtn">Hold ▶</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // DOM refs
      const canvas = document.getElementById('game');
      const wrap = document.getElementById('canvasWrap');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const livesEl = document.getElementById('lives');
      const levelEl = document.getElementById('level');
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayDesc = document.getElementById('overlayDesc');
      const overlayBtn = document.getElementById('overlayBtn');
      const newGameBtn = document.getElementById('newGameBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const muteBtn = document.getElementById('muteBtn');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');

      // Game state
      let gameRunning = false;
      let paused = false;
      let animationId = null;
      let score = 0;
      let lives = 3;
      let level = 1;
      let maxScoreThisLevel = 0;

      // Dimensions & scaling
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let W = 480, H = 320;
      const baseAspect = 3 / 2; // width/height

      // Paddle
      let paddleWidth, paddleHeight, paddleX, paddleY, paddleSpeed;

      // Ball
      const ballRadiusBase = 8;
      let ballRadius, ballX, ballY, ballDX, ballDY, ballSpeed;
      const trail = [];
      const trailMax = 10;

      // Bricks
      let bricks = [];
      let brickRows = 5;
      let brickCols = 8;
      let brickW, brickH, brickPad, brickOffsetTop, brickOffsetSide;
      const brickColors = ['#ef4444', '#f97316', '#eab308', '#10b981', '#3b82f6', '#a855f7', '#22d3ee'];

      // Particles
      const particles = [];

      // Controls
      let leftPressed = false;
      let rightPressed = false;
      let pointerActive = false;

      // Audio (lightweight, optional)
      let muted = true;
      const buzz = (freq=220, dur=60, vol=0.03) => {
        if (muted) return;
        try {
          const actx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = actx.createOscillator();
          const gain = actx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.value = vol;
          osc.connect(gain).connect(actx.destination);
          osc.start();
          setTimeout(()=>{ osc.stop(); actx.close(); }, dur);
        } catch {}
      };

      // Helpers
      const clamp = (n, min, max) => Math.max(min, Math.min(n, max));
      const rand = (min, max) => Math.random() * (max - min) + min;

      function resizeCanvas() {
        // Determine size based on container width with target aspect ratio
        const wrapWidth = wrap.clientWidth;
        let width = wrapWidth;
        let height = Math.round(width / baseAspect);
        // Keep some max height on very tall screens
        const maxH = Math.min(window.innerHeight - 200, 640);
        if (height > maxH) {
          height = maxH;
          width = Math.round(height * baseAspect);
        }
        // Set CSS size
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        // Set internal resolution for crisp rendering
        DPR = Math.max(1, window.devicePixelRatio || 1);
        W = Math.floor(width * DPR);
        H = Math.floor(height * DPR);
        canvas.width = W;
        canvas.height = H;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(DPR, DPR);

        // Recalculate sizes
        computeLayout(width, height);

        // Adjust positions proportionally if already placed
        if (typeof paddleX === 'number') {
          paddleX = clamp(paddleX, 0, width - paddleWidth);
          paddleY = height - paddleHeight - 10;
          ballRadius = Math.max(6, Math.round(ballRadiusBase * (width / 480)));
        }
      }

      function computeLayout(viewW, viewH) {
        // Bricks responsive setup
        brickCols = viewW < 520 ? 8 : viewW < 720 ? 9 : 10;
        brickRows = 5 + Math.floor((level - 1) % 3); // slight increase per level cycle
        brickPad = Math.max(3, Math.round(viewW * 0.008));
        brickOffsetSide = Math.round(viewW * 0.04);
        brickOffsetTop = Math.round(viewH * 0.06);
        brickW = Math.floor((viewW - brickOffsetSide * 2 - (brickCols - 1) * brickPad) / brickCols);
        brickH = Math.max(14, Math.round(viewH * 0.055));

        // Paddle
        paddleWidth = Math.max(60, Math.round(viewW * 0.18));
        paddleHeight = Math.max(10, Math.round(viewH * 0.028));
        paddleY = viewH - paddleHeight - 10;
        paddleSpeed = Math.max(6, Math.round(viewW * 0.012));

        // Ball
        ballRadius = Math.max(6, Math.round(ballRadiusBase * (viewW / 480)));
        ballSpeed = Math.max(4, Math.round(viewW * 0.008));
      }

      function initBricks() {
        bricks = [];
        maxScoreThisLevel = 0;
        for (let c = 0; c < brickCols; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickRows; r++) {
            const x = c * (brickW + brickPad) + brickOffsetSide;
            const y = r * (brickH + brickPad) + brickOffsetTop;
            const color = brickColors[r % brickColors.length];
            const value = (brickRows - r) * 10;
            bricks[c][r] = { x, y, status: 1, color, alpha: 1, value, hit:false };
            maxScoreThisLevel += value;
          }
        }
      }

      function resetBallAndPaddle(center = true) {
        const viewW = canvas.clientWidth;
        const viewH = canvas.clientHeight;
        paddleX = (viewW - paddleWidth) / 2;
        if (!center && typeof ballX === 'number') {
          // Keep ball above paddle
          ballX = clamp(ballX, ballRadius, viewW - ballRadius);
          ballY = paddleY - ballRadius - 2;
        } else {
          ballX = viewW / 2;
          ballY = viewH - 30;
        }
        const angle = rand(-0.35, 0.35);
        const speed = ballSpeed;
        ballDX = Math.cos(Math.PI/2 + angle) * speed;
        ballDY = Math.sin(Math.PI/2 + angle) * speed;
        if (ballDY > 0) ballDY = -ballDY;
        trail.length = 0;
      }

      function startGame() {
        score = 0;
        lives = 3;
        level = 1;
        levelEl.textContent = level;
        scoreEl.textContent = score;
        livesEl.textContent = lives;
        overlay.style.display = 'none';
        gameRunning = true;
        paused = false;
        pauseBtn.textContent = 'Pause';
        initBricks();
        resetBallAndPaddle(true);
        cancelAnimationFrame(animationId);
        lastTs = 0;
        loop(0);
      }

      function nextLevel() {
        level++;
        levelEl.textContent = level;
        initBricks();
        resetBallAndPaddle(true);
      }

      function gameOver(won = false) {
        gameRunning = false;
        paused = false;
        overlayTitle.textContent = won ? 'You Win!' : 'Game Over';
        overlayDesc.textContent = `Score: ${score}`;
        overlayBtn.textContent = 'Play Again';
        overlay.style.display = 'flex';
      }

      function togglePause() {
        if (!gameRunning) return;
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
        if (!paused) {
          lastTs = 0;
          loop(0);
        }
      }

      // Drawing helpers
      function drawRoundedRect(x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }

      function drawPaddle() {
        const viewY = paddleY;
        ctx.save();
        ctx.shadowColor = 'rgba(16,185,129,.35)';
        ctx.shadowBlur = 14;
        const grad = ctx.createLinearGradient(paddleX, viewY, paddleX, viewY + paddleHeight);
        grad.addColorStop(0, '#34d399');
        grad.addColorStop(1, '#059669');
        drawRoundedRect(paddleX, viewY, paddleWidth, paddleHeight, 8);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();
      }

      function drawBall() {
        // Trail
        for (let i = 0; i < trail.length; i++) {
          const t = trail[i];
          const alpha = (i + 1) / (trail.length + 2);
          ctx.beginPath();
          ctx.arc(t.x, t.y, ballRadius * (0.8 + i/trail.length * 0.3), 0, Math.PI*2);
          ctx.fillStyle = `rgba(96,165,250,${alpha * 0.35})`;
          ctx.fill();
        }
        // Ball
        ctx.save();
        ctx.shadowColor = 'rgba(96,165,250,.6)';
        ctx.shadowBlur = 18;
        const grad = ctx.createRadialGradient(ballX - 2, ballY - 2, ballRadius*0.2, ballX, ballY, ballRadius);
        grad.addColorStop(0, '#bfdbfe');
        grad.addColorStop(1, '#3b82f6');
        ctx.beginPath();
        ctx.arc(ballX, ballY, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();
      }

      function drawBricks() {
        for (let c = 0; c < brickCols; c++) {
          for (let r = 0; r < brickRows; r++) {
            const b = bricks[c][r];
            if (b.status === 0) continue;
            const alpha = b.alpha;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.shadowColor = b.color + '55';
            ctx.shadowBlur = 10;
            drawRoundedRect(b.x, b.y, brickW, brickH, 6);
            const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + brickH);
            grad.addColorStop(0, lighten(b.color, 0.25));
            grad.addColorStop(1, b.color);
            ctx.fillStyle = grad;
            ctx.fill();
            // top shine
            ctx.globalAlpha = alpha * 0.35;
            ctx.fillStyle = '#ffffff';
            drawRoundedRect(b.x + 4, b.y + 3, brickW - 8, 6, 3);
            ctx.fill();
            ctx.restore();
          }
        }
      }

      function lighten(hex, amt=0.2){
        const c = hex.replace('#','');
        const num = parseInt(c,16);
        let r=(num>>16)&255, g=(num>>8)&255, b=(num)&255;
        r = Math.min(255, Math.round(r + (255 - r)*amt));
        g = Math.min(255, Math.round(g + (255 - g)*amt));
        b = Math.min(255, Math.round(b + (255 - b)*amt));
        return `rgb(${r},${g},${b})`;
      }

      function spawnParticles(x, y, color, count=10){
        for (let i=0;i<count;i++){
          particles.push({
            x, y,
            vx: rand(-2.8, 2.8),
            vy: rand(-3, -0.5),
            life: rand(18, 30),
            color,
            size: rand(1.5, 3.2),
            alpha: 1
          });
        }
        if (navigator.vibrate) navigator.vibrate(10);
      }

      function updateParticles(dt){
        for (let i=particles.length-1;i>=0;i--){
          const p = particles[i];
          p.life -= dt*60;
          if (p.life <= 0){ particles.splice(i,1); continue; }
          p.x += p.vx * dt * 60 * 0.5;
          p.y += p.vy * dt * 60 * 0.5;
          p.vy += 0.08 * dt * 60;
          p.vx *= (1 - 0.02 * dt * 60);
          p.alpha = p.life / 30;
        }
      }

      function drawParticles(){
        for (const p of particles){
          ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function collisionDetection() {
        // Only check bricks in vicinity by computing column/row indexes
        const bx = ballX, by = ballY;
        const col = Math.floor((bx - brickOffsetSide) / (brickW + brickPad));
        const row = Math.floor((by - brickOffsetTop) / (brickH + brickPad));
        const candidates = [];
        for (let dc = -1; dc <= 1; dc++) {
          for (let dr = -1; dr <= 1; dr++) {
            const cc = col + dc;
            const rr = row + dr;
            if (cc >= 0 && cc < brickCols && rr >= 0 && rr < brickRows) {
              candidates.push(bricks[cc][rr]);
            }
          }
        }
        for (const b of candidates) {
          if (!b || b.status !== 1) continue;
          if (bx + ballRadius > b.x && bx - ballRadius < b.x + brickW &&
              by + ballRadius > b.y && by - ballRadius < b.y + brickH) {
            // Determine bounce axis by penetration
            const overlapX = Math.min(b.x + brickW - (bx - ballRadius), (bx + ballRadius) - b.x);
            const overlapY = Math.min(b.y + brickH - (by - ballRadius), (by + ballRadius) - b.y);
            if (overlapX < overlapY) ballDX = -ballDX; else ballDY = -ballDY;
            // Mark hit and fade out
            b.status = 2; // fading
            b.hit = true;
            spawnParticles(bx, by, b.color, 14);
            buzz(480, 50, 0.02);
            score += b.value;
            scoreEl.textContent = score;
          }
        }
      }

      function updateBricks(dt){
        let activeCount = 0;
        for (let c=0; c<brickCols; c++){
          for (let r=0; r<brickRows; r++){
            const b = bricks[c][r];
            if (b.status === 1) activeCount++;
            if (b.status === 2){
              b.alpha -= dt * 2; // fade quickly
              if (b.alpha <= 0){ b.status = 0; }
            }
          }
        }
        if (activeCount === 0){
          buzz(200, 120, 0.03);
          nextLevel();
        }
      }

      function updatePaddle(dt){
        const viewW = canvas.clientWidth;
        if (leftPressed) paddleX -= paddleSpeed * dt * 60;
        if (rightPressed) paddleX += paddleSpeed * dt * 60;
        paddleX = clamp(paddleX, 0, viewW - paddleWidth);
      }

      function updateBall(dt){
        const viewW = canvas.clientWidth;
        const viewH = canvas.clientHeight;
        const speedScale = dt * 60;

        // trail
        trail.unshift({ x: ballX, y: ballY });
        if (trail.length > trailMax) trail.pop();

        ballX += ballDX * dt;
        ballY += ballDY * dt;

        // walls
        if (ballX + ballRadius >= viewW) { ballX = viewW - ballRadius; ballDX = -Math.abs(ballDX); buzz(220, 40, 0.01); }
        if (ballX - ballRadius <= 0)     { ballX = ballRadius;       ballDX =  Math.abs(ballDX); buzz(220, 40, 0.01); }
        if (ballY - ballRadius <= 0)     { ballY = ballRadius;       ballDY =  Math.abs(ballDY); buzz(220, 40, 0.01); }

        // paddle collision
        if (ballY + ballRadius >= paddleY && ballY + ballRadius <= paddleY + paddleHeight + Math.abs(ballDY)*speedScale) {
          if (ballX >= paddleX && ballX <= paddleX + paddleWidth) {
            const hit = (ballX - paddleX) / paddleWidth; // 0..1
            const angle = (hit - 0.5) * Math.PI * 0.75; // -67.5..+67.5 deg
            const speed = Math.hypot(ballDX, ballDY) * 1.02; // slight speed up
            ballDX = Math.sin(angle) * speed;
            ballDY = -Math.abs(Math.cos(angle) * speed);
            ballY = paddleY - ballRadius - 0.1;
            buzz(300, 40, 0.02);
          }
        }

        // missed
        if (ballY - ballRadius > viewH) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver(false);
            cancelAnimationFrame(animationId);
            return;
          } else {
            resetBallAndPaddle(false);
          }
        }
      }

      function drawBackground() {
        // subtle grid
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const step = Math.max(24, Math.round(w * 0.03));
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#93c5fd';
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
        }
        for (let y = 0; y < h; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
        }
        ctx.restore();
      }

      let lastTs = 0;
      function loop(ts){
        if (!gameRunning || paused) return;
        const viewW = canvas.clientWidth;
        const viewH = canvas.clientHeight;
        if (!lastTs) lastTs = ts;
        let dt = (ts - lastTs) / 1000;
        dt = Math.min(dt, 1/30); // clamp to avoid huge jumps
        lastTs = ts;

        ctx.clearRect(0, 0, viewW, viewH);
        drawBackground();
        drawBricks();
        drawParticles();
        drawPaddle();
        drawBall();

        updatePaddle(dt);
        updateBall(dt);
        collisionDetection();
        updateBricks(dt);
        updateParticles(dt);

        animationId = requestAnimationFrame(loop);
      }

      // Input
      // Mouse move
      canvas.addEventListener('mousemove', (e) => {
        if (!gameRunning || paused) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        paddleX = clamp(x - paddleWidth / 2, 0, rect.width - paddleWidth);
      });

      // Pointer/touch drag
      canvas.addEventListener('pointerdown', (e) => {
        pointerActive = true;
      });
      window.addEventListener('pointerup', () => { pointerActive = false; });
      canvas.addEventListener('pointermove', (e) => {
        if (!gameRunning || paused) return;
        if (!pointerActive && e.pointerType === 'touch') return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        paddleX = clamp(x - paddleWidth / 2, 0, rect.width - paddleWidth);
      }, { passive: true });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'arrowleft' || k === 'a') leftPressed = true;
        if (k === 'arrowright' || k === 'd') rightPressed = true;
        if (k === 'p') togglePause();
        if (k === 'm') toggleMute();
      });
      window.addEventListener('keyup', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'arrowleft' || k === 'a') leftPressed = false;
        if (k === 'arrowright' || k === 'd') rightPressed = false;
      });

      // Mobile buttons
      function bindHold(btn, on) {
        let active = false;
        const start = (e) => { e.preventDefault(); active = true; on(true); };
        const end = () => { active = false; on(false); };
        btn.addEventListener('touchstart', start, {passive:false});
        btn.addEventListener('touchend', end);
        btn.addEventListener('touchcancel', end);
        btn.addEventListener('mousedown', start);
        window.addEventListener('mouseup', end);
        // Prevent double tap zoom
        btn.addEventListener('dblclick', e => e.preventDefault());
      }
      bindHold(leftBtn, v => leftPressed = v);
      bindHold(rightBtn, v => rightPressed = v);

      // Buttons
      newGameBtn.addEventListener('click', startGame);
      overlayBtn.addEventListener('click', startGame);
      pauseBtn.addEventListener('click', togglePause);
      function toggleMute(){
        muted = !muted;
        muteBtn.textContent = muted ? 'Unmute' : 'Mute';
        if (!muted) buzz(300, 60, 0.02);
      }
      muteBtn.addEventListener('click', toggleMute);

      // Resize handling
      const handleResize = () => {
        const prevW = canvas.clientWidth || 1;
        const prevH = canvas.clientHeight || 1;
        const prevBallRatioX = typeof ballX === 'number' ? ballX / prevW : 0.5;
        const prevPaddleRatio = typeof paddleX === 'number' ? paddleX / prevW : 0.5;
        resizeCanvas();
        const viewW = canvas.clientWidth;
        ballX = clamp(prevBallRatioX * viewW, ballRadius, viewW - ballRadius);
        paddleX = clamp(prevPaddleRatio * viewW, 0, viewW - paddleWidth);
      };
      window.addEventListener('resize', handleResize, { passive:true });

      // Subtle background reactive glow
      window.addEventListener('pointermove', (e) => {
        document.body.style.setProperty('--x', (e.clientX / window.innerWidth * 100) + '%');
        document.body.style.setProperty('--y', (e.clientY / window.innerHeight * 100) + '%');
      });

      // Initialize
      resizeCanvas();
      initBricks();
      resetBallAndPaddle(true);
      overlay.style.display = 'flex';
    })();
  </script>
</body>
</html>