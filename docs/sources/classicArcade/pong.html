<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f17" />
  <title>Pong Neo</title>
  <style>
    :root{
      --bg1:#0b0f17;
      --bg2:#0a1328;
      --bg3:#071322;
      --panel:#0e1628;
      --glass:rgba(255,255,255,0.06);
      --stroke:rgba(255,255,255,0.08);
      --text:#e5e7eb;
      --muted:#9ca3af;
      --brand:#60a5fa;
      --paddle1:#22d3ee;
      --paddle2:#f472b6;
      --ball:#a78bfa;
      --accent:#10b981;
      --warning:#ef4444;
      --shadow:rgba(0,0,0,0.5);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%; margin:0; background:radial-gradient(1200px 600px at 20% -10%, #12233f 0%, transparent 60%), radial-gradient(900px 600px at 100% 0%, #1d0f3b33 0%, transparent 50%), linear-gradient(180deg, var(--bg1), var(--bg3)); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif; overflow:hidden;}
    .wrap{height:100%; display:flex; align-items:center; justify-content:center; padding:clamp(8px, 2.5vw, 24px);}
    .panel{
      width:100%;
      max-width:min(96vw, 980px);
      display:flex; flex-direction:column; gap:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border:1px solid var(--stroke);
      border-radius:16px;
      box-shadow:0 10px 30px var(--shadow), inset 0 1px 0 rgba(255,255,255,0.06);
      backdrop-filter: blur(8px);
      padding:clamp(10px, 2.6vw, 18px);
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:6px 4px 4px;
    }
    .scoreboard{
      display:flex; align-items:center; justify-content:center; gap:12px;
      padding:10px 14px;
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--stroke);
      border-radius:12px;
      line-height:1;
      user-select:none;
    }
    .score{
      font-weight:800;
      font-size:clamp(20px, 5.2vw, 40px);
      letter-spacing:1px;
      background:linear-gradient(90deg, #22d3ee, #60a5fa, #a78bfa);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      filter:drop-shadow(0 2px 8px rgba(96,165,250,0.25));
      min-width:1.4em; text-align:center;
    }
    .vs{ color:var(--muted); font-weight:700; opacity:0.8; font-size:clamp(16px, 4vw, 28px);}
    .controls{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn{
      appearance:none; border:none; outline:none;
      background:linear-gradient(180deg, #1f2a44, #17233d);
      color:#fff; padding:10px 14px; border-radius:10px;
      font-weight:700; letter-spacing:0.3px;
      box-shadow:0 6px 18px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.07);
      border:1px solid rgba(255,255,255,0.08);
      cursor:pointer; transition:transform .08s ease, filter .2s ease, background .2s ease;
      touch-action:manipulation;
    }
    .btn:active{ transform:translateY(1px) scale(0.99); filter:brightness(0.95); }
    .btn.secondary{ background:linear-gradient(180deg, #17302a, #132620); }
    .hint{ font-size:clamp(12px, 2.8vw, 14px); color:var(--muted); opacity:0.9; padding:0 4px; }
    .stage{
      position:relative; width:100%; margin:2px auto 6px;
      aspect-ratio: 3 / 2;  /* Responsive game area */
      border-radius:14px; overflow:hidden;
      background:radial-gradient(800px 500px at 70% -10%, #183157 0%, transparent 60%), linear-gradient(180deg, #061226, #0a1220 50%, #061226);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 12px 40px rgba(0,0,0,0.55);
    }
    canvas#game{ width:100%; height:100%; display:block; cursor:none; }
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; pointer-events:none;
    }
    .overlay .msg{
      background:rgba(0,0,0,0.35);
      padding:10px 14px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(6px);
      color:#e5e7eb; font-weight:700; letter-spacing:0.4px;
      font-size:clamp(12px, 3.4vw, 14px);
      transform:translateY(0);
      animation: float 2.4s ease-in-out infinite;
    }
    @keyframes float { 0%,100%{ transform:translateY(0);} 50%{ transform:translateY(-4px);} }

    /* Touch thumb indicator */
    .thumb{
      position:absolute; width:44px; height:44px; border-radius:999px;
      background:radial-gradient(16px 16px at 50% 40%, rgba(255,255,255,0.25), rgba(255,255,255,0.05));
      border:1px solid rgba(255,255,255,0.18);
      box-shadow:0 8px 20px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
      pointer-events:none; transform:translate(-50%,-50%) scale(0.98);
      opacity:0; transition:opacity .15s ease, transform .08s ease;
    }
    .thumb.show{ opacity:0.85; transform:translate(-50%,-50%) scale(1); }

    /* Safe area spacing on very small screens */
    @supports (padding: max(0px)) {
      .panel{ padding-bottom:max(16px, env(safe-area-inset-bottom)); }
    }

    @media (max-width: 640px){
      .topbar{ flex-direction:column; align-items:stretch; gap:10px; }
      .controls{ justify-content:space-between; }
      canvas#game{ cursor:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" role="application" aria-label="Pong game">
      <div class="topbar">
        <div class="scoreboard" aria-live="polite">
          <span class="score" id="playerScore">0</span>
          <span class="vs">:</span>
          <span class="score" id="aiScore">0</span>
        </div>
        <div class="controls">
          <button id="btnReset" class="btn" aria-label="New Game">New Game</button>
          <button id="btnPause" class="btn secondary" aria-label="Pause or Resume">Pause</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="game"></canvas>
        <div class="overlay" id="overlay" aria-hidden="true">
          <div class="msg" id="overlayMsg">Drag on the left side to move your paddle</div>
        </div>
        <div class="thumb" id="thumb"></div>
      </div>

      <div class="hint" id="hint">
        Mouse: move to aim. Touch: drag on the left side. Keys: W/S or ↑/↓.
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const stage = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: false });
    const playerScoreEl = document.getElementById('playerScore');
    const aiScoreEl = document.getElementById('aiScore');
    const btnReset = document.getElementById('btnReset');
    const btnPause = document.getElementById('btnPause');
    const overlay = document.getElementById('overlay');
    const overlayMsg = document.getElementById('overlayMsg');
    const thumb = document.getElementById('thumb');

    const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;

    let W = 600, H = 400, DPR = 1;
    let paddleW = 10, paddleH = 80, ballR = 10;
    let aiMaxSpeed = 360; // px/s
    let playerMaxSpeed = 900; // px/s
    let baseBallSpeed = 460; // px/s
    const maxBounceDeg = 55 * Math.PI/180;

    const net = {dash: [10, 20], color:'#1f2937', width: 3};

    // Entities
    const player = { x: 0, y: 0, w: 0, h: 0, targetY: null, dy: 0 };
    const ai = { x: 0, y: 0, w: 0, h: 0, dy: 0 };
    const ball = { x: 0, y: 0, dx: 0, dy: 0, r: 0, speed: baseBallSpeed };
    let trail = [];
    const maxTrail = 12;
    const particles = [];
    let playerScore = 0, aiScore = 0;

    let paused = false;
    let serveCooldown = 0; // seconds
    let lastTime = performance.now();

    // Controls
    let upPressed = false, downPressed = false;
    let pointerActive = false;
    let pointerY = null, pointerX = null;

    // Resize and device pixel ratio handling
    function resize() {
      const rectW = stage.clientWidth;
      const rectH = stage.clientHeight;
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = Math.round(rectW * DPR);
      canvas.height = Math.round(rectH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // use CSS pixel coordinates
      W = rectW; H = rectH;

      // Recalculate sizes relative to new dimensions
      paddleW = Math.max(8, Math.round(W * 0.015));
      paddleH = Math.round(H * 0.24);
      ballR = Math.max(5, Math.round(Math.min(W,H) * 0.015));
      aiMaxSpeed = Math.max(300, H * 0.9);
      playerMaxSpeed = Math.max(800, H * 1.6);
      baseBallSpeed = Math.max(380, Math.min(900, Math.sqrt(W*W + H*H) * 0.42));

      // Update entities dimensions and positions proportionally
      const px = player.x / (player.w || 1);
      const pyRatio = (player.y + player.h/2) / (H || 1);
      const ayRatio = (ai.y + ai.h/2) / (H || 1);

      player.w = paddleW; player.h = paddleH;
      ai.w = paddleW; ai.h = paddleH;

      const offset = Math.max(12, Math.round(W * 0.025));
      player.x = offset;
      ai.x = W - offset - ai.w;

      if (!Number.isFinite(pyRatio)) {
        player.y = (H - player.h)/2;
        ai.y = (H - ai.h)/2;
      } else {
        player.y = Math.min(H - player.h, Math.max(0, pyRatio * H - player.h/2));
        ai.y = Math.min(H - ai.h, Math.max(0, ayRatio * H - ai.h/2));
      }

      ball.r = ballR;
      if (!ball.x && !ball.y) {
        centerBall();
      }
    }

    function centerBall(dir = (Math.random() < 0.5 ? -1 : 1)) {
      ball.x = W / 2; ball.y = H / 2;
      ball.speed = baseBallSpeed;
      const angle = (Math.random() * 0.5 - 0.25) * Math.PI/3; // ~-15..15 deg
      ball.dx = Math.cos(angle) * ball.speed * dir;
      ball.dy = Math.sin(angle) * ball.speed;
      trail.length = 0;
      serveCooldown = 0.6;
    }

    // Drawing helpers
    function clear() {
      ctx.clearRect(0,0,W,H);
      // subtle vignette
      const g = ctx.createRadialGradient(W/2,H*0.6, Math.min(W,H)*0.2, W/2, H/2, Math.max(W,H));
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.25)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
    }

    function drawNet() {
      ctx.save();
      ctx.setLineDash(net.dash);
      const grad = ctx.createLinearGradient(W/2,0,W/2,H);
      grad.addColorStop(0, '#143253');
      grad.addColorStop(1, '#0c203a');
      ctx.strokeStyle = grad;
      ctx.lineWidth = net.width;
      ctx.beginPath();
      ctx.moveTo(W/2,0);
      ctx.lineTo(W/2,H);
      ctx.stroke();
      ctx.restore();
    }

    function drawPaddle(p, color) {
      ctx.save();
      ctx.shadowBlur = 12;
      ctx.shadowColor = color + 'aa';
      ctx.fillStyle = color;
      const radius = Math.min(10, paddleW*0.8);
      roundRect(ctx, p.x, p.y, p.w, p.h, radius);
      ctx.fill();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawBall() {
      // trail
      for (let i = trail.length - 1; i >= 0; i--) {
        const t = trail[i];
        const alpha = (i + 1) / (trail.length + 1);
        ctx.save();
        ctx.fillStyle = `rgba(167,139,250,${alpha*0.25})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, Math.max(2, ball.r * 0.8 * alpha), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.save();
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#9ca3ff';
      const grad = ctx.createRadialGradient(ball.x - ball.r*0.3, ball.y - ball.r*0.3, 1, ball.x, ball.y, ball.r*1.2);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.2, '#e0ddff');
      grad.addColorStop(1, '#a78bfa');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i,1); continue; }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 40 * dt;
        const a = Math.max(0, p.life / p.maxLife);
        ctx.save();
        ctx.fillStyle = `rgba(${p.color},${a})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * a, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    function spawnBurst(x,y, type='hit') {
      const n = type === 'score' ? 24 : 12;
      for (let i=0;i<n;i++){
        const ang = Math.random() * Math.PI * 2;
        const spd = type === 'score' ? 200 + Math.random()*420 : 150 + Math.random()*220;
        const size = type === 'score' ? 3 + Math.random()*3 : 2 + Math.random()*2;
        const colors = type==='score' ? ['34,211,238','96,165,250','167,139,250','244,114,182'] : ['96,165,250','167,139,250','34,197,94'];
        const color = colors[(Math.random()*colors.length)|0];
        particles.push({ x, y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, size, color, life: 0.6 + Math.random()*0.4, maxLife: 0.8 });
      }
      vibrate(type === 'score' ? 35 : 12);
    }

    function vibrate(ms){
      if (navigator.vibrate) navigator.vibrate(ms);
    }

    // Physics and game update
    function update(dt) {
      // cooldown stop ball movement
      if (serveCooldown > 0) {
        serveCooldown -= dt;
      } else {
        // Add to trail
        trail.push({ x: ball.x, y: ball.y });
        if (trail.length > maxTrail) trail.shift();

        ball.x += ball.dx * dt;
        ball.y += ball.dy * dt;
      }

      // Player control
      const speed = playerMaxSpeed;
      if (upPressed) player.y -= speed * dt;
      if (downPressed) player.y += speed * dt;

      if (pointerActive && pointerX !== null) {
        // Only move if pointer is on the left 70% (avoid blocking AI)
        if (pointerX <= W * 0.75 || isCoarse) {
          const target = Math.max(0, Math.min(H - player.h, pointerY - player.h/2));
          // Smooth follow
          const diff = target - player.y;
          player.y += diff * Math.min(1, dt * 12);
        }
      }

      clampPaddle(player);
      // AI follows ball with easing
      const aiCenter = ai.y + ai.h/2;
      const desired = ball.y - ai.h/2;
      const diff = desired - ai.y;
      const aiStep = Math.sign(diff) * Math.min(Math.abs(diff), aiMaxSpeed * dt * (0.8 + Math.min(1, Math.abs(ball.dx)/baseBallSpeed)));
      ai.y += aiStep;
      clampPaddle(ai);

      // Collisions with top/bottom
      if (ball.y - ball.r < 0) {
        ball.y = ball.r;
        ball.dy = Math.abs(ball.dy);
      } else if (ball.y + ball.r > H) {
        ball.y = H - ball.r;
        ball.dy = -Math.abs(ball.dy);
      }

      // Paddle collisions
      checkPaddleCollision(player, 1);
      checkPaddleCollision(ai, -1);

      // Scoring
      if (ball.x + ball.r < 0) {
        aiScore++;
        aiScoreEl.textContent = aiScore;
        spawnBurst(20, H/2, 'score');
        centerBall(1);
      } else if (ball.x - ball.r > W) {
        playerScore++;
        playerScoreEl.textContent = playerScore;
        spawnBurst(W-20, H/2, 'score');
        centerBall(-1);
      }
    }

    function clampPaddle(p){
      if (p.y < 0) p.y = 0;
      if (p.y + p.h > H) p.y = H - p.h;
    }

    function checkPaddleCollision(paddle, dir) {
      // dir: 1 for left paddle (ball goes right after), -1 for right paddle
      if (ball.y + ball.r < paddle.y || ball.y - ball.r > paddle.y + paddle.h) return;
      if (dir === 1) { // left paddle
        if (ball.x - ball.r <= paddle.x + paddle.w && ball.x > paddle.x) {
          collide(paddle, dir);
          ball.x = paddle.x + paddle.w + ball.r + 0.5;
        }
      } else { // right paddle
        if (ball.x + ball.r >= paddle.x && ball.x < paddle.x + paddle.w) {
          collide(paddle, dir);
          ball.x = paddle.x - ball.r - 0.5;
        }
      }
    }

    function collide(paddle, dir) {
      const relativeY = (ball.y - (paddle.y + paddle.h/2)) / (paddle.h/2);
      const clamped = Math.max(-1, Math.min(1, relativeY));
      const angle = clamped * maxBounceDeg;
      ball.speed = Math.min(baseBallSpeed * 1.6, ball.speed * 1.04 + 8);
      ball.dx = Math.cos(angle) * ball.speed * dir;
      ball.dy = Math.sin(angle) * ball.speed;
      spawnBurst(ball.x, ball.y, 'hit');
    }

    // Render
    function draw(dt) {
      clear();
      drawNet();
      drawParticles(dt);
      drawPaddle(player, 'rgba(34,211,238,0.95)');
      drawPaddle(ai, 'rgba(244,114,182,0.95)');
      drawBall();
      if (paused) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = '#e5e7eb';
        ctx.font = `700 ${Math.max(18, Math.round(W * 0.05))}px ui-sans-serif, system-ui`;
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText('Paused', W/2, H/2);
        ctx.restore();
      } else if (serveCooldown > 0) {
        const t = Math.ceil(serveCooldown);
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        roundRect(ctx, W/2-26, 12, 52, 26, 8); ctx.fill();
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '700 16px ui-sans-serif';
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.fillText('Serve', W/2, 16);
        ctx.restore();
      }
    }

    // Loop
    function loop(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      if (!paused) update(dt);
      draw(dt);
      requestAnimationFrame(loop);
    }

    // Input
    window.addEventListener('resize', resize, {passive:true});

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') upPressed = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') downPressed = true;
      if (e.key === ' '){ togglePause(); }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') upPressed = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') downPressed = false;
    });

    // Pointer unified input
    canvas.addEventListener('pointerdown', (e) => {
      pointerActive = true;
      updatePointer(e);
      canvas.setPointerCapture(e.pointerId);
      showThumb(e);
      // hide overlay hint after first interaction
      overlay.style.display = 'none';
    }, {passive:true});
    canvas.addEventListener('pointermove', (e) => {
      if (!pointerActive && !isCoarse) return;
      updatePointer(e);
      showThumb(e);
    }, {passive:true});
    function updatePointer(e){
      const rect = canvas.getBoundingClientRect();
      pointerX = e.clientX - rect.left;
      pointerY = e.clientY - rect.top;
    }
    function showThumb(e){
      if (!isCoarse) { thumb.classList.remove('show'); return; }
      const rect = stage.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      thumb.style.left = x + 'px';
      thumb.style.top = y + 'px';
      thumb.classList.add('show');
    }
    canvas.addEventListener('pointerup', (e) => {
      pointerActive = false;
      thumb.classList.remove('show');
      canvas.releasePointerCapture(e.pointerId);
    }, {passive:true});
    canvas.addEventListener('pointercancel', () => {
      pointerActive = false;
      thumb.classList.remove('show');
    }, {passive:true});

    // Buttons
    btnReset.addEventListener('click', () => resetGame());
    btnPause.addEventListener('click', () => togglePause());

    function togglePause(){
      paused = !paused;
      btnPause.textContent = paused ? 'Resume' : 'Pause';
    }

    function resetGame(){
      playerScore = 0; aiScore = 0;
      playerScoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      player.y = (H - player.h)/2;
      ai.y = (H - ai.h)/2;
      centerBall(Math.random() < 0.5 ? -1 : 1);
      paused = false;
      btnPause.textContent = 'Pause';
      overlay.style.display = isCoarse ? 'flex' : 'none';
    }

    // Init
    function init(){
      resize();
      player.w = paddleW; player.h = paddleH;
      ai.w = paddleW; ai.h = paddleH;
      player.x = Math.max(12, Math.round(W * 0.025));
      ai.x = W - player.x - ai.w;
      player.y = (H - player.h)/2;
      ai.y = (H - ai.h)/2;
      centerBall(Math.random() < 0.5 ? -1 : 1);
      overlay.style.display = isCoarse ? 'flex' : 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    init();

  })();
  </script>
</body>
</html>