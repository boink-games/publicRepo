<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Frogger Neo</title>
  <style>
    :root{
      --bg1:#0b1220;
      --bg2:#0a0f1a;
      --panel:#0f172a80;
      --panel-border:#33415555;
      --text:#e5e7eb;
      --muted:#93a3b5;
      --accent:#60a5fa;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --btn:#1f2937;
      --btn-pressed:#374151;
      --glow:0 10px 25px rgba(96,165,250,.25), inset 0 0 0 1px #1f293766;
      --radius:16px;
      --shadow:0 8px 24px rgba(0,0,0,.35);
      --grid-gap:14px;
      --control-size:70px;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;margin:0}
    body{
      font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% -10%, #0b3b6a22, transparent 60%),
        radial-gradient(1000px 1000px at 120% 10%, #155e7522, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
    }
    .wrap{
      min-height:100%;
      padding: max(14px, env(safe-area-inset-top)) max(14px, env(safe-area-inset-right)) max(14px, env(safe-area-inset-bottom)) max(14px, env(safe-area-inset-left));
      display:flex; align-items:center; justify-content:center;
    }
    .panel{
      width:100%;
      max-width:min(92vh, 720px);
      margin-inline:auto;
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:calc(var(--radius) + 6px);
      box-shadow:var(--shadow);
      backdrop-filter:saturate(120%) blur(8px);
      padding:16px 16px 18px;
      display:flex; flex-direction:column; align-items:center; gap:12px;
      position:relative;
    }
    .topbar{
      width:100%;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .title{
      font-weight:800; letter-spacing:.3px;
      font-size:clamp(18px, 2.2vw, 22px);
      display:flex; align-items:center; gap:10px;
    }
    .title .dot{
      width:10px; height:10px; border-radius:50%;
      background:conic-gradient(from 0deg, #34d399, #60a5fa, #a78bfa, #34d399);
      box-shadow:0 0 12px #60a5fa88;
      animation:spin 3s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    .stats{
      display:flex; gap:18px; align-items:center; flex-wrap:wrap;
      font-weight:700; font-size:clamp(14px, 1.8vw, 16px);
      color:var(--muted);
    }
    .stat{
      background:#0b122066; border:1px solid #22304766;
      padding:6px 10px; border-radius:12px; display:flex; gap:8px; align-items:center;
    }
    .stat .val{ color:var(--accent) }
    .actions{ display:flex; gap:8px; }
    .icon-btn{
      appearance:none; border:none; cursor:pointer; border-radius:12px;
      background:linear-gradient(180deg, #101827, #0b1220);
      color:#e5e7eb; width:40px; height:40px; display:grid; place-items:center;
      box-shadow:var(--glow); transition:transform .08s ease, background .15s ease, box-shadow .2s ease;
    }
    .icon-btn:active{ transform:translateY(1px); background:#141b2b; }
    .icon-btn[aria-pressed="true"]{ outline:2px solid #60a5fa66 }

    .stage-wrap{
      width:100%; display:flex; justify-content:center; position:relative;
    }
    canvas{
      width:100%;
      aspect-ratio:1/1;
      background:#0b1220;
      border-radius:14px;
      border:1px solid #1f2937;
      box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 0 0 1px #203047;
      touch-action:none;
    }
    .overlay{
      position:absolute; inset:0; display:none; place-items:center;
      border-radius:14px;
      background:linear-gradient(180deg, #0b1220cc, #0b1220ee);
      backdrop-filter:saturate(140%) blur(6px);
    }
    .overlay.show{ display:grid }
    .overlay .card{
      text-align:center; padding:18px;
      background:#0f172a; border:1px solid #1f2937; border-radius:16px;
      box-shadow:var(--shadow);
      max-width:80%;
    }
    .overlay h2{ margin:0 0 8px; font-size:22px }
    .overlay p{ margin:0 0 14px; color:var(--muted) }
    .btn{
      appearance:none; border:none; border-radius:12px; font-weight:800; letter-spacing:.3px;
      padding:10px 16px; cursor:pointer; color:#0b1220; background:linear-gradient(180deg, #60a5fa, #3b82f6);
      box-shadow:0 8px 24px rgba(59,130,246,.35), inset 0 0 0 1px #ffffff33;
      transition:transform .08s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .info{
      font-size:13px; color:var(--muted);
      opacity:.9; margin-top:2px;
      text-align:center;
    }

    .controls{
      width:100%;
      display:grid; gap:var(--grid-gap);
      grid-template-columns:repeat(3, minmax(0, 1fr));
      justify-items:center; align-items:center;
      margin-top:8px;
      user-select:none;
    }
    .controls .pad-btn{
      width:var(--control-size); height:var(--control-size);
      max-width:22vw; max-height:22vw;
      min-width:54px; min-height:54px;
      border-radius:16px; font-size:clamp(20px, 4.5vw, 28px); font-weight:900;
      background:radial-gradient(circle at 30% 30%, #2b3c5288, #111827 60%);
      color:#fff; border:1px solid #2a3b51;
      box-shadow:var(--glow);
      display:grid; place-items:center;
      transition:transform .06s ease, filter .2s ease, background .2s ease;
      touch-action:manipulation;
    }
    .controls .pad-btn:active{ transform:scale(.98); filter:brightness(1.08) }
    .controls .empty{ visibility:hidden; width:var(--control-size); height:var(--control-size) }

    /* Larger screens: shrink controls a bit and align inline */
    @media (min-width: 820px){
      .panel{ max-width:820px; }
      :root{ --control-size:64px }
      .controls{ grid-template-columns:repeat(5, minmax(0, 1fr)); gap:18px }
      .controls .empty{ display:none }
      .controls{ justify-content:center }
    }

    /* Subtle animated starfield */
    .stars, .stars:before, .stars:after{
      content:""; position:fixed; inset:0; pointer-events:none;
      background-repeat:repeat; animation:twinkle 14s linear infinite;
      mix-blend-mode:screen; opacity:.08;
    }
    .stars{ background-image:radial-gradient(2px 2px at 20px 30px,#9ac5ff, transparent 60%), radial-gradient(1.5px 1.5px at 120px 80px,#9ac5ff, transparent 60%) }
    .stars:before{ background-image:radial-gradient(1.2px 1.2px at 70px 110px,#9ac5ff, transparent 60%), radial-gradient(1.2px 1.2px at 190px 60px,#9ac5ff, transparent 60%); animation-duration:20s }
    .stars:after{ background-image:radial-gradient(1px 1px at 160px 160px,#9ac5ff, transparent 60%), radial-gradient(1.5px 1.5px at 260px 20px,#9ac5ff, transparent 60%); animation-duration:26s }
    @keyframes twinkle { from{transform:translateY(0)} to{transform:translateY(-40px)} }
  </style>
</head>
<body>
  <div class="stars"></div>
  <div class="wrap">
    <div class="panel">
      <div class="topbar">
        <div class="title"><span class="dot"></span>Frogger Neo</div>
        <div class="stats" aria-live="polite">
          <div class="stat">Score: <span id="score" class="val">0</span></div>
          <div class="stat">Lives: <span id="lives" class="val">3</span></div>
          <div class="stat">Level: <span id="level" class="val">1</span></div>
        </div>
        <div class="actions">
          <button id="muteBtn" class="icon-btn" aria-label="Toggle sound" title="Sound">
            üîà
          </button>
          <button id="pauseBtn" class="icon-btn" aria-label="Pause / Resume" title="Pause/Resume">
            ‚è∏Ô∏è
          </button>
        </div>
      </div>

      <div class="stage-wrap">
        <canvas id="game" width="480" height="480"></canvas>
        <div id="startOverlay" class="overlay show" role="dialog" aria-modal="true">
          <div class="card">
            <h2>Hop to Safety!</h2>
            <p>Swipe, tap arrows, or use keys to guide the frog. Avoid cars, ride logs, reach the goal.</p>
            <button id="startBtn" class="btn">Tap to Start</button>
          </div>
        </div>
        <div id="gameOverOverlay" class="overlay" role="dialog" aria-modal="true">
          <div class="card">
            <h2 style="color:var(--bad); margin-bottom:6px;">Game Over</h2>
            <p>Your score: <strong id="finalScore">0</strong></p>
            <div style="display:flex; gap:10px; justify-content:center;">
              <button id="restartBtn" class="btn">Restart</button>
            </div>
          </div>
        </div>
        <div id="pauseOverlay" class="overlay" role="dialog" aria-modal="true">
          <div class="card">
            <h2>Paused</h2>
            <p>Take a breather. Cars won‚Äôt wait when you return!</p>
            <button id="resumeBtn" class="btn">Resume</button>
          </div>
        </div>
      </div>

      <div class="info">Controls: Arrow Keys ¬∑ WASD ¬∑ On-screen Pad ¬∑ Swipe on the board</div>

      <div class="controls" aria-label="On-screen controls">
        <div class="empty"></div>
        <button class="pad-btn" id="btnUp" aria-label="Move up">‚ñ≤</button>
        <div class="empty"></div>
        <button class="pad-btn" id="btnLeft" aria-label="Move left">‚óÄ</button>
        <button class="pad-btn" id="btnDown" aria-label="Move down">‚ñº</button>
        <button class="pad-btn" id="btnRight" aria-label="Move right">‚ñ∂</button>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');

    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const finalScoreEl = document.getElementById('finalScore');

    const muteBtn = document.getElementById('muteBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    let score = 0;
    let lives = 3;
    let level = 1;

    const ROWS = 12; // 0..11 (0 is goal)
    const COLS = 12;

    let gridSize = 40;
    let gameRunning = false;
    let paused = false;
    let lastTime = 0;

    const lanes = [
      { y: 11, type: 'safe',  speed: 0 },
      { y: 10, type: 'road',  speed: 1.0, dir:  1 },
      { y:  9, type: 'road',  speed: 1.5, dir: -1 },
      { y:  8, type: 'road',  speed: 1.1, dir:  1 },
      { y:  7, type: 'road',  speed: 1.9, dir: -1 },
      { y:  6, type: 'safe',  speed: 0 },
      { y:  5, type: 'water', speed: 1.0, dir:  1 },
      { y:  4, type: 'water', speed: 1.5, dir: -1 },
      { y:  3, type: 'water', speed: 1.1, dir:  1 },
      { y:  2, type: 'water', speed: 1.3, dir: -1 },
      { y:  1, type: 'water', speed: 1.5, dir:  1 },
      { y:  0, type: 'goal',  speed: 0 }
    ];

    const frog = {
      x: 0,
      y: 0,
      size: () => gridSize - 6,
      hopAnim: 0 // 0..1
    };

    let vehicles = [];
    let logs = [];

    // Audio (tiny beeps)
    let audioEnabled = false;
    let audioCtx = null;
    function beep(freq = 440, duration = 0.06, type = 'sine', gain = 0.04) {
      if (!audioEnabled) return;
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(e){ return; }
      }
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g).connect(audioCtx.destination);
      o.start();
      setTimeout(() => { o.stop(); }, duration * 1000);
    }
    function vibrate(ms = 40){ if (navigator.vibrate) navigator.vibrate(ms); }

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      // Fit to container width (panel max-width manages it). Using clientWidth.
      const display = Math.floor(canvas.clientWidth);
      const size = Math.max(320, Math.min(display, 720)); // clamp
      canvas.width = Math.floor(size * dpr);
      canvas.height = Math.floor(size * dpr);
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // grid
      gridSize = Math.floor(size / ROWS);
      alignFrogToGrid();
      // reinitialize moving objects to match new sizes
      initLevel();
      draw(); // render one frame
    }

    function alignFrogToGrid() {
      // keep frog within bounds on resize
      frog.x = Math.min(Math.max(0, frog.x), gridSize * (COLS - 1));
      frog.y = Math.min(Math.max(0, frog.y), gridSize * (ROWS - 1));
      // snap to nearest grid cell
      frog.x = Math.round(frog.x / gridSize) * gridSize;
      frog.y = Math.round(frog.y / gridSize) * gridSize;
    }

    function resetFrog() {
      frog.x = Math.floor(COLS / 2) * gridSize;
      frog.y = (ROWS - 1) * gridSize;
      frog.hopAnim = 0;
    }

    function initLevel() {
      vehicles = [];
      logs = [];

      lanes.forEach(lane => {
        if (lane.type === 'road') {
          const baseWidth = gridSize * 1.5;
          const height = gridSize - 10;
          const speedPx = lane.speed * gridSize * (1 + (level - 1) * 0.15) * lane.dir;
          const count = Math.max(3, Math.min(6, Math.round(canvas.width / (gridSize * 2.2))));
          const spacing = Math.max(gridSize * 2.2, canvas.width / count);
          for (let i = 0; i < count; i++) {
            vehicles.push({
              x: i * spacing + (Math.random() * gridSize),
              y: lane.y * gridSize,
              width: baseWidth * (0.9 + Math.random() * 0.4),
              height,
              speed: speedPx,
              color: lane.dir > 0 ? '#ef4444' : '#f97316',
              dir: lane.dir
            });
          }
        }
        if (lane.type === 'water') {
          const height = gridSize - 10;
          const speedPx = lane.speed * gridSize * (1 + (level - 1) * 0.15) * lane.dir;
          const count = Math.max(2, Math.min(4, Math.round(canvas.width / (gridSize * 3.0))));
          const spacing = Math.max(gridSize * 3.0, canvas.width / count);
          for (let i = 0; i < count; i++) {
            logs.push({
              x: i * spacing + (Math.random() * gridSize),
              y: lane.y * gridSize,
              width: gridSize * (2 + Math.random() * 1.5),
              height,
              speed: speedPx,
              color: '#8b5a2b',
              dir: lane.dir
            });
          }
        }
      });
    }

    function drawBackgroundLanes() {
      // Gradient water motion
      const t = (performance.now() / 1000);
      lanes.forEach(lane => {
        const y = lane.y * gridSize;
        if (lane.type === 'safe') {
          const g = ctx.createLinearGradient(0, y, 0, y + gridSize);
          g.addColorStop(0, '#0f1a2a');
          g.addColorStop(1, '#0b1322');
          ctx.fillStyle = g;
          ctx.fillRect(0, y, canvas.width, gridSize);
        } else if (lane.type === 'road') {
          const g = ctx.createLinearGradient(0, y, 0, y + gridSize);
          g.addColorStop(0, '#222a36');
          g.addColorStop(1, '#181f2a');
          ctx.fillStyle = g;
          ctx.fillRect(0, y, canvas.width, gridSize);
          // dashed center line
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 2;
          ctx.setLineDash([gridSize * 0.6, gridSize * 0.4]);
          ctx.beginPath();
          ctx.moveTo(0, y + gridSize / 2);
          ctx.lineTo(canvas.width, y + gridSize / 2);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (lane.type === 'water') {
          const wave = Math.sin(t * 2 + lane.y) * 6;
          const g = ctx.createLinearGradient(0, y, 0, y + gridSize);
          g.addColorStop(0, '#0c2860');
          g.addColorStop(1, '#0b2150');
          ctx.fillStyle = g;
          ctx.fillRect(0, y, canvas.width, gridSize);
          // subtle moving highlights
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = '#8ec5ff';
          for (let i = 0; i < 6; i++) {
            const yy = y + (i * gridSize / 6) + wave;
            ctx.fillRect(0, yy, canvas.width, 2);
          }
          ctx.globalAlpha = 1;
        } else if (lane.type === 'goal') {
          const g = ctx.createLinearGradient(0, y, 0, y + gridSize);
          g.addColorStop(0, '#065f46');
          g.addColorStop(1, '#064e3b');
          ctx.fillStyle = g;
          ctx.fillRect(0, y, canvas.width, gridSize);
          // lilypads hints
          const padCount = 5;
          const gap = canvas.width / padCount;
          for (let i = 0; i < padCount; i++) {
            const cx = gap * (i + 0.5);
            const cy = y + gridSize / 2;
            ctx.fillStyle = '#1abc9c';
            ctx.beginPath();
            ctx.arc(cx, cy, gridSize * 0.28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0ea5a5';
            ctx.beginPath();
            ctx.arc(cx + 4, cy - 4, gridSize * 0.12, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
    }

    function roundRect(x, y, w, h, r) {
      const rr = Math.min(r, h/2, w/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawVehicles() {
      vehicles.forEach(v => {
        const y = v.y + (gridSize - v.height) / 2;
        // body
        ctx.fillStyle = v.color;
        roundRect(v.x, y, v.width, v.height, 8);
        ctx.fill();
        // windows
        ctx.fillStyle = '#1f2937';
        roundRect(v.x + 6, y + 6, v.width - 12, v.height / 2 - 8, 6);
        ctx.fill();
        // headlights/taillights
        ctx.fillStyle = v.dir > 0 ? '#fde68a' : '#ef4444';
        ctx.fillRect(v.x + (v.dir > 0 ? v.width - 4 : 0), y + 6, 3, 8);
        ctx.fillRect(v.x + (v.dir > 0 ? v.width - 4 : 0), y + v.height - 14, 3, 8);
      });
    }

    function drawLogs() {
      logs.forEach(l => {
        const y = l.y + (gridSize - l.height) / 2;
        // wood base
        ctx.fillStyle = '#8b5a2b';
        roundRect(l.x, y, l.width, l.height, 8);
        ctx.fill();
        // wood grain lines
        ctx.strokeStyle = '#a8743a';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        const lines = 3;
        for (let i = 1; i <= lines; i++) {
          const yy = y + (i * l.height / (lines + 1));
          ctx.moveTo(l.x + 6, yy);
          ctx.lineTo(l.x + l.width - 6, yy);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      });
    }

    function drawFrog() {
      const size = frog.size();
      const hopLift = Math.sin(frog.hopAnim * Math.PI) * (gridSize * 0.12);
      const x = frog.x + 3;
      const y = frog.y + 3 - hopLift;

      // shadow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(frog.x + gridSize / 2, frog.y + gridSize - 6, size * 0.35, size * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // body
      const bodyColor = '#10b981';
      ctx.fillStyle = bodyColor;
      roundRect(x, y, size, size, 10);
      ctx.fill();

      // belly
      ctx.fillStyle = '#34d399';
      roundRect(x + size * 0.18, y + size * 0.32, size * 0.64, size * 0.5, 8);
      ctx.fill();

      // eyes
      ctx.fillStyle = '#ecfeff';
      roundRect(x + size * 0.15, y + size * 0.05, 8, 10, 4);
      ctx.fill();
      roundRect(x + size - 8 - size * 0.15, y + size * 0.05, 8, 10, 4);
      ctx.fill();
      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.arc(x + size * 0.20 + 4, y + size * 0.05 + 5, 2, 0, Math.PI * 2);
      ctx.arc(x + size - size * 0.20 - 4, y + size * 0.05 + 5, 2, 0, Math.PI * 2);
      ctx.fill();

      // outline
      ctx.strokeStyle = '#064e3b';
      ctx.lineWidth = 2;
      roundRect(x, y, size, size, 10);
      ctx.stroke();
    }

    function updateObjects(dt) {
      vehicles.forEach(v => {
        v.x += v.speed * dt;
        if (v.speed > 0 && v.x > canvas.width) v.x = -v.width;
        if (v.speed < 0 && v.x < -v.width) v.x = canvas.width;
      });
      logs.forEach(l => {
        l.x += l.speed * dt;
        if (l.speed > 0 && l.x > canvas.width) l.x = -l.width;
        if (l.speed < 0 && l.x < -l.width) l.x = canvas.width;
      });
    }

    function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function currentLaneAt(y) {
      const row = Math.floor(y / gridSize);
      return lanes.find(l => l.y === row);
    }

    function checkCollisions(dt) {
      const size = frog.size();
      const lane = currentLaneAt(frog.y);
      if (!lane) return;

      if (lane.type === 'road') {
        for (let v of vehicles) {
          const y = v.y + (gridSize - v.height) / 2;
          if (aabb(frog.x + 2, frog.y + 2, size - 4, size - 4, v.x, y, v.width, v.height)) {
            loseLife();
            return;
          }
        }
      }

      if (lane.type === 'water') {
        let onLog = false;
        for (let l of logs) {
          const y = l.y + (gridSize - l.height) / 2;
          if (aabb(frog.x + 6, frog.y + 6, size - 12, size - 12, l.x, y, l.width, l.height)) {
            onLog = true;
            frog.x += l.speed * dt;
            break;
          }
        }
        if (!onLog) {
          splashEffect();
          loseLife();
          return;
        }
      }

      if (lane.type === 'goal') {
        score += Math.round(100 * (1 + (level - 1) * 0.2));
        level++;
        scoreEl.textContent = score;
        levelEl.textContent = level;
        beep(880, 0.08, 'triangle', 0.05);
        resetFrog();
        initLevel();
      }

      // bounds
      if (frog.x < 0 || frog.x > canvas.width / (window.devicePixelRatio || 1) - gridSize) {
        loseLife();
      }
    }

    function splashEffect() {
      // simple visual hint: brief flash on water
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#93c5fd';
      ctx.beginPath();
      ctx.arc(frog.x + gridSize/2, frog.y + gridSize/2, gridSize * 0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      vibrate(50);
      beep(220, 0.08, 'square', 0.05);
      if (lives <= 0) {
        return gameOver();
      }
      resetFrog();
    }

    function gameOver() {
      gameRunning = false;
      finalScoreEl.textContent = String(score);
      gameOverOverlay.classList.add('show');
    }

    function update(dt) {
      updateObjects(dt);
      checkCollisions(dt);
      // decay hop animation
      frog.hopAnim = Math.max(0, frog.hopAnim - dt * 4);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackgroundLanes();
      drawLogs();
      drawVehicles();
      drawFrog();
    }

    function loop(ts) {
      if (!gameRunning || paused) { lastTime = ts; return; }
      const dt = Math.min(0.05, (ts - lastTime) / 1000 || 0.016);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Controls
    function addScoreForForward(dy) {
      if (dy < 0) {
        score += 10;
        scoreEl.textContent = score;
      }
    }

    function moveFrog(dx, dy) {
      if (!gameRunning || paused) return;
      const newX = frog.x + dx * gridSize;
      const newY = frog.y + dy * gridSize;
      const max = gridSize * (COLS - 1);
      if (newX >= 0 && newX <= max) frog.x = newX;
      if (newY >= 0 && newY <= gridSize * (ROWS - 1)) frog.y = newY;
      frog.hopAnim = 1;
      if (dx !== 0 || dy !== 0) {
        beep(660, 0.04, 'sine', 0.03);
        addScoreForForward(dy);
      }
    }

    // Keyboard
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(k) || ['w','a','s','d'].includes(k)) {
        e.preventDefault();
      }
      if (!gameRunning && k === ' ') {
        startGame();
        return;
      }
      if (k === 'p') { togglePause(); return; }

      if (!gameRunning || paused) return;
      if (k === 'arrowup' || k === 'w') moveFrog(0, -1);
      if (k === 'arrowdown' || k === 's') moveFrog(0, 1);
      if (k === 'arrowleft' || k === 'a') moveFrog(-1, 0);
      if (k === 'arrowright' || k === 'd') moveFrog(1, 0);
    }, { passive:false });

    // On-screen buttons with press-and-hold repeat
    function addPadRepeat(button, dx, dy) {
      let holdTimer = null, repeatTimer = null;
      const start = () => {
        moveFrog(dx, dy);
        clearTimeout(holdTimer);
        clearInterval(repeatTimer);
        holdTimer = setTimeout(() => {
          repeatTimer = setInterval(() => moveFrog(dx, dy), 200);
        }, 350);
      };
      const end = () => { clearTimeout(holdTimer); clearInterval(repeatTimer); };

      button.addEventListener('pointerdown', (e) => { e.preventDefault(); button.setPointerCapture(e.pointerId); start(); vibrate(10); });
      button.addEventListener('pointerup', end);
      button.addEventListener('pointercancel', end);
      button.addEventListener('lostpointercapture', end);
      button.addEventListener('click', (e) => e.preventDefault());
    }
    addPadRepeat(btnUp, 0, -1);
    addPadRepeat(btnDown, 0, 1);
    addPadRepeat(btnLeft, -1, 0);
    addPadRepeat(btnRight, 1, 0);

    // Swipe controls on canvas
    let swipeStart = null;
    canvas.addEventListener('pointerdown', (e) => {
      swipeStart = { x: e.clientX, y: e.clientY, t: performance.now() };
      canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointerup', (e) => {
      if (!swipeStart) return;
      const dx = e.clientX - swipeStart.x;
      const dy = e.clientY - swipeStart.y;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      const dt = performance.now() - swipeStart.t;
      const threshold = Math.max(24, canvas.clientWidth * 0.08);
      if (Math.max(absX, absY) > threshold && dt < 500) {
        if (absX > absY) moveFrog(dx > 0 ? 1 : -1, 0);
        else moveFrog(0, dy > 0 ? 1 : -1);
        vibrate(10);
      }
      swipeStart = null;
    });

    // UI actions
    function startGame() {
      if (gameRunning) return;
      score = 0; lives = 3; level = 1;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      levelEl.textContent = level;
      resetFrog();
      initLevel();
      gameRunning = true;
      paused = false;
      hideOverlays();
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function hideOverlays() {
      startOverlay.classList.remove('show');
      gameOverOverlay.classList.remove('show');
      pauseOverlay.classList.remove('show');
    }

    function restartGame() { // keep globally accessible signature
      startGame();
    }
    window.restartGame = restartGame;

    function togglePause() {
      if (!gameRunning) return;
      paused = !paused;
      pauseBtn.textContent = paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
      if (paused) {
        pauseOverlay.classList.add('show');
      } else {
        pauseOverlay.classList.remove('show');
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }
    }

    // Buttons
    startBtn.addEventListener('click', () => { audioEnabled = true; startGame(); });
    restartBtn.addEventListener('click', () => { audioEnabled = true; startGame(); });
    resumeBtn.addEventListener('click', togglePause);

    muteBtn.addEventListener('click', () => {
      audioEnabled = !audioEnabled;
      muteBtn.textContent = audioEnabled ? 'üîä' : 'üîà';
      muteBtn.setAttribute('aria-pressed', audioEnabled ? 'true' : 'false');
      if (audioEnabled) beep(880, 0.05, 'sine', 0.03);
    });
    pauseBtn.addEventListener('click', togglePause);

    // Initial sizing and start screen
    const ro = new ResizeObserver(resizeCanvas);
    ro.observe(canvas);

    // Kick off with a drawn board
    resetFrog();
    initLevel();
    draw();
  })();
  </script>
</body>
</html>