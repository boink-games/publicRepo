<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#0b0f17" />
  <title>Snake Game</title>
  <style>
    :root{
      --bg:#0b0f17;
      --bg2:#0a0d14;
      --fg:#e5e7eb;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --accent2:#22d3ee;
      --btn:#111827;
      --btn-active:#1f2937;
      --danger:#ef4444;
      --snake:#10b981;
      --snake-head:#34d399;
      --apple:#ef4444;
      --panel:#0e1421cc;
      --ring:#1f2937;
      --glow:#1e3a8a;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; background: radial-gradient(1200px 800px at 70% -10%, #13233d 0%, transparent 55%), radial-gradient(900px 600px at 0% 100%, #0d1b2a 0%, transparent 60%), linear-gradient(180deg, var(--bg), var(--bg2)); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif; }
    .wrap{ min-height:100%; display:flex; align-items:center; justify-content:center; padding:clamp(12px, 2.8vw, 24px); }
    .panel{ width:100%; max-width:min(560px, 96vw); text-align:center; padding:clamp(12px, 2vw, 16px); border-radius:20px; backdrop-filter:saturate(1.2) blur(6px); background:linear-gradient(180deg, rgba(16,23,42,0.55), rgba(8,12,22,0.55)); border:1px solid rgba(99,102,241,0.12); box-shadow:0 20px 60px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.03); }
    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:12px; }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.4px; }
    .brand .dot{ width:10px; height:10px; border-radius:50%; background:conic-gradient(from 0deg, var(--accent), var(--accent2), var(--accent)); box-shadow:0 0 18px rgba(96,165,250,0.6); }
    .stats{ display:flex; align-items:center; gap:10px; }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(148,163,184,0.08); border:1px solid rgba(148,163,184,0.18); font-weight:700; font-size:14px; color:var(--fg); }
    .pill .label{ color:var(--muted); font-weight:600; }
    .actions{ display:flex; align-items:center; gap:8px; }
    .icon-btn{ width:38px; height:38px; display:inline-grid; place-items:center; border-radius:12px; background:var(--btn); border:1px solid rgba(148,163,184,0.16); color:#fff; cursor:pointer; transition:transform .08s ease, background .2s ease, box-shadow .2s ease; box-shadow:0 4px 14px rgba(2,6,23,0.3); }
    .icon-btn:active{ transform:translateY(1px) scale(.98); background:var(--btn-active); }
    .icon-btn:focus-visible{ outline:3px solid var(--accent); outline-offset:2px; }
    .board-wrap{ position:relative; margin:auto; }
    canvas{ display:block; margin:0 auto; border-radius:18px; background:linear-gradient(180deg, #0b1220 0%, #0b1020 100%); touch-action:none; box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 2px var(--ring), 0 0 0 6px rgba(59,130,246,0.08); transition: box-shadow .25s ease; }
    canvas.pulse{ box-shadow: 0 10px 30px rgba(0,0,0,0.55), 0 0 0 2px var(--ring), 0 0 24px 10px rgba(56,189,248,0.18); }
    .hint{ position:absolute; bottom:8px; left:50%; transform:translateX(-50%); font-size:12px; color:var(--muted); background:rgba(2,6,23,0.6); border:1px solid rgba(148,163,184,0.18); padding:5px 10px; border-radius:999px; pointer-events:none; opacity:.9; }
    .banner{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
    .banner.show{ display:flex; }
    .banner .card{ padding:18px 18px; background:linear-gradient(180deg, rgba(14,23,42,0.9), rgba(8,12,22,0.9)); border:1px solid rgba(148,163,184,0.18); border-radius:16px; box-shadow:0 18px 50px rgba(0,0,0,0.55); text-align:center; max-width:85%; }
    .banner h2{ margin:0 0 8px; font-size:22px; }
    .banner p{ margin:0 0 14px; color:var(--muted); font-size:14px; }
    .banner .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .btn{ padding:10px 14px; background:linear-gradient(180deg, #1e3a8a, #1e40af); border:none; border-radius:12px; color:#fff; font-weight:800; cursor:pointer; box-shadow:0 8px 24px rgba(30,64,175,0.35); }
    .btn.alt{ background:linear-gradient(180deg, #0f172a, #0b1220); border:1px solid rgba(148,163,184,0.2); }
    .btn:focus-visible{ outline:3px solid #93c5fd; outline-offset:2px; }
    .controls{ margin-top:16px; display:grid; grid-template-columns: repeat(3, min(26vw, 92px)); gap:12px; justify-content:center; user-select:none; }
    .controls button{ padding:18px; background:radial-gradient(80% 80% at 30% 20%, rgba(255,255,255,0.06), transparent), var(--btn); color:#fff; border:1px solid rgba(148,163,184,0.18); border-radius:14px; font-size:22px; font-weight:900; cursor:pointer; line-height:1; box-shadow:0 10px 24px rgba(2,6,23,0.4); touch-action:manipulation; }
    .controls button:active{ background:var(--btn-active); transform:translateY(1px) scale(.98); }
    .controls button:focus-visible{ outline:3px solid var(--accent); outline-offset:2px; }
    .controls .empty{ visibility:hidden; }
    .score-pop{ animation: pop .25s ease; }
    @keyframes pop{ 0%{ transform:scale(1);} 50%{ transform:scale(1.2);} 100%{ transform:scale(1);} }
    .shake{ animation: shake .4s ease; }
    @keyframes shake{
      10%, 90% { transform: translateX(-1px);}
      20%, 80% { transform: translateX(2px);}
      30%, 50%, 70% { transform: translateX(-4px);}
      40%, 60% { transform: translateX(4px);}
    }
    @media (min-width:768px){
      .controls{ grid-template-columns: repeat(3, 90px); }
    }
    @media (hover:hover){
      .icon-btn:hover{ box-shadow:0 8px 26px rgba(30,64,175,0.25); }
      .controls button:hover{ box-shadow:0 12px 28px rgba(2,6,23,0.5); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" id="panel">
      <div class="topbar">
        <div class="brand"><span class="dot" aria-hidden="true"></span>Snake</div>
        <div class="stats" aria-live="polite" aria-atomic="true">
          <div class="pill" title="Score"><span class="label">Score</span><span id="score">0</span></div>
          <div class="pill" title="Best"><span class="label">Best</span><span id="best">0</span></div>
        </div>
        <div class="actions">
          <button class="icon-btn" id="pauseBtn" aria-label="Pause">
            &#10074;&#10074;
          </button>
          <button class="icon-btn" id="restartBtn" aria-label="Restart">↻</button>
        </div>
      </div>

      <div class="board-wrap">
        <canvas id="game" aria-label="Snake game board"></canvas>
        <div class="hint" id="hint">Swipe or use buttons to move</div>
        <div class="banner" id="banner" aria-live="assertive" aria-atomic="true">
          <div class="card">
            <h2 id="bannerTitle">Paused</h2>
            <p id="bannerText">Tap resume to continue.</p>
            <div class="row">
              <button class="btn" id="resumeBtn" aria-label="Resume">Resume</button>
              <button class="btn alt" id="bannerRestart" aria-label="Restart">Restart</button>
            </div>
          </div>
        </div>
      </div>

      <div class="controls" aria-label="On-screen controls">
        <div class="empty" aria-hidden="true"></div>
        <button id="up" aria-label="Move up">▲</button>
        <div class="empty" aria-hidden="true"></div>
        <button id="left" aria-label="Move left">◀</button>
        <button id="down" aria-label="Move down">▼</button>
        <button id="right" aria-label="Move right">▶</button>
      </div>
    </div>
  </div>
  <script>
    // Core elements
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const panelEl = document.getElementById('panel');
    const bannerEl = document.getElementById('banner');
    const bannerTitle = document.getElementById('bannerTitle');
    const bannerText = document.getElementById('bannerText');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const bannerRestartBtn = document.getElementById('bannerRestart');
    const hintEl = document.getElementById('hint');

    // Game settings
    const GRID = 16;
    const INITIAL_LENGTH = 4;
    const BASE_STEP = 110; // ms
    const MIN_STEP = 60;   // ms
    const SCORE_PER_APPLE = 10;

    // State
    let boardSize = 400;
    let cellCount = boardSize / GRID;
    let dpr = 1;

    const snake = { x: 160, y: 160, dx: GRID, dy: 0, cells: [], maxCells: INITIAL_LENGTH };
    const apple = { x: 320, y: 320 };

    let particles = [];
    let score = 0;
    let best = parseInt(localStorage.getItem('snake_best') || '0', 10) || 0;
    let running = false;
    let paused = false;
    let gameOver = false;

    // Timestep
    let step = BASE_STEP;
    let lastTime = 0;
    let acc = 0;

    // Utilities
    const rand = (min, max) => Math.floor(Math.random() * (max - min) + min);
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function vibrate(ms){ try{ if (navigator.vibrate) navigator.vibrate(ms); }catch(e){} }

    function roundedRect(x, y, w, h, r=4){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawGrid(){
      ctx.save();
      ctx.strokeStyle = 'rgba(148,163,184,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=GRID;i<boardSize;i+=GRID){
        ctx.moveTo(i, 0); ctx.lineTo(i, boardSize);
        ctx.moveTo(0, i); ctx.lineTo(boardSize, i);
      }
      ctx.stroke();
      ctx.restore();
    }

    let tPulse = 0;
    function drawApple(ts){
      // pulsing circle apple with small leaf
      const cx = apple.x + GRID/2;
      const cy = apple.y + GRID/2;
      const scale = 1 + 0.08 * Math.sin((ts || 0) * 0.006 + tPulse);
      const r = (GRID*0.45) * scale;

      const grad = ctx.createRadialGradient(cx-2, cy-2, r*0.2, cx, cy, r);
      grad.addColorStop(0, '#ff7b7b');
      grad.addColorStop(1, '#ef4444');

      ctx.save();
      ctx.fillStyle = grad;
      ctx.shadowColor = 'rgba(239,68,68,0.35)';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fill();

      // leaf
      ctx.translate(cx + r*0.25, cy - r*0.7);
      ctx.rotate(-0.6);
      ctx.fillStyle = '#22c55e';
      ctx.beginPath();
      ctx.ellipse(0,0, r*0.25, r*0.12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawSnake(){
      // body
      ctx.save();
      ctx.fillStyle = getSnakeColor(false);
      snake.cells.forEach((c, i) => {
        const isHead = i === 0;
        const size = GRID - 2;
        const x = c.x + 1, y = c.y + 1;
        if (isHead){
          ctx.shadowColor = 'rgba(16,185,129,0.35)';
          ctx.shadowBlur = 10;
          ctx.fillStyle = getSnakeColor(true);
          roundedRect(x, y, size, size, 5);
          ctx.fill();

          // eyes
          ctx.fillStyle = 'rgba(15,23,42,0.9)';
          const eye = Math.max(2, GRID*0.12);
          const off = GRID*0.18;
          if (snake.dx !== 0){
            ctx.beginPath(); ctx.arc(x + (snake.dx>0 ? size-off : off), y + off, eye, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + (snake.dx>0 ? size-off : off), y + size - off, eye, 0, Math.PI*2); ctx.fill();
          } else {
            ctx.beginPath(); ctx.arc(x + off, y + (snake.dy>0 ? size-off : off), eye, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + size - off, y + (snake.dy>0 ? size-off : off), eye, 0, Math.PI*2); ctx.fill();
          }
        } else {
          roundedRect(x, y, size, size, 4);
          ctx.fill();
        }
      });
      ctx.restore();
    }

    function getSnakeColor(head){
      return head ? '#34d399' : '#10b981';
    }

    function spawnParticles(x, y, color='#60a5fa'){
      const n = 12;
      for (let i=0;i<n;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 0.6 + Math.random()*2.2;
        particles.push({
          x: x + GRID/2, y: y + GRID/2,
          dx: Math.cos(a)*sp, dy: Math.sin(a)*sp,
          life: 420 + Math.random()*220,
          age: 0,
          color
        });
      }
    }

    function updateParticles(dt){
      const keep = [];
      for (let p of particles){
        p.age += dt;
        if (p.age < p.life){
          p.x += p.dx;
          p.y += p.dy;
          p.dy += 0.0015 * dt; // gravity-ish
          keep.push(p);
        }
      }
      particles = keep;
    }

    function drawParticles(){
      ctx.save();
      for (let p of particles){
        const t = 1 - (p.age / p.life);
        ctx.globalAlpha = Math.max(0, t);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, GRID*0.07 + t*2.2), 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function getRandomEmptyCell(){
      let x, y, safe = 0;
      do{
        x = rand(0, cellCount) * GRID;
        y = rand(0, cellCount) * GRID;
        safe++;
        if (safe > 500) break;
      } while (snake.cells.some(c => c.x === x && c.y === y) || (snake.x === x && snake.y === y));
      return {x, y};
    }

    function placeApple(){
      const pos = getRandomEmptyCell();
      apple.x = pos.x; apple.y = pos.y;
      tPulse = Math.random()*1000;
    }

    function bumpScore(){
      scoreEl.textContent = score;
      scoreEl.classList.remove('score-pop');
      // force reflow to restart animation
      void scoreEl.offsetWidth;
      scoreEl.classList.add('score-pop');

      canvas.classList.remove('pulse');
      void canvas.offsetWidth;
      canvas.classList.add('pulse');
      setTimeout(()=>canvas.classList.remove('pulse'), 250);
    }

    function updateSpeed(){
      const level = Math.floor(score / 50); // speed up every 5 apples
      step = clamp(BASE_STEP - level*8, MIN_STEP, BASE_STEP);
    }

    function wrap(val){
      if (val < 0) return boardSize - GRID;
      if (val >= boardSize) return 0;
      return val;
    }

    function resetSnake(){
      snake.x = Math.min(160, boardSize - GRID);
      snake.y = Math.min(160, boardSize - GRID);
      snake.dx = GRID;
      snake.dy = 0;
      snake.cells = [];
      snake.maxCells = INITIAL_LENGTH;
    }

    function setPaused(p){
      if (gameOver) return;
      paused = p;
      if (paused){
        showBanner('Paused', 'Tap resume to continue.');
        pauseBtn.textContent = '▶';
      }else{
        hideBanner();
        pauseBtn.textContent = '❚❚';
      }
    }

    function showBanner(title, text){
      bannerTitle.textContent = title;
      bannerText.textContent = text;
      bannerEl.classList.add('show');
    }
    function hideBanner(){ bannerEl.classList.remove('show'); }

    function endGame(){
      gameOver = true;
      paused = true;
      if (score > best){ best = score; localStorage.setItem('snake_best', String(best)); bestEl.textContent = best; }
      panelEl.classList.remove('shake'); void panelEl.offsetWidth; panelEl.classList.add('shake');
      showBanner('Game Over', 'You scored ' + score + '.');
      vibrate(30);
    }

    function restartGame(){
      score = 0;
      scoreEl.textContent = '0';
      gameOver = false;
      paused = false;
      resetSnake();
      placeApple();
      particles = [];
      updateSpeed();
      hideBanner();
      hintOnce();
      // restart timing
      lastTime = 0; acc = 0;
    }

    function hintOnce(){
      // show brief hint on mobile
      hintEl.style.opacity = '0.95';
      clearTimeout(hintOnce._t);
      hintOnce._t = setTimeout(()=>{ hintEl.style.opacity = '0'; }, 2400);
    }

    // Input
    function goLeft(){ if (paused || gameOver) return; if (snake.dx === 0){ snake.dx = -GRID; snake.dy = 0; } }
    function goRight(){ if (paused || gameOver) return; if (snake.dx === 0){ snake.dx = GRID; snake.dy = 0; } }
    function goUp(){ if (paused || gameOver) return; if (snake.dy === 0){ snake.dy = -GRID; snake.dx = 0; } }
    function goDown(){ if (paused || gameOver) return; if (snake.dy === 0){ snake.dy = GRID; snake.dx = 0; } }

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.code === 'Space'){ e.preventDefault(); setPaused(!paused); return; }
      if (e.key === 'Enter'){ if (gameOver) { restartGame(); } return; }
      if (paused || gameOver) return;

      if (e.key === 'ArrowLeft'){ e.preventDefault(); goLeft(); }
      else if (e.key === 'ArrowUp'){ e.preventDefault(); goUp(); }
      else if (e.key === 'ArrowRight'){ e.preventDefault(); goRight(); }
      else if (e.key === 'ArrowDown'){ e.preventDefault(); goDown(); }
    }, { passive:false });

    function bindButton(id, handler){
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); handler(); vibrate(5); }, { passive:false });
      el.addEventListener('click', (e)=>{ e.preventDefault(); handler(); });
    }
    bindButton('up', goUp);
    bindButton('down', goDown);
    bindButton('left', goLeft);
    bindButton('right', goRight);

    pauseBtn.addEventListener('click', ()=> setPaused(!paused));
    restartBtn.addEventListener('click', ()=>{ restartGame(); vibrate(10); });
    resumeBtn.addEventListener('click', ()=> setPaused(false));
    bannerRestartBtn.addEventListener('click', ()=>{ restartGame(); vibrate(10); });

    // Swipe controls
    let touchStartX = 0, touchStartY = 0, touchActive = false;
    canvas.addEventListener('touchstart', (e)=>{
      if (gameOver) return;
      const t = e.changedTouches[0];
      touchStartX = t.clientX; touchStartY = t.clientY; touchActive = true;
    }, { passive:true });
    canvas.addEventListener('touchmove', (e)=>{ if (touchActive) e.preventDefault(); }, { passive:false });
    canvas.addEventListener('touchend', (e)=>{
      if (!touchActive || gameOver) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      const threshold = 24;
      if (adx < threshold && ady < threshold){ touchActive = false; return; }
      if (adx > ady){ if (dx > 0) goRight(); else goLeft(); } else { if (dy > 0) goDown(); else goUp(); }
      touchActive = false;
    }, { passive:true });

    // Resize & DPR-aware canvas
    function sizeCanvas(){
      const padding = 24;
      const controlsSpace = 240; // score + controls + margins
      const maxSize = 560;
      const widthAvail = Math.max(180, Math.floor(window.innerWidth - padding*2));
      const heightAvail = Math.max(180, Math.floor(window.innerHeight - controlsSpace));
      let logical = Math.min(maxSize, widthAvail, heightAvail);
      logical = Math.max(160, Math.floor(logical / GRID) * GRID);

      dpr = Math.min(window.devicePixelRatio || 1, 2);
      if (boardSize !== logical || canvas._dpr !== dpr){
        boardSize = logical;
        canvas._dpr = dpr;
        // internal pixel size
        canvas.width = Math.floor(boardSize * dpr);
        canvas.height = Math.floor(boardSize * dpr);
        // CSS size
        canvas.style.width = boardSize + 'px';
        canvas.style.height = boardSize + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 1 unit = 1 CSS pixel
        cellCount = boardSize / GRID;
      }
    }

    // Game update and render
    function update(){
      // move snake
      snake.x = wrap(snake.x + snake.dx);
      snake.y = wrap(snake.y + snake.dy);

      // head
      snake.cells.unshift({ x: snake.x, y: snake.y });
      if (snake.cells.length > snake.maxCells) snake.cells.pop();

      // apple eat
      if (snake.x === apple.x && snake.y === apple.y){
        snake.maxCells++;
        score += SCORE_PER_APPLE;
        bumpScore();
        updateSpeed();
        spawnParticles(apple.x, apple.y, 'rgba(239,68,68,0.9)');
        vibrate(12);
        placeApple();
      }

      // self-collision
      for (let i=1;i<snake.cells.length;i++){
        if (snake.x === snake.cells[i].x && snake.y === snake.cells[i].y){
          endGame();
          break;
        }
      }
    }

    function render(ts=0){
      ctx.clearRect(0,0,boardSize,boardSize);
      drawGrid();
      drawApple(ts);
      drawSnake();
      drawParticles();
    }

    function loop(ts){
      if (!running){ return; }
      if (!lastTime) lastTime = ts;
      const delta = ts - lastTime;
      lastTime = ts;

      if (!paused && !gameOver){
        acc += delta;
        const maxCatchUp = 3; // prevent spiral of death
        let loops = 0;
        while (acc >= step && loops < maxCatchUp){
          update();
          acc -= step;
          loops++;
        }
        updateParticles(delta);
      }
      render(ts);
      requestAnimationFrame(loop);
    }

    // Init
    function init(){
      bestEl.textContent = best;
      sizeCanvas();
      resetSnake();
      placeApple();
      hintOnce();
      running = true; paused = false; gameOver = false;
      updateSpeed();
      requestAnimationFrame(loop);
    }

    // Resize handling: adapt and restart if grid changed
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{
        const prev = boardSize;
        sizeCanvas();
        if (boardSize !== prev){
          restartGame();
        }
      }, 120);
    }, { passive:true });

    // Start
    init();
  </script>
</body>
</html>