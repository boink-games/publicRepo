<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<title>Retro Space Invaders</title>
<style>
  :root {
    --bg1: #02030a;
    --bg2: #0a0d2a;
    --scan: rgba(255,255,255,0.03);
    --ui: #9efcff;
    --accent: #51f1d8;
    --warn: #ff4d6d;
    --good: #9cff57;
  }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: radial-gradient(1200px 800px at 50% 20%, var(--bg2), var(--bg1));
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    overscroll-behavior: none;
    touch-action: none;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
  }
  /* Subtle CRT scanline effect */
  #scanlines {
    position: fixed;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(
      to bottom,
      transparent 0px,
      transparent 2px,
      var(--scan) 3px,
      transparent 4px
    );
    mix-blend-mode: soft-light;
    opacity: .5;
  }
  /* On-screen hint zones (non-interactive, just hints) */
  .hints {
    position: fixed;
    inset: 0;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    opacity: 0.08;
    pointer-events: none;
  }
  .hints > div {
    border-left: 1px dashed #fff;
    border-right: 1px dashed #fff;
  }
  .hints span {
    position: absolute;
    bottom: 18px;
    font-weight: 700;
    font-size: 12px;
    letter-spacing: 1px;
    text-shadow: 0 1px 0 #000;
  }
  .hints .left span { left: 8px; }
  .hints .right span { right: 8px; }
  .hints .fire span { left: 50%; transform: translateX(-50%); }
  @media (min-width: 900px) {
    .hints { display: none; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="scanlines"></div>
<div class="hints">
  <div class="left"><span>LEFT</span></div>
  <div class="fire"><span>FIRE</span></div>
  <div class="right"><span>RIGHT</span></div>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.imageSmoothingEnabled = false;

  // Virtual resolution for retro look
  const VW = 320;
  const VH = 480;

  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let scale = 1, offX = 0, offY = 0;

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    scale = Math.min(window.innerWidth / VW, window.innerHeight / VH);
    offX = (window.innerWidth - VW * scale) / 2;
    offY = (window.innerHeight - VH * scale) / 2;
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Controls
  const keys = { left: false, right: false, fire: false };
  let lastFireKey = false;
  const activePointers = new Map();

  function clientToVirtual(x, y) {
    return {
      x: (x - offX) / scale,
      y: (y - offY) / scale
    };
  }

  function handlePointer(e, pressed) {
    if (e.pointerType === 'mouse' && e.button !== 0 && pressed) return;
    const id = e.pointerId || 0;
    const { x } = clientToVirtual(e.clientX, e.clientY);
    let zone = 'center';
    if (x < VW / 3) zone = 'left';
    else if (x > VW * 2 / 3) zone = 'right';
    else zone = 'center';

    if (pressed) {
      activePointers.set(id, zone);
      if (zone === 'left') keys.left = true;
      if (zone === 'right') keys.right = true;
      if (zone === 'center') triggerFire();
    } else {
      const prev = activePointers.get(id);
      activePointers.delete(id);
      if (prev === 'left') keys.left = [...activePointers.values()].includes('left');
      if (prev === 'right') keys.right = [...activePointers.values()].includes('right');
    }
  }

  canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handlePointer(e, true); }, { passive: false });
  window.addEventListener('pointerup', (e) => { e.preventDefault(); handlePointer(e, false); }, { passive: false });
  window.addEventListener('pointercancel', (e) => { e.preventDefault(); handlePointer(e, false); }, { passive: false });
  window.addEventListener('pointermove', (e) => {
    if (!activePointers.has(e.pointerId)) return;
    // Update zone if moved across boundaries
    const id = e.pointerId;
    const oldZone = activePointers.get(id);
    const { x } = clientToVirtual(e.clientX, e.clientY);
    let zone = 'center';
    if (x < VW / 3) zone = 'left';
    else if (x > VW * 2 / 3) zone = 'right';
    else zone = 'center';
    if (zone !== oldZone) {
      // Release previous
      if (oldZone === 'left') keys.left = [...activePointers.values()].filter(z => z !== oldZone).includes('left');
      if (oldZone === 'right') keys.right = [...activePointers.values()].filter(z => z !== oldZone).includes('right');
      activePointers.set(id, zone);
      if (zone === 'left') keys.left = true;
      if (zone === 'right') keys.right = true;
    }
  }, { passive: true });

  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowUp') keys.fire = true;
    if (state !== 'playing' && (e.code === 'Space' || e.code === 'Enter')) {
      startGame();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowUp') keys.fire = false;
  });

  // Random helper
  const R = {
    range(a, b) { return a + Math.random() * (b - a); },
    int(a, b) { return Math.floor(R.range(a, b + 1)); },
    choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; },
    chance(p) { return Math.random() < p; }
  };

  // Bitmap drawing for retro style
  function drawBitmap(ctx, bmp, x, y, pixel, color, flipAnim = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = color;
    const frame = bmp[flipAnim % bmp.length];
    for (let r = 0; r < frame.length; r++) {
      const row = frame[r];
      for (let c = 0; c < row.length; c++) {
        if (row[c] === 1) {
          ctx.fillRect(c * pixel, r * pixel, pixel, pixel);
        }
      }
    }
    ctx.restore();
  }

  // Define bitmaps (two frames each) for aliens and player
  const ALIEN_PIX = 2; // in virtual pixels per "pixel"
  const ALIENS = [
    // Type 0 (top row) - small squid/crab
    [
      [
        [0,1,0,0,0,1,0],
        [0,0,1,0,1,0,0],
        [0,1,1,1,1,1,0],
        [1,1,0,1,0,1,1],
        [1,1,1,1,1,1,1],
        [0,1,0,0,0,1,0]
      ],
      [
        [0,0,1,0,1,0,0],
        [0,1,0,1,0,1,0],
        [0,1,1,1,1,1,0],
        [1,1,0,1,0,1,1],
        [1,1,1,1,1,1,1],
        [0,1,0,0,0,1,0]
      ]
    ],
    // Type 1 (mid row) - crab
    [
      [
        [0,0,1,0,1,0,0],
        [0,1,0,1,0,1,0],
        [1,1,1,1,1,1,1],
        [1,0,1,1,1,0,1],
        [1,0,1,1,1,0,1],
        [0,1,0,0,0,1,0]
      ],
      [
        [0,0,1,0,1,0,0],
        [1,0,1,1,1,0,1],
        [1,1,1,1,1,1,1],
        [0,1,0,1,0,1,0],
        [0,1,0,1,0,1,0],
        [1,0,0,0,0,0,1]
      ]
    ],
    // Type 2 (bottom row) - octo
    [
      [
        [0,1,0,0,0,1,0],
        [1,0,1,0,1,0,1],
        [1,1,1,1,1,1,1],
        [0,1,1,1,1,1,0],
        [0,0,1,1,1,0,0],
        [0,1,0,0,0,1,0]
      ],
      [
        [0,1,0,0,0,1,0],
        [1,0,1,0,1,0,1],
        [1,1,1,1,1,1,1],
        [0,1,1,1,1,1,0],
        [0,1,0,1,0,1,0],
        [1,0,0,0,0,0,1]
      ]
    ]
  ];

  const PLAYER_BMP = [
    [
      [0,0,0,1,1,0,0,0],
      [0,0,1,1,1,1,0,0],
      [0,1,1,1,1,1,1,0],
      [1,1,1,1,1,1,1,1],
      [0,0,0,1,1,0,0,0]
    ]
  ];
  const PLAYER_PIX = 2;

  function bmpSize(frames, pixel) {
    const f = frames[0];
    const h = f.length;
    const w = f[0].length;
    return { w: w * pixel, h: h * pixel };
  }

  // Particle system for modern explosions
  class Particle {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      const a = R.range(0, Math.PI * 2);
      const s = R.range(30, 140);
      this.vx = Math.cos(a) * s;
      this.vy = Math.sin(a) * s - R.range(20, 80);
      this.life = R.range(0.4, 0.9);
      this.age = 0;
      this.size = R.range(1, 2.5);
      this.color = color;
    }
    update(dt) {
      this.age += dt;
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.vy += 160 * dt;
    }
    draw(ctx) {
      const t = Math.max(0, 1 - this.age / this.life);
      ctx.globalAlpha = t;
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
      ctx.globalAlpha = 1;
    }
    get dead() { return this.age >= this.life; }
  }
  const particles = [];

  // Entities
  class Bullet {
    constructor(x, y, vy, owner) {
      this.x = x;
      this.y = y;
      this.w = 2;
      this.h = 6;
      this.vy = vy;
      this.owner = owner; // 'player' or 'alien'
      this.dead = false;
      this.color = owner === 'player' ? '#9efcff' : '#ff5ea8';
    }
    update(dt) {
      this.y += this.vy * dt;
      if (this.y < -20 || this.y > VH + 20) this.dead = true;
    }
    draw(ctx) {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h);
      // glow
      ctx.globalAlpha = 0.35;
      ctx.fillRect(this.x - this.w, this.y - this.h / 2, this.w * 2, this.h);
      ctx.globalAlpha = 1;
    }
    get AABB() { return { x: this.x - this.w/2, y: this.y - this.h/2, w: this.w, h: this.h }; }
  }

  class Player {
    constructor() {
      this.size = bmpSize(PLAYER_BMP, PLAYER_PIX);
      this.x = VW/2 - this.size.w/2;
      this.y = VH - 40;
      this.speed = 140;
      this.cooldown = 0;
      this.invuln = 0;
      this.alive = true;
    }
    update(dt) {
      const move = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      this.x += move * this.speed * dt;
      this.x = Math.max(6, Math.min(VW - this.size.w - 6, this.x));
      this.cooldown = Math.max(0, this.cooldown - dt);
      this.invuln = Math.max(0, this.invuln - dt);
      if (state === 'playing') {
        if (keys.fire && !lastFireKey) triggerFire();
        lastFireKey = keys.fire;
      }
    }
    draw(ctx) {
      if (this.invuln > 0 && Math.floor(this.invuln * 20) % 2 === 0) return;
      drawBitmap(ctx, PLAYER_BMP, this.x, this.y, PLAYER_PIX, '#7af5ff', 0);
      // engine glow
      ctx.fillStyle = 'rgba(81,241,216,0.5)';
      ctx.fillRect(this.x + this.size.w/2 - 2, this.y + this.size.h, 4, 3);
    }
    shoot() {
      if (!this.alive) return;
      if (this.cooldown <= 0 && bullets.filter(b=>b.owner==='player').length < 1) {
        const bx = this.x + this.size.w/2;
        bullets.push(new Bullet(bx, this.y - 2, -240 - level*15, 'player'));
        this.cooldown = Math.max(0.18, 0.35 - level * 0.02);
      }
    }
    get AABB() { return { x: this.x, y: this.y, w: this.size.w, h: this.size.h }; }
  }

  class Alien {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type; // 0,1,2
      this.alive = true;
      const sz = bmpSize(ALIENS[type], ALIEN_PIX);
      this.w = sz.w;
      this.h = sz.h;
    }
    draw(ctx, anim) {
      const colors = ['#a1ff5e', '#7bff4a', '#5eff2a'];
      drawBitmap(ctx, ALIENS[this.type], this.x, this.y, ALIEN_PIX, colors[this.type], anim);
    }
    get AABB() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
  }

  class Swarm {
    constructor(rows, cols) {
      this.rows = rows;
      this.cols = cols;
      this.aliens = [];
      this.dir = 1;
      this.speed = 12 + level * 4;
      this.stepDown = 14;
      this.offsetX = 20;
      this.offsetY = 40;
      this.spacingX = 20;
      this.spacingY = 20;
      this.animTime = 0;
      this.fireTimer = 0;
      this.initAliens();
    }
    initAliens() {
      this.aliens = [];
      const types = [0,1,1,2,2];
      for (let r = 0; r < this.rows; r++) {
        for (let c = 0; c < this.cols; c++) {
          const ax = this.offsetX + c * (this.spacingX + bmpSize(ALIENS[2], ALIEN_PIX).w * 0.1);
          const ay = this.offsetY + r * this.spacingY;
          const type = types[Math.min(types.length-1, r)];
          const alien = new Alien(ax, ay, type);
          // Adjust spacing based on width
          alien.x = this.offsetX + c * (alien.w + 6);
          alien.y = this.offsetY + r * (alien.h + 6);
          this.aliens.push(alien);
        }
      }
    }
    bounds() {
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity, minY = Infinity;
      for (const a of this.aliens) {
        if (!a.alive) continue;
        minX = Math.min(minX, a.x);
        maxX = Math.max(maxX, a.x + a.w);
        minY = Math.min(minY, a.y);
        maxY = Math.max(maxY, a.y + a.h);
      }
      if (minX === Infinity) return { minX:0, maxX:0, maxY:0, minY:0 };
      return { minX, maxX, maxY, minY };
    }
    aliveCount() { return this.aliens.filter(a=>a.alive).length; }
    update(dt) {
      const alive = this.aliveCount();
      if (alive === 0) return;
      const accel = (1 - alive / (this.rows * this.cols)) * (18 + level * 6);
      const v = this.speed + accel;
      const moveX = v * this.dir * dt;
      for (const a of this.aliens) {
        if (!a.alive) continue;
        a.x += moveX;
      }
      const b = this.bounds();
      let hitEdge = (b.minX < 8 && this.dir < 0) || (b.maxX > VW - 8 && this.dir > 0);
      if (hitEdge) {
        this.dir *= -1;
        for (const a of this.aliens) {
          if (!a.alive) continue;
          a.y += this.stepDown;
        }
      }
      // Animation
      this.animTime += dt;
      // Firing logic
      const baseInterval = Math.max(0.7, 1.6 - level * 0.1);
      this.fireTimer -= dt * (1.0 + (1 - alive / (this.rows * this.cols)));
      if (this.fireTimer <= 0) {
        this.fireTimer = R.range(baseInterval * 0.5, baseInterval * 1.25);
        this.fireFromRandomFront();
      }
    }
    fireFromRandomFront() {
      const columns = {};
      for (const a of this.aliens) {
        if (!a.alive) continue;
        const col = Math.round((a.x - this.offsetX) / (a.w + 6));
        if (!columns[col] || columns[col].y < a.y) columns[col] = a;
      }
      const fronts = Object.values(columns);
      if (fronts.length === 0) return;
      const shooter = R.choice(fronts);
      bullets.push(new Bullet(shooter.x + shooter.w/2, shooter.y + shooter.h + 2, R.range(60 + level*10, 120 + level*20), 'alien'));
    }
    draw(ctx) {
      const frame = Math.floor(this.animTime * 6) % 2;
      for (const a of this.aliens) {
        if (!a.alive) continue;
        a.draw(ctx, frame);
      }
    }
  }

  class Barrier {
    constructor(x, y, cols=16, rows=8, cell=3) {
      this.x = x;
      this.y = y;
      this.cols = cols;
      this.rows = rows;
      this.cell = cell;
      this.grid = this.makeShape(cols, rows);
      this.color = '#6bff5b';
      this.shadow = 'rgba(107,255,91,0.35)';
    }
    makeShape(cols, rows) {
      const grid = Array.from({length: rows}, () => Array(cols).fill(1));
      // Carve a notch
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          // edges bevel
          if ((r === rows-1 && (c < 2 || c > cols-3)) ||
              (r === rows-2 && (c < 1 || c > cols-2))) grid[r][c] = 0;
        }
      }
      // central arch
      const holeW = Math.max(4, Math.floor(cols/4));
      const holeStart = Math.floor((cols - holeW)/2);
      for (let r = Math.floor(rows/2); r < rows; r++) {
        for (let c = holeStart; c < holeStart + holeW; c++) {
          grid[r][c] = 0;
        }
      }
      return grid;
    }
    draw(ctx) {
      ctx.fillStyle = this.shadow;
      ctx.fillRect(this.x, this.y+1, this.cols*this.cell, this.rows*this.cell);
      ctx.fillStyle = this.color;
      for (let r = 0; r < this.rows; r++) {
        for (let c = 0; c < this.cols; c++) {
          if (this.grid[r][c]) {
            ctx.fillRect(this.x + c*this.cell, this.y + r*this.cell, this.cell, this.cell);
          }
        }
      }
    }
    damageAt(px, py, rad=2) {
      // Convert point to grid indices
      const lx = px - this.x;
      const ly = py - this.y;
      if (lx < 0 || ly < 0 || lx > this.cols*this.cell || ly > this.rows*this.cell) return false;
      const cx = Math.floor(lx / this.cell);
      const cy = Math.floor(ly / this.cell);
      let hit = false;
      for (let r = cy - rad; r <= cy + rad; r++) {
        for (let c = cx - rad; c <= cx + rad; c++) {
          if (r < 0 || c < 0 || r >= this.rows || c >= this.cols) continue;
          const dx = c - cx, dy = r - cy;
          if (dx*dx + dy*dy <= rad*rad) {
            if (this.grid[r][c]) {
              this.grid[r][c] = 0;
              hit = true;
            }
          }
        }
      }
      return hit;
    }
    overlapsAABB(box) {
      // If any solid cell overlaps the box, report true
      const minC = Math.floor((box.x - this.x) / this.cell);
      const maxC = Math.floor((box.x + box.w - this.x) / this.cell);
      const minR = Math.floor((box.y - this.y) / this.cell);
      const maxR = Math.floor((box.y + box.h - this.y) / this.cell);
      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          if (r < 0 || c < 0 || r >= this.rows || c >= this.cols) continue;
          if (this.grid[r][c]) return true;
        }
      }
      return false;
    }
  }

  // Game globals
  let player, swarm, barriers, bullets, stars;
  let score = 0, lives = 3, level = 1;
  let state = 'menu'; // 'menu', 'playing', 'gameover', 'next'
  let stateTimer = 0;

  function initStars() {
    const count = 80;
    stars = [];
    for (let i=0;i<count;i++) {
      stars.push({
        x: R.range(0, VW),
        y: R.range(0, VH),
        s: R.range(0.5, 1.6),
        spd: R.range(10, 35)
      });
    }
  }

  function initLevel() {
    bullets = [];
    particles.length = 0;
    player = new Player();
    swarm = new Swarm(5, 8);
    barriers = [];
    const baseY = VH - 100;
    const margin = 32;
    const between = (VW - margin*2) / 4;
    for (let i=0;i<3;i++) {
      const bx = margin + (i+0.5) * between - 24;
      barriers.push(new Barrier(bx, baseY, 18, 9, 3));
    }
  }

  function startGame() {
    score = 0;
    lives = 3;
    level = 1;
    initStars();
    initLevel();
    state = 'playing';
    stateTimer = 0;
  }

  function nextLevel() {
    level++;
    initLevel();
    state = 'playing';
    stateTimer = 0;
  }

  function gameOver() {
    state = 'gameover';
    stateTimer = 0;
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function triggerFire() {
    if (state === 'menu' || state === 'gameover') {
      startGame();
      return;
    }
    if (state !== 'playing') return;
    player.shoot();
  }

  function killAlien(a) {
    a.alive = false;
    score += a.type === 0 ? 30 : a.type === 1 ? 20 : 10;
    spawnExplosion(a.x + a.w/2, a.y + a.h/2, ['#fff','#ffee58','#ffd166','#ff9e80']);
  }

  function hitPlayer() {
    if (player.invuln > 0) return;
    lives--;
    spawnExplosion(player.x + player.size.w/2, player.y + player.size.h/2, ['#fff','#90e0ef','#48cae4','#00b4d8']);
    player.invuln = 2.2;
    if (lives < 0) {
      gameOver();
    }
  }

  function spawnExplosion(x, y, palette) {
    const count = 18;
    for (let i=0;i<count;i++) {
      particles.push(new Particle(x, y, R.choice(palette)));
    }
  }

  // Main loop
  let last = 0;
  function loop(ts) {
    requestAnimationFrame(loop);
    if (!last) last = ts;
    let dt = (ts - last) / 1000;
    last = ts;
    dt = Math.min(0.033, dt);

    update(dt);
    draw();
  }
  requestAnimationFrame(loop);

  function update(dt) {
    // Update stars
    if (!stars) initStars();
    for (const s of stars) {
      s.y += s.spd * dt;
      if (s.y > VH) { s.y = -2; s.x = R.range(0, VW); }
    }

    if (state === 'menu' || state === 'gameover') {
      stateTimer += dt;
      return;
    }

    if (state === 'playing') {
      player.update(dt);
      swarm.update(dt);

      // Update bullets
      for (const b of bullets) b.update(dt);
      bullets = bullets.filter(b => !b.dead);

      // Collisions: bullets vs aliens
      for (const b of bullets) {
        if (b.owner !== 'player') continue;
        for (const a of swarm.aliens) {
          if (!a.alive) continue;
          if (rectsOverlap(b.AABB, a.AABB)) {
            b.dead = true;
            killAlien(a);
            break;
          }
        }
      }

      // Bullets vs barriers
      for (const b of bullets) {
        for (const bar of barriers) {
          if (bar.damageAt(b.x, b.y, b.owner === 'alien' ? 2 : 1)) {
            b.dead = true;
            break;
          }
        }
      }

      // Bullets vs player
      for (const b of bullets) {
        if (b.owner !== 'alien') continue;
        if (rectsOverlap(b.AABB, player.AABB)) {
          b.dead = true;
          hitPlayer();
        }
      }

      // Aliens reach barriers or player
      const bounds = swarm.bounds();
      if (bounds.maxY >= barriers[0].y - 2 || bounds.maxY >= player.y - 2) {
        // degrade overlapping barrier cells to emulate invasion
        for (const a of swarm.aliens) {
          if (!a.alive) continue;
          const box = a.AABB;
          for (const bar of barriers) {
            if (bar.overlapsAABB(box)) {
              // chew through
              bar.damageAt(a.x + a.w/2, a.y + a.h, 3);
            }
          }
        }
        if (bounds.maxY >= player.y - 10) {
          lives = -1;
          gameOver();
        }
      }

      // Clear dead bullets
      bullets = bullets.filter(b => !b.dead);

      // Win condition
      if (swarm.aliveCount() === 0) {
        state = 'next';
        stateTimer = 0;
      }

      // Update particles
      for (const p of particles) p.update(dt);
      for (let i=particles.length-1;i>=0;i--) if (particles[i].dead) particles.splice(i,1);
    } else if (state === 'next') {
      stateTimer += dt;
      for (const p of particles) p.update(dt);
      if (stateTimer > 1.2) nextLevel();
    }
  }

  function draw() {
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);

    // Letterbox and scale
    ctx.translate(offX, offY);
    ctx.scale(scale, scale);

    // Background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, VW, VH);

    // Stars
    for (const s of stars) {
      ctx.fillStyle = s.s > 1.2 ? '#aaffff' : '#9ea7ff';
      ctx.globalAlpha = 0.6 + (s.s / 2);
      ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.s, s.s);
      ctx.globalAlpha = 1;
    }

    // UI top
    drawUI();

    if (state === 'menu') {
      drawTitle();
      return;
    }

    // Barriers
    for (const b of barriers) b.draw(ctx);

    // Player
    if (lives >= 0) player.draw(ctx);

    // Swarm
    swarm.draw(ctx);

    // Bullets
    for (const b of bullets) b.draw(ctx);

    // Particles
    for (const p of particles) p.draw(ctx);

    if (state === 'next') {
      drawBanner(`Wave ${level} Cleared!`, 'Get ready...');
    }
    if (state === 'gameover') {
      drawBanner('GAME OVER', 'Tap or press Space to restart');
    }

    // On-screen control guide (subtle)
    drawZonesHint();
  }

  function drawUI() {
    // score left
    ctx.fillStyle = '#9efcff';
    ctx.font = '8px monospace';
    ctx.textBaseline = 'top';
    const pad = 6;
    drawText('SCORE: ' + score.toString().padStart(5, '0'), pad, pad, '#9efcff');
    // lives right
    let text = 'LIVES: ' + Math.max(0, lives + 1);
    drawText(text, VW - pad - measureText(text), pad, '#9efcff');
    // level center
    const levelText = 'WAVE ' + level;
    drawText(levelText, VW/2 - measureText(levelText)/2, pad, '#51f1d8');
    // subtle line
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, 16, VW, 1);
  }

  function drawZonesHint() {
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, VH-40, VW/3, 40);
    ctx.fillRect(VW/3, VH-40, VW/3, 40);
    ctx.fillRect(VW*2/3, VH-40, VW/3, 40);
    ctx.globalAlpha = 1;
    const y = VH - 31;
    drawText('LEFT', VW/6 - measureText('LEFT')/2, y, '#c7f9ff');
    drawText('FIRE', VW/2 - measureText('FIRE')/2, y, '#c7f9ff');
    drawText('RIGHT', VW*5/6 - measureText('RIGHT')/2, y, '#c7f9ff');
  }

  function drawTitle() {
    const t1 = 'SPACE INVADERS';
    const t2 = 'RETRO EDITION';
    ctx.save();
    // Glow title
    drawBigText(t1, VW/2, VH*0.26, '#9efcff');
    drawBigText(t2, VW/2, VH*0.32, '#51f1d8', 0.55);

    // Instructions
    const lines = [
      'How to Play',
      'Desktop: Arrow Keys/A,D to Move',
      'Space/Enter to Shoot',
      'Mobile: Tap Left/Right to Move',
      'Tap Center to Shoot',
      'Hide behind barriers and avoid enemy fire.'
    ];
    let y = VH*0.45;
    for (let i=0;i<lines.length;i++) {
      const c = i === 0 ? '#a7ff83' : '#d0f7ff';
      drawText(lines[i], VW/2 - measureText(lines[i])/2, y, c);
      y += 12;
    }

    const prompt = 'Tap or Press Space to Start';
    const alpha = 0.5 + 0.5 * Math.sin(perfNow()*0.005);
    ctx.globalAlpha = 0.5 + 0.5 * alpha;
    drawText(prompt, VW/2 - measureText(prompt)/2, VH*0.78, '#ffffff');
    ctx.globalAlpha = 1;

    // Minimal demo player
    ctx.restore();
  }

  function drawBanner(title, subtitle) {
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#000000';
    ctx.fillRect(20, VH/2 - 40, VW - 40, 80);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#51f1d8';
    ctx.lineWidth = 1;
    ctx.strokeRect(20.5, VH/2 - 39.5, VW - 41, 79);
    drawBigText(title, VW/2, VH/2 - 10, '#9efcff', 0.9);
    drawText(subtitle, VW/2 - measureText(subtitle)/2, VH/2 + 12, '#ffffff');
    ctx.restore();
  }

  function drawBigText(text, cx, y, color, scale=1) {
    ctx.save();
    ctx.font = `${14*scale}px monospace`;
    ctx.textBaseline = 'top';
    ctx.fillStyle = color;
    const w = ctx.measureText(text).width;
    // glow
    ctx.globalAlpha = 0.12;
    ctx.fillText(text, cx - w/2 + 1, y + 1);
    ctx.globalAlpha = 1;
    ctx.fillText(text, cx - w/2, y);
    ctx.restore();
  }

  function drawText(text, x, y, color) {
    ctx.save();
    ctx.font = '8px monospace';
    ctx.textBaseline = 'top';
    ctx.fillStyle = color;
    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillText(text, Math.floor(x)+1, Math.floor(y)+1);
    ctx.globalAlpha = 1;
    ctx.fillText(text, Math.floor(x), Math.floor(y));
    ctx.restore();
  }
  function measureText(text) {
    ctx.save();
    ctx.font = '8px monospace';
    const w = ctx.measureText(text).width;
    ctx.restore();
    return w;
  }

  function perfNow() { return performance.now(); }

  // Start at menu
  initStars();

  // Prevent context menu on long-press
  window.addEventListener('contextmenu', e => e.preventDefault());
})();
</script>
</body>
</html>